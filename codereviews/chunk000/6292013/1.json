{"files":{"net/spdy/spdy_proxy_client_socket.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":10,"is_binary":false},"net/spdy/spdy_http_stream.cc":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":22,"num_removed":5,"messages":[{"author":"willchan","author_email":"willchan@chromium.org","text":"You're reusing the same parameter for input and output. You probably shouldn't be doing this. Why don't you just change the return value?","draft":false,"lineno":271,"date":"2011-01-27 18:47:49.051117","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/01/27 18:47:49, willchan wrote:\n> You're reusing the same parameter for input and output. You probably shouldn't\n> be doing this. Why don't you just change the return value?\n\nThe function needs the status code as input and return 2 values - network status code as well as EOF flag. So we either need 1 IN parameter (status), 1 OUT parameter (eof) and a return value (write status), or 1 IN/OUT parameter and a return value as I have done here. I'm fine either way, so I can change it to the first if you prefer so.","draft":false,"lineno":271,"date":"2011-01-27 20:42:09.895467","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/01/27 20:42:09, Satish wrote:\n> On 2011/01/27 18:47:49, willchan wrote:\n> > You're reusing the same parameter for input and output. You probably shouldn't\n> > be doing this. Why don't you just change the return value?\n> \n> The function needs the status code as input and return 2 values - network status\n> code as well as EOF flag. So we either need 1 IN parameter (status), 1 OUT\n> parameter (eof) and a return value (write status), or 1 IN/OUT parameter and a\n> return value as I have done here. I'm fine either way, so I can change it to the\n> first if you prefer so.\n\nOK, I see what's going on here. You should probably be changing SpdyStream::DoSendBodyComplete() to go back to DoSendBody() if there is still more data to be written. You should not be writting data here in SpdyHttpStream::OnSendBodyComplete().","draft":false,"lineno":271,"date":"2011-01-28 00:56:17.241378","left":false}],"id":7,"is_binary":false},"net/spdy/spdy_http_stream.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":8,"is_binary":false},"net/spdy/spdy_proxy_client_socket.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":11,"is_binary":false},"net/http/http_stream_parser.cc":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":32,"num_removed":7,"messages":[{"author":"Satish","author_email":"satish@chromium.org","text":"We use \"chunk_data_length_\" here because UploadDataStream only has the data and not the chunk header+footer. For e.g. If the chunk data was 100 bytes long we'll be sending 106 bytes (2 byte len, 2 crlfs, data) over the wire and result will be 106 here.. but we should be consuming only 100 bytes from UploadDataStream","draft":false,"lineno":276,"date":"2011-01-26 22:36:33.278144","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/01/26 22:36:33, Satish wrote:\n> We use \"chunk_data_length_\" here because UploadDataStream only has the data and\n> not the chunk header+footer. For e.g. If the chunk data was 100 bytes long we'll\n> be sending 106 bytes (2 byte len, 2 crlfs, data) over the wire and result will\n> be 106 here.. but we should be consuming only 100 bytes from UploadDataStream\n\nThis is buggy. ClientSocket::Write() may not write all bytes. It might only partially write.\n\nI think the correct way to do this is to only call MarkConsumedAndFillBuffer() when you've successfully written the full chunk.\n\nGoing further, it seems to be that we should stop calling this MarkConsumedAndFillBuffer() and redo the functionality. Perhaps it'd be better to have something like int int GetNextBuffer(scoped_refptr<IOBufferWithSize>* buf, CompletionCallback* callback);\n\nThen it'd return ERR_IO_PENDING if the buffer is not yet available. Otherwise, it'd return the number of bytes. 0 should mean EOF.","draft":false,"lineno":276,"date":"2011-01-27 18:47:49.050985","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"> This is buggy. ClientSocket::Write() may not write all bytes. It might only\n> partially write.\n> \n> I think the correct way to do this is to only call MarkConsumedAndFillBuffer()\n> when you've successfully written the full chunk.\n\nOk. I can stash the number of bytes given to Write() in a member var, decrement it by the value received by OnIOComplete() and call DoLoop() only when it reaches zero. Is that ok or do you have other suggestions?\n\n> Going further, it seems to be that we should stop calling this\n> MarkConsumedAndFillBuffer() and redo the functionality. Perhaps it'd be better\n> to have something like int int GetNextBuffer(scoped_refptr<IOBufferWithSize>*\n> buf, CompletionCallback* callback);\n> \n> Then it'd return ERR_IO_PENDING if the buffer is not yet available. Otherwise,\n> it'd return the number of bytes. 0 should mean EOF.\n\nSounds good. This seems like a general change in UploadDataStream and not related to SPDY. Can I do it in a subsequent CL? This also requires that UploadDataStream will now implement ChunkCallback and receive the call from UploadData, and in turn invoke the CompletionCallback you mention above. That would be a self contained change on its own.","draft":false,"lineno":276,"date":"2011-01-27 20:42:09.895326","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/01/27 20:42:09, Satish wrote:\n> > This is buggy. ClientSocket::Write() may not write all bytes. It might only\n> > partially write.\n> > \n> > I think the correct way to do this is to only call MarkConsumedAndFillBuffer()\n> > when you've successfully written the full chunk.\n> \n> Ok. I can stash the number of bytes given to Write() in a member var, decrement\n> it by the value received by OnIOComplete() and call DoLoop() only when it\n> reaches zero. Is that ok or do you have other suggestions?\n\nI'm not sure I follow. Write() with 10 bytes may have a return value of 3. In order to complete it, you need to call Write() again, with the buffer index incremented by 3, and the number of bytes to write changed to 7. When OnIOComplete(result) is called, there's no way to know which state you're in. It could be a Read() that is completing. So you have to call DoLoop() to enter the state machine so you know that it's the return value for Write().\n\nI think you need to expand the number of states in the state machine. And the state machine will be easier to understand if you implement my suggestion below wrt UploadDataStream::MarkConsumedAndFillBuffer() vs UploadDataStream::GetNextBuffer().\n\nI think you need states like.\nSTATE_GET_BODY,\nSTATE_GET_BODY_COMPLETE,\nSTATE_SEND_BODY,\nSTATE_SEND_BODY_COMPLETE\n\nSTATE_GET_BODY calls request_body_->GetNextBuffer(). Pass the return value to STATE_GET_BODY_COMPLETE\nIn STATE_GET_BODY_COMPLETE, if the result is positive, go straight to STATE_SEND_BODY. If the result is negative, it must be ERR_IO_PENDING, mark the next state as STATE_SEND_BODY, and then bail out of the state machine. We'll continue when it comes back.\nIn STATE_SEND_BODY_COMPLETE, if we're sent the whole chunk, go to STATE_GET_BODY. Otherwise, go to back to STATE_SEND_BODY.\n\n> \n> > Going further, it seems to be that we should stop calling this\n> > MarkConsumedAndFillBuffer() and redo the functionality. Perhaps it'd be better\n> > to have something like int int GetNextBuffer(scoped_refptr<IOBufferWithSize>*\n> > buf, CompletionCallback* callback);\n> > \n> > Then it'd return ERR_IO_PENDING if the buffer is not yet available. Otherwise,\n> > it'd return the number of bytes. 0 should mean EOF.\n> \n> Sounds good. This seems like a general change in UploadDataStream and not\n> related to SPDY. Can I do it in a subsequent CL? This also requires that\n> UploadDataStream will now implement ChunkCallback and receive the call from\n> UploadData, and in turn invoke the CompletionCallback you mention above. That\n> would be a self contained change on its own.\n\n","draft":false,"lineno":276,"date":"2011-01-28 00:56:17.241217","left":false}],"id":5,"is_binary":false},"net/spdy/spdy_stream_unittest.cc":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":15,"is_binary":false},"net/base/upload_data_stream.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":0,"messages":[],"id":4,"is_binary":false},"net/spdy/spdy_stream.cc":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":17,"num_removed":5,"messages":[],"id":13,"is_binary":false},"net/spdy/spdy_session.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":12,"is_binary":false},"net/spdy/spdy_http_utils.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":3,"num_removed":1,"messages":[],"id":9,"is_binary":false},"net/base/upload_data_stream.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[{"author":"Satish","author_email":"satish@chromium.org","text":"This check is required because accessing \"d[0]\" below when d is empty will throw an exception","draft":false,"lineno":72,"date":"2011-01-26 22:36:33.277989","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/01/26 22:36:33, Satish wrote:\n> This check is required because accessing \"d[0]\" below when d is empty will throw\n> an exception\n\nI wonder if it'd be simpler to do:\nif (!bytes_copied)\n  break;\n\nNot sure what you think here.","draft":false,"lineno":72,"date":"2011-01-27 18:47:49.050826","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/01/27 18:47:49, willchan wrote:\n> On 2011/01/26 22:36:33, Satish wrote:\n> > This check is required because accessing \"d[0]\" below when d is empty will\n> throw\n> > an exception\n> \n> I wonder if it'd be simpler to do:\n> if (!bytes_copied)\n>   break;\n> \n> Not sure what you think here.\n\nSure could do that.","draft":false,"lineno":72,"date":"2011-01-27 20:42:09.895097","left":false}],"id":3,"is_binary":false},"net/spdy/spdy_stream.h":{"status":"M","num_chunks":5,"no_base_file":false,"property_changes":"","num_added":10,"num_removed":2,"messages":[],"id":14,"is_binary":false},"net/base/upload_data.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":0,"num_removed":5,"messages":[],"id":2,"is_binary":false},"net/http/http_stream_parser.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":4,"num_removed":0,"messages":[],"id":6,"is_binary":false}},"owner_email":"satish@chromium.org","owner":"Satish","message":null,"try_job_results":[],"created":"2011-01-26 22:33:03.266013","url":null,"num_comments":10,"modified":"2011-01-28 00:56:17.308969","patchset":1,"issue":6292013}