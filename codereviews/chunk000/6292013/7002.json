{"files":{"net/spdy/spdy_proxy_client_socket.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":10009,"is_binary":false},"net/spdy/spdy_http_stream.cc":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":35,"num_removed":6,"messages":[{"author":"willchan","author_email":"willchan@chromium.org","text":"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Function_Calls#Function_Calls\nYou need to align your parameters on the second line.","draft":false,"lineno":273,"date":"2011-02-01 23:35:59.505957","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"I'm confused how this works. OK == 0. You set *status to OK a few lines before. How does this ever make progress?\n\nAt this point, we've gone through enough of the design. You need to add tests to show this stuff works.","draft":false,"lineno":284,"date":"2011-02-01 23:35:59.506083","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/02/01 23:35:59, willchan wrote:\n> http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Function_Calls#Function_Calls\n> You need to align your parameters on the second line.\n\nDone.","draft":false,"lineno":273,"date":"2011-02-22 14:25:44.014877","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/02/01 23:35:59, willchan wrote:\n> I'm confused how this works. OK == 0. You set *status to OK a few lines before.\n> How does this ever make progress?\n> \n> At this point, we've gone through enough of the design. You need to add tests to\n> show this stuff works.\n\nThis was a last minute copy/paste error, fixed now.","draft":false,"lineno":284,"date":"2011-02-22 14:25:44.015039","left":false}],"id":10006,"is_binary":false},"net/spdy/spdy_http_stream.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":4,"num_removed":1,"messages":[],"id":10007,"is_binary":false},"net/spdy/spdy_proxy_client_socket.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[{"author":"willchan","author_email":"willchan@chromium.org","text":"If you're ignoring the parameter, please document it properly. See http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Function_Declarations_and_Definitions#Function_Declarations_and_Definitions which says:\n\"\"\"\n// Comment out unused named parameters in definitions.\nvoid Circle::Rotate(double /*radians*/) {}\n\"\"\"","draft":false,"lineno":98,"date":"2011-02-01 23:35:59.506209","left":false}],"id":10010,"is_binary":false},"net/http/http_stream_parser.cc":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":54,"num_removed":9,"messages":[{"author":"willchan","author_email":"willchan@chromium.org","text":"Please add a bunch of assertions to validate this function works correctly. I'll give some examples below.\n\nI also feel like we have a lot of unnecessary request_body_->MarkConsumedAndFillBuffer(0) calls. A stricter UploadDataStream implementation should probably disallow this. Is there a way to rework this code so we don't have to call it with 0?","draft":false,"lineno":276,"date":"2011-02-01 23:35:59.505566","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"You need to use memmove instead of memcpy because you have overlapping memory regions.\n\nRather than having to do copies, how about just incrementing an index pointer to keep track of where you are in the buffer?","draft":false,"lineno":280,"date":"2011-02-01 23:35:59.505692","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"Why don't you use a single sprintf() call? Something like:\nsprintf(\"%X\\r\\n%*s\\r\\n\", buf_len, buf_len, request_body_->buf()->data())? It's annoying to have to read the destination pointers each time to make sure you have the indices calculated correctly.","draft":false,"lineno":300,"date":"2011-02-01 23:35:59.505828","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"> I also feel like we have a lot of unnecessary\n> request_body_->MarkConsumedAndFillBuffer(0) calls. A stricter UploadDataStream\n> implementation should probably disallow this. Is there a way to rework this code\n> so we don't have to call it with 0?\n\nIn the newly added code MarkConsumedAndFillBuffer() is never called with zero. Can you clarify which code flow you thought results in such calls?","draft":false,"lineno":276,"date":"2011-02-22 14:25:44.014380","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/02/01 23:35:59, willchan wrote:\n> You need to use memmove instead of memcpy because you have overlapping memory\n> regions.\n\nDone\n\n> Rather than having to do copies, how about just incrementing an index pointer to\n> keep track of where you are in the buffer?\n\nThe net::Socket::Write call in the next line only takes an IOBuffer and writes the whole buffer out, so there is no easy way to use an index here.. unless I change that to use a DrainableIOBuffer or something similar which is a larger change.","draft":false,"lineno":280,"date":"2011-02-22 14:25:44.014545","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/02/01 23:35:59, willchan wrote:\n> Why don't you use a single sprintf() call? Something like:\n> sprintf(\"%X\\r\\n%*s\\r\\n\", buf_len, buf_len, request_body_->buf()->data())? It's\n> annoying to have to read the destination pointers each time to make sure you\n> have the indices calculated correctly.\n\nMSDN says that for %s 'characters are printed up to the first null character or until the precision value is reached' - so if there was a zero byte in the buffer only so many characters will be printed. Hence I'm doing the memcpy myself","draft":false,"lineno":300,"date":"2011-02-22 14:25:44.014706","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/02/22 14:25:44, Satish wrote:\n> > I also feel like we have a lot of unnecessary\n> > request_body_->MarkConsumedAndFillBuffer(0) calls. A stricter UploadDataStream\n> > implementation should probably disallow this. Is there a way to rework this\n> code\n> > so we don't have to call it with 0?\n> \n> In the newly added code MarkConsumedAndFillBuffer() is never called with zero.\n> Can you clarify which code flow you thought results in such calls?\n\nI don't recall the control flow =/ I looked at don't see it, so maybe I was just wrong before? I hope I didn't miss it on the re-read.","draft":false,"lineno":276,"date":"2011-02-24 19:03:39.774460","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/02/22 14:25:44, Satish wrote:\n> On 2011/02/01 23:35:59, willchan wrote:\n> > You need to use memmove instead of memcpy because you have overlapping memory\n> > regions.\n> \n> Done\n> \n> > Rather than having to do copies, how about just incrementing an index pointer\n> to\n> > keep track of where you are in the buffer?\n> \n> The net::Socket::Write call in the next line only takes an IOBuffer and writes\n> the whole buffer out, so there is no easy way to use an index here.. unless I\n> change that to use a DrainableIOBuffer or something similar which is a larger\n> change.\n\nDrainableIOBuffer is the right solution here. Of course, UploadDataStream is creating the IOBuffer, rather than using a user-provided buffer. UGH.","draft":false,"lineno":280,"date":"2011-02-24 19:03:39.774663","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/02/22 14:25:44, Satish wrote:\n> On 2011/02/01 23:35:59, willchan wrote:\n> > Why don't you use a single sprintf() call? Something like:\n> > sprintf(\"%X\\r\\n%*s\\r\\n\", buf_len, buf_len, request_body_->buf()->data())? It's\n> > annoying to have to read the destination pointers each time to make sure you\n> > have the indices calculated correctly.\n> \n> MSDN says that for %s 'characters are printed up to the first null character or\n> until the precision value is reached' - so if there was a zero byte in the\n> buffer only so many characters will be printed. Hence I'm doing the memcpy\n> myself\n\nDoh, I forgot about the NUL. You're absolutely correct.\n\nMy style preference would be for you to chunk_ptr += length, after each memcpy, but I don't feel strongly. What you have is ok too.","draft":false,"lineno":300,"date":"2011-02-24 19:03:39.774861","left":false}],"id":10004,"is_binary":false},"net/spdy/spdy_stream_unittest.cc":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":10014,"is_binary":false},"net/base/upload_data_stream.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":0,"messages":[{"author":"willchan","author_email":"willchan@chromium.org","text":"It's annoying we have to expose this. We should just be returning a IOBufferWithSize for the consumer to take. Or write to a buffer that they provide.\n\nPlease leave a TODO to fix this, so people will know not to use this.","draft":false,"lineno":29,"date":"2011-02-01 23:35:59.505436","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"> It's annoying we have to expose this. We should just be returning a\n> IOBufferWithSize for the consumer to take. Or write to a buffer that they\n> provide.\n> \n> Please leave a TODO to fix this, so people will know not to use this.\n\nWe don't write to a buffer provided by the caller, but the caller indeed copies the data to their own IOBuffer. To do that the caller needs to know how large the IOBuffer should be allocated for, hence this method. The alternative is to pass this constant as a parameter at creation time which looks uglier because the consumer and creator of this object are different classes. Since this is primarily used to avoid unwanted allocations and just use the same IOBuffer in http_stream_parser, I'm not sure why you feel this is ugly. A caller who sends the IOBuffer as a whole doesn't care about this method at all.","draft":false,"lineno":29,"date":"2011-02-22 14:25:44.014209","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/02/22 14:25:44, Satish wrote:\n> > It's annoying we have to expose this. We should just be returning a\n> > IOBufferWithSize for the consumer to take. Or write to a buffer that they\n> > provide.\n> > \n> > Please leave a TODO to fix this, so people will know not to use this.\n> \n> We don't write to a buffer provided by the caller, but the caller indeed copies\n> the data to their own IOBuffer. To do that the caller needs to know how large\n> the IOBuffer should be allocated for, hence this method. The alternative is to\n> pass this constant as a parameter at creation time which looks uglier because\n> the consumer and creator of this object are different classes. Since this is\n> primarily used to avoid unwanted allocations and just use the same IOBuffer in\n> http_stream_parser, I'm not sure why you feel this is ugly. A caller who sends\n> the IOBuffer as a whole doesn't care about this method at all.\n\nI was thinking that instead of an interface like MarkConsumedAndFillBuffer(), we'd have something like a int Read(num_bytes, buf, callback) member function. The user provides a IOBuffer with the appropriate max size specified by \"num_bytes\". The return value indicates the size that was populated by UploadDataStream.\n\nA MarkConsumedAndFillBuffer() member function dictates that UploadDataStream owns the IOBuffer, which is just lent out to the caller to read temporarily. This means that when MarkConsumedAndFillBuffer() is called, UploadDataStream has to do a memmove. Ew, why?\n\nUsers should provide their own buffer. They can either use new buffers and keep calling Read() to populate the new buffers, or they can finishing using their first buffer and then pass that same buffer to Read(). Why does UploadDataStream dictate the Read() size? Shouldn't callers be in control of how much data they want to read at a time?","draft":false,"lineno":29,"date":"2011-02-24 19:03:39.774225","left":false}],"id":10003,"is_binary":false},"net/spdy/spdy_stream.cc":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":17,"num_removed":5,"messages":[],"id":10012,"is_binary":false},"net/spdy/spdy_session.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[{"author":"willchan","author_email":"willchan@chromium.org","text":"Why is it a DCHECK_GE now?","draft":false,"lineno":635,"date":"2011-02-01 23:35:59.506335","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/02/01 23:35:59, willchan wrote:\n> Why is it a DCHECK_GE now?\n\nPer the SPDY spec the last chunk is indicated with a SPDY frame with no data, so 'result' here would be teh same as SpdyFrame::size(). Hence changing GT to GE","draft":false,"lineno":635,"date":"2011-02-22 14:25:44.015204","left":false}],"id":10011,"is_binary":false},"net/spdy/spdy_http_utils.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":3,"num_removed":1,"messages":[],"id":10008,"is_binary":false},"net/base/upload_data_stream.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[{"author":"Satish","author_email":"satish@chromium.org","text":"I left this as is because we need to set 'advance_to_next_element' to true below and doing a break here means we have to duplicate that here as well.","draft":false,"lineno":72,"date":"2011-01-28 17:37:51.586673","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"On 2011/01/28 17:37:51, Satish wrote:\n> I left this as is because we need to set 'advance_to_next_element' to true below\n> and doing a break here means we have to duplicate that here as well.\n\nWell, maybe buf_len_ += bytes_copied should be included in the if condition then.","draft":false,"lineno":72,"date":"2011-02-01 23:35:59.505291","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/02/01 23:35:59, willchan wrote:\n> On 2011/01/28 17:37:51, Satish wrote:\n> > I left this as is because we need to set 'advance_to_next_element' to true\n> below\n> > and doing a break here means we have to duplicate that here as well.\n> \n> Well, maybe buf_len_ += bytes_copied should be included in the if condition\n> then.\n\nDone.","draft":false,"lineno":72,"date":"2011-02-22 14:25:44.013978","left":false}],"id":10002,"is_binary":false},"net/spdy/spdy_stream.h":{"status":"M","num_chunks":5,"no_base_file":false,"property_changes":"","num_added":10,"num_removed":2,"messages":[{"author":"willchan","author_email":"willchan@chromium.org","text":"Change this to be more consistent with the rest of the network stack code. If it needs to return a net error code, return it using the return value. Use a bool* output parameter for the eof status. Please update the comments too.","draft":false,"lineno":58,"date":"2011-02-01 23:35:59.506462","left":false},{"author":"willchan","author_email":"willchan@chromium.org","text":"Please comment this.","draft":false,"lineno":79,"date":"2011-02-01 23:35:59.506589","left":false},{"author":"Satish","author_email":"satish@chromium.org","text":"On 2011/02/01 23:35:59, willchan wrote:\n> Change this to be more consistent with the rest of the network stack code. If it\n> needs to return a net error code, return it using the return value. Use a bool*\n> output parameter for the eof status. Please update the comments too.\n\nDone.","draft":false,"lineno":58,"date":"2011-02-22 14:25:44.015366","left":false}],"id":10013,"is_binary":false},"net/base/upload_data.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":0,"num_removed":5,"messages":[],"id":10001,"is_binary":false},"net/http/http_stream_parser.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":0,"messages":[],"id":10005,"is_binary":false}},"owner_email":"satish@chromium.org","owner":"Satish","message":".","try_job_results":[],"created":"2011-01-28 17:36:29.297263","url":null,"num_comments":25,"modified":"2011-02-24 19:03:39.808884","patchset":7002,"issue":6292013}