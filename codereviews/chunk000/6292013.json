{"description":"Add chunked uploads support to SPDY\r\n\r\nAs part of this, I had to move the chunked encoding part from UploadData::Element::SetChunk\r\nto HttpStreamParser::DoSendBody as SPDY doesn't have this encoded format and UploadData\r\nneeds to serve both.\r\n\r\nBUG=none\r\nTEST=net_unittests (2 new tests added)\r\n\r\nCommitted and rolled back: http://src.chromium.org/viewvc/chrome?view=rev&revision=76892\n\nCommitted: http://src.chromium.org/viewvc/chrome?view=rev&revision=76930","cc":["chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"reviewers":["willchan@chromium.org"],"messages":[{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"","disapproval":false,"date":"2011-01-26 22:33:52.349739","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/1/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/base/upload_data_stream.cc#newcode72\nnet/base/upload_data_stream.cc:72: if (bytes_copied)\nThis check is required because accessing \"d[0]\" below when d is empty will throw an exception\n\nhttp://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc#newcode276\nnet/http/http_stream_parser.cc:276: chunk_data_length_ : result);\nWe use \"chunk_data_length_\" here because UploadDataStream only has the data and not the chunk header+footer. For e.g. If the chunk data was 100 bytes long we'll be sending 106 bytes (2 byte len, 2 crlfs, data) over the wire and result will be 106 here.. but we should be consuming only 100 bytes from UploadDataStream","disapproval":false,"date":"2011-01-26 22:36:33.277804","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"My instinct here is that UploadDataStream isn't designed correctly for our needs. I think the interface should be changed.\n\nhttp://codereview.chromium.org/6292013/diff/1/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/base/upload_data_stream.cc#newcode72\nnet/base/upload_data_stream.cc:72: if (bytes_copied)\nOn 2011/01/26 22:36:33, Satish wrote:\n> This check is required because accessing \"d[0]\" below when d is empty will throw\n> an exception\n\nI wonder if it'd be simpler to do:\nif (!bytes_copied)\n  break;\n\nNot sure what you think here.\n\nhttp://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc#newcode276\nnet/http/http_stream_parser.cc:276: chunk_data_length_ : result);\nOn 2011/01/26 22:36:33, Satish wrote:\n> We use \"chunk_data_length_\" here because UploadDataStream only has the data and\n> not the chunk header+footer. For e.g. If the chunk data was 100 bytes long we'll\n> be sending 106 bytes (2 byte len, 2 crlfs, data) over the wire and result will\n> be 106 here.. but we should be consuming only 100 bytes from UploadDataStream\n\nThis is buggy. ClientSocket::Write() may not write all bytes. It might only partially write.\n\nI think the correct way to do this is to only call MarkConsumedAndFillBuffer() when you've successfully written the full chunk.\n\nGoing further, it seems to be that we should stop calling this MarkConsumedAndFillBuffer() and redo the functionality. Perhaps it'd be better to have something like int int GetNextBuffer(scoped_refptr<IOBufferWithSize>* buf, CompletionCallback* callback);\n\nThen it'd return ERR_IO_PENDING if the buffer is not yet available. Otherwise, it'd return the number of bytes. 0 should mean EOF.\n\nhttp://codereview.chromium.org/6292013/diff/1/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/spdy/spdy_http_stream.cc#newcode271\nnet/spdy/spdy_http_stream.cc:271: bool SpdyHttpStream::OnSendBodyComplete(int* status) {\nYou're reusing the same parameter for input and output. You probably shouldn't be doing this. Why don't you just change the return value?","disapproval":false,"date":"2011-01-27 18:47:48.506272","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/1/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/base/upload_data_stream.cc#newcode72\nnet/base/upload_data_stream.cc:72: if (bytes_copied)\nOn 2011/01/27 18:47:49, willchan wrote:\n> On 2011/01/26 22:36:33, Satish wrote:\n> > This check is required because accessing \"d[0]\" below when d is empty will\n> throw\n> > an exception\n> \n> I wonder if it'd be simpler to do:\n> if (!bytes_copied)\n>   break;\n> \n> Not sure what you think here.\n\nSure could do that.\n\nhttp://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc#newcode276\nnet/http/http_stream_parser.cc:276: chunk_data_length_ : result);\n> This is buggy. ClientSocket::Write() may not write all bytes. It might only\n> partially write.\n> \n> I think the correct way to do this is to only call MarkConsumedAndFillBuffer()\n> when you've successfully written the full chunk.\n\nOk. I can stash the number of bytes given to Write() in a member var, decrement it by the value received by OnIOComplete() and call DoLoop() only when it reaches zero. Is that ok or do you have other suggestions?\n\n> Going further, it seems to be that we should stop calling this\n> MarkConsumedAndFillBuffer() and redo the functionality. Perhaps it'd be better\n> to have something like int int GetNextBuffer(scoped_refptr<IOBufferWithSize>*\n> buf, CompletionCallback* callback);\n> \n> Then it'd return ERR_IO_PENDING if the buffer is not yet available. Otherwise,\n> it'd return the number of bytes. 0 should mean EOF.\n\nSounds good. This seems like a general change in UploadDataStream and not related to SPDY. Can I do it in a subsequent CL? This also requires that UploadDataStream will now implement ChunkCallback and receive the call from UploadData, and in turn invoke the CompletionCallback you mention above. That would be a self contained change on its own.\n\nhttp://codereview.chromium.org/6292013/diff/1/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/spdy/spdy_http_stream.cc#newcode271\nnet/spdy/spdy_http_stream.cc:271: bool SpdyHttpStream::OnSendBodyComplete(int* status) {\nOn 2011/01/27 18:47:49, willchan wrote:\n> You're reusing the same parameter for input and output. You probably shouldn't\n> be doing this. Why don't you just change the return value?\n\nThe function needs the status code as input and return 2 values - network status code as well as EOF flag. So we either need 1 IN parameter (status), 1 OUT parameter (eof) and a return value (write status), or 1 IN/OUT parameter and a return value as I have done here. I'm fine either way, so I can change it to the first if you prefer so.","disapproval":false,"date":"2011-01-27 20:42:09.796626","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/http/http_stream_parser.cc#newcode276\nnet/http/http_stream_parser.cc:276: chunk_data_length_ : result);\nOn 2011/01/27 20:42:09, Satish wrote:\n> > This is buggy. ClientSocket::Write() may not write all bytes. It might only\n> > partially write.\n> > \n> > I think the correct way to do this is to only call MarkConsumedAndFillBuffer()\n> > when you've successfully written the full chunk.\n> \n> Ok. I can stash the number of bytes given to Write() in a member var, decrement\n> it by the value received by OnIOComplete() and call DoLoop() only when it\n> reaches zero. Is that ok or do you have other suggestions?\n\nI'm not sure I follow. Write() with 10 bytes may have a return value of 3. In order to complete it, you need to call Write() again, with the buffer index incremented by 3, and the number of bytes to write changed to 7. When OnIOComplete(result) is called, there's no way to know which state you're in. It could be a Read() that is completing. So you have to call DoLoop() to enter the state machine so you know that it's the return value for Write().\n\nI think you need to expand the number of states in the state machine. And the state machine will be easier to understand if you implement my suggestion below wrt UploadDataStream::MarkConsumedAndFillBuffer() vs UploadDataStream::GetNextBuffer().\n\nI think you need states like.\nSTATE_GET_BODY,\nSTATE_GET_BODY_COMPLETE,\nSTATE_SEND_BODY,\nSTATE_SEND_BODY_COMPLETE\n\nSTATE_GET_BODY calls request_body_->GetNextBuffer(). Pass the return value to STATE_GET_BODY_COMPLETE\nIn STATE_GET_BODY_COMPLETE, if the result is positive, go straight to STATE_SEND_BODY. If the result is negative, it must be ERR_IO_PENDING, mark the next state as STATE_SEND_BODY, and then bail out of the state machine. We'll continue when it comes back.\nIn STATE_SEND_BODY_COMPLETE, if we're sent the whole chunk, go to STATE_GET_BODY. Otherwise, go to back to STATE_SEND_BODY.\n\n> \n> > Going further, it seems to be that we should stop calling this\n> > MarkConsumedAndFillBuffer() and redo the functionality. Perhaps it'd be better\n> > to have something like int int GetNextBuffer(scoped_refptr<IOBufferWithSize>*\n> > buf, CompletionCallback* callback);\n> > \n> > Then it'd return ERR_IO_PENDING if the buffer is not yet available. Otherwise,\n> > it'd return the number of bytes. 0 should mean EOF.\n> \n> Sounds good. This seems like a general change in UploadDataStream and not\n> related to SPDY. Can I do it in a subsequent CL? This also requires that\n> UploadDataStream will now implement ChunkCallback and receive the call from\n> UploadData, and in turn invoke the CompletionCallback you mention above. That\n> would be a self contained change on its own.\n\nhttp://codereview.chromium.org/6292013/diff/1/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/1/net/spdy/spdy_http_stream.cc#newcode271\nnet/spdy/spdy_http_stream.cc:271: bool SpdyHttpStream::OnSendBodyComplete(int* status) {\nOn 2011/01/27 20:42:09, Satish wrote:\n> On 2011/01/27 18:47:49, willchan wrote:\n> > You're reusing the same parameter for input and output. You probably shouldn't\n> > be doing this. Why don't you just change the return value?\n> \n> The function needs the status code as input and return 2 values - network status\n> code as well as EOF flag. So we either need 1 IN parameter (status), 1 OUT\n> parameter (eof) and a return value (write status), or 1 IN/OUT parameter and a\n> return value as I have done here. I'm fine either way, so I can change it to the\n> first if you prefer so.\n\nOK, I see what's going on here. You should probably be changing SpdyStream::DoSendBodyComplete() to go back to DoSendBody() if there is still more data to be written. You should not be writting data here in SpdyHttpStream::OnSendBodyComplete().","disapproval":false,"date":"2011-01-28 00:56:17.074456","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.cc#newcode72\nnet/base/upload_data_stream.cc:72: if (bytes_copied)\nI left this as is because we need to set 'advance_to_next_element' to true below and doing a break here means we have to duplicate that here as well.","disapproval":false,"date":"2011-01-28 17:37:51.586514","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"New patch uploaded, please take a look.\n\nChanging UploadDataStream to implement a GetNextBuffer() style interface  is a more sweeping change and requires modifications to http stream, spdy stream as well as chrome-frame which has its own variation of UploadDataStream. I think it will be cleaner to implement that change in a separate CL after this change goes in.\n\nBecause of the way the latest patch is implemented, a big chunk of this will stay the same even with the above suggested new interface.","disapproval":false,"date":"2011-01-28 17:41:54.415978","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.cc#newcode72\nnet/base/upload_data_stream.cc:72: if (bytes_copied)\nOn 2011/01/28 17:37:51, Satish wrote:\n> I left this as is because we need to set 'advance_to_next_element' to true below\n> and doing a break here means we have to duplicate that here as well.\n\nWell, maybe buf_len_ += bytes_copied should be included in the if condition then.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.h\nFile net/base/upload_data_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.h#newcode29\nnet/base/upload_data_stream.h:29: size_t GetMaxBufferSize() const { return kBufSize; }\nIt's annoying we have to expose this. We should just be returning a IOBufferWithSize for the consumer to take. Or write to a buffer that they provide.\n\nPlease leave a TODO to fix this, so people will know not to use this.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode276\nnet/http/http_stream_parser.cc:276: int HttpStreamParser::DoSendBody(int result) {\nPlease add a bunch of assertions to validate this function works correctly. I'll give some examples below.\n\nI also feel like we have a lot of unnecessary request_body_->MarkConsumedAndFillBuffer(0) calls. A stricter UploadDataStream implementation should probably disallow this. Is there a way to rework this code so we don't have to call it with 0?\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode280\nnet/http/http_stream_parser.cc:280: memcpy(chunk_buf_->data(), chunk_buf_->data() + result, chunk_length_);\nYou need to use memmove instead of memcpy because you have overlapping memory regions.\n\nRather than having to do copies, how about just incrementing an index pointer to keep track of where you are in the buffer?\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode300\nnet/http/http_stream_parser.cc:300: // Encode and send the buffer as 1 chunk.\nWhy don't you use a single sprintf() call? Something like:\nsprintf(\"%X\\r\\n%*s\\r\\n\", buf_len, buf_len, request_body_->buf()->data())? It's annoying to have to read the destination pointers each time to make sure you have the indices calculated correctly.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_http_stream.cc#newcode273\nnet/spdy/spdy_http_stream.cc:273: return stream_->WriteStreamData(request_body_stream_->buf(), buf_len,\nhttp://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Function_Calls#Function_Calls\nYou need to align your parameters on the second line.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_http_stream.cc#newcode284\nnet/spdy/spdy_http_stream.cc:284: request_body_stream_->MarkConsumedAndFillBuffer(*status);\nI'm confused how this works. OK == 0. You set *status to OK a few lines before. How does this ever make progress?\n\nAt this point, we've gone through enough of the design. You need to add tests to show this stuff works.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_proxy_client_socket.h\nFile net/spdy/spdy_proxy_client_socket.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_proxy_client_socket.h#newcode98\nnet/spdy/spdy_proxy_client_socket.h:98: virtual void set_chunk_callback(ChunkCallback* callback) {}\nIf you're ignoring the parameter, please document it properly. See http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Function_Declarations_and_Definitions#Function_Declarations_and_Definitions which says:\n\"\"\"\n// Comment out unused named parameters in definitions.\nvoid Circle::Rotate(double /*radians*/) {}\n\"\"\"\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_session.cc\nFile net/spdy/spdy_session.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_session.cc#newcode635\nnet/spdy/spdy_session.cc:635: DCHECK_GE(result, static_cast<int>(spdy::SpdyFrame::size()));\nWhy is it a DCHECK_GE now?\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_stream.h\nFile net/spdy/spdy_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_stream.h#newcode58\nnet/spdy/spdy_stream.h:58: virtual bool OnSendBodyComplete(int* status) = 0;\nChange this to be more consistent with the rest of the network stack code. If it needs to return a net error code, return it using the return value. Use a bool* output parameter for the eof status. Please update the comments too.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_stream.h#newcode79\nnet/spdy/spdy_stream.h:79: virtual void set_chunk_callback(ChunkCallback* callback) = 0;\nPlease comment this.","disapproval":false,"date":"2011-02-01 23:35:59.412287","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Latest patch uploaded, I will add tests once the current questions get cleared below. Please excuse this late reply as I was away for the past couple of weeks.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.cc#newcode72\nnet/base/upload_data_stream.cc:72: if (bytes_copied)\nOn 2011/02/01 23:35:59, willchan wrote:\n> On 2011/01/28 17:37:51, Satish wrote:\n> > I left this as is because we need to set 'advance_to_next_element' to true\n> below\n> > and doing a break here means we have to duplicate that here as well.\n> \n> Well, maybe buf_len_ += bytes_copied should be included in the if condition\n> then.\n\nDone.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.h\nFile net/base/upload_data_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.h#newcode29\nnet/base/upload_data_stream.h:29: size_t GetMaxBufferSize() const { return kBufSize; }\n> It's annoying we have to expose this. We should just be returning a\n> IOBufferWithSize for the consumer to take. Or write to a buffer that they\n> provide.\n> \n> Please leave a TODO to fix this, so people will know not to use this.\n\nWe don't write to a buffer provided by the caller, but the caller indeed copies the data to their own IOBuffer. To do that the caller needs to know how large the IOBuffer should be allocated for, hence this method. The alternative is to pass this constant as a parameter at creation time which looks uglier because the consumer and creator of this object are different classes. Since this is primarily used to avoid unwanted allocations and just use the same IOBuffer in http_stream_parser, I'm not sure why you feel this is ugly. A caller who sends the IOBuffer as a whole doesn't care about this method at all.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode276\nnet/http/http_stream_parser.cc:276: int HttpStreamParser::DoSendBody(int result) {\n> I also feel like we have a lot of unnecessary\n> request_body_->MarkConsumedAndFillBuffer(0) calls. A stricter UploadDataStream\n> implementation should probably disallow this. Is there a way to rework this code\n> so we don't have to call it with 0?\n\nIn the newly added code MarkConsumedAndFillBuffer() is never called with zero. Can you clarify which code flow you thought results in such calls?\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode280\nnet/http/http_stream_parser.cc:280: memcpy(chunk_buf_->data(), chunk_buf_->data() + result, chunk_length_);\nOn 2011/02/01 23:35:59, willchan wrote:\n> You need to use memmove instead of memcpy because you have overlapping memory\n> regions.\n\nDone\n\n> Rather than having to do copies, how about just incrementing an index pointer to\n> keep track of where you are in the buffer?\n\nThe net::Socket::Write call in the next line only takes an IOBuffer and writes the whole buffer out, so there is no easy way to use an index here.. unless I change that to use a DrainableIOBuffer or something similar which is a larger change.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode300\nnet/http/http_stream_parser.cc:300: // Encode and send the buffer as 1 chunk.\nOn 2011/02/01 23:35:59, willchan wrote:\n> Why don't you use a single sprintf() call? Something like:\n> sprintf(\"%X\\r\\n%*s\\r\\n\", buf_len, buf_len, request_body_->buf()->data())? It's\n> annoying to have to read the destination pointers each time to make sure you\n> have the indices calculated correctly.\n\nMSDN says that for %s 'characters are printed up to the first null character or until the precision value is reached' - so if there was a zero byte in the buffer only so many characters will be printed. Hence I'm doing the memcpy myself\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_http_stream.cc#newcode273\nnet/spdy/spdy_http_stream.cc:273: return stream_->WriteStreamData(request_body_stream_->buf(), buf_len,\nOn 2011/02/01 23:35:59, willchan wrote:\n> http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Function_Calls#Function_Calls\n> You need to align your parameters on the second line.\n\nDone.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_http_stream.cc#newcode284\nnet/spdy/spdy_http_stream.cc:284: request_body_stream_->MarkConsumedAndFillBuffer(*status);\nOn 2011/02/01 23:35:59, willchan wrote:\n> I'm confused how this works. OK == 0. You set *status to OK a few lines before.\n> How does this ever make progress?\n> \n> At this point, we've gone through enough of the design. You need to add tests to\n> show this stuff works.\n\nThis was a last minute copy/paste error, fixed now.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_session.cc\nFile net/spdy/spdy_session.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_session.cc#newcode635\nnet/spdy/spdy_session.cc:635: DCHECK_GE(result, static_cast<int>(spdy::SpdyFrame::size()));\nOn 2011/02/01 23:35:59, willchan wrote:\n> Why is it a DCHECK_GE now?\n\nPer the SPDY spec the last chunk is indicated with a SPDY frame with no data, so 'result' here would be teh same as SpdyFrame::size(). Hence changing GT to GE\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_stream.h\nFile net/spdy/spdy_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/spdy/spdy_stream.h#newcode58\nnet/spdy/spdy_stream.h:58: virtual bool OnSendBodyComplete(int* status) = 0;\nOn 2011/02/01 23:35:59, willchan wrote:\n> Change this to be more consistent with the rest of the network stack code. If it\n> needs to return a net error code, return it using the return value. Use a bool*\n> output parameter for the eof status. Please update the comments too.\n\nDone.","disapproval":false,"date":"2011-02-22 14:25:43.929417","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Still looking, but wanted to send comments asap since I'm already way behind. Sorry for the delay, right now's pretty busy.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.h\nFile net/base/upload_data_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/base/upload_data_stream.h#newcode29\nnet/base/upload_data_stream.h:29: size_t GetMaxBufferSize() const { return kBufSize; }\nOn 2011/02/22 14:25:44, Satish wrote:\n> > It's annoying we have to expose this. We should just be returning a\n> > IOBufferWithSize for the consumer to take. Or write to a buffer that they\n> > provide.\n> > \n> > Please leave a TODO to fix this, so people will know not to use this.\n> \n> We don't write to a buffer provided by the caller, but the caller indeed copies\n> the data to their own IOBuffer. To do that the caller needs to know how large\n> the IOBuffer should be allocated for, hence this method. The alternative is to\n> pass this constant as a parameter at creation time which looks uglier because\n> the consumer and creator of this object are different classes. Since this is\n> primarily used to avoid unwanted allocations and just use the same IOBuffer in\n> http_stream_parser, I'm not sure why you feel this is ugly. A caller who sends\n> the IOBuffer as a whole doesn't care about this method at all.\n\nI was thinking that instead of an interface like MarkConsumedAndFillBuffer(), we'd have something like a int Read(num_bytes, buf, callback) member function. The user provides a IOBuffer with the appropriate max size specified by \"num_bytes\". The return value indicates the size that was populated by UploadDataStream.\n\nA MarkConsumedAndFillBuffer() member function dictates that UploadDataStream owns the IOBuffer, which is just lent out to the caller to read temporarily. This means that when MarkConsumedAndFillBuffer() is called, UploadDataStream has to do a memmove. Ew, why?\n\nUsers should provide their own buffer. They can either use new buffers and keep calling Read() to populate the new buffers, or they can finishing using their first buffer and then pass that same buffer to Read(). Why does UploadDataStream dictate the Read() size? Shouldn't callers be in control of how much data they want to read at a time?\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode276\nnet/http/http_stream_parser.cc:276: int HttpStreamParser::DoSendBody(int result) {\nOn 2011/02/22 14:25:44, Satish wrote:\n> > I also feel like we have a lot of unnecessary\n> > request_body_->MarkConsumedAndFillBuffer(0) calls. A stricter UploadDataStream\n> > implementation should probably disallow this. Is there a way to rework this\n> code\n> > so we don't have to call it with 0?\n> \n> In the newly added code MarkConsumedAndFillBuffer() is never called with zero.\n> Can you clarify which code flow you thought results in such calls?\n\nI don't recall the control flow =/ I looked at don't see it, so maybe I was just wrong before? I hope I didn't miss it on the re-read.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode280\nnet/http/http_stream_parser.cc:280: memcpy(chunk_buf_->data(), chunk_buf_->data() + result, chunk_length_);\nOn 2011/02/22 14:25:44, Satish wrote:\n> On 2011/02/01 23:35:59, willchan wrote:\n> > You need to use memmove instead of memcpy because you have overlapping memory\n> > regions.\n> \n> Done\n> \n> > Rather than having to do copies, how about just incrementing an index pointer\n> to\n> > keep track of where you are in the buffer?\n> \n> The net::Socket::Write call in the next line only takes an IOBuffer and writes\n> the whole buffer out, so there is no easy way to use an index here.. unless I\n> change that to use a DrainableIOBuffer or something similar which is a larger\n> change.\n\nDrainableIOBuffer is the right solution here. Of course, UploadDataStream is creating the IOBuffer, rather than using a user-provided buffer. UGH.\n\nhttp://codereview.chromium.org/6292013/diff/7002/net/http/http_stream_parser.cc#newcode300\nnet/http/http_stream_parser.cc:300: // Encode and send the buffer as 1 chunk.\nOn 2011/02/22 14:25:44, Satish wrote:\n> On 2011/02/01 23:35:59, willchan wrote:\n> > Why don't you use a single sprintf() call? Something like:\n> > sprintf(\"%X\\r\\n%*s\\r\\n\", buf_len, buf_len, request_body_->buf()->data())? It's\n> > annoying to have to read the destination pointers each time to make sure you\n> > have the indices calculated correctly.\n> \n> MSDN says that for %s 'characters are printed up to the first null character or\n> until the precision value is reached' - so if there was a zero byte in the\n> buffer only so many characters will be printed. Hence I'm doing the memcpy\n> myself\n\nDoh, I forgot about the NUL. You're absolutely correct.\n\nMy style preference would be for you to chunk_ptr += length, after each memcpy, but I don't feel strongly. What you have is ok too.","disapproval":false,"date":"2011-02-24 19:03:39.705533","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/20001/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/base/upload_data_stream.cc#newcode72\nnet/base/upload_data_stream.cc:72: if (bytes_copied) {\nPlease add a comment for why we need this condition. I re-read the earlier review comments and they make sense, but this code is not immediately obvious that it's because d may be empty.\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/http/http_stream_parser.cc\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/http/http_stream_parser.cc#newcode281\nnet/http/http_stream_parser.cc:281: memmove(chunk_buf_->data(), chunk_buf_->data() + result, chunk_length_);\nPlease add a regression test here, since last time it was memcpy() which was wrong.\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/http/http_stream_parser.cc#newcode297\nnet/http/http_stream_parser.cc:297: chunk_length_ = 5;\nPlease do something like:\nstatic const char kLastChunk[] = \"0\\r\\n\\r\\n\";\n\nThen you can do chunk_length_ = strlen(kLastChunk) (note: compiler will reduce this to a compile-time constant) and memcpy with strlen(kLastChunk) too. I prefer this to magic constants like 5.\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/http/http_stream_parser.h\nFile net/http/http_stream_parser.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/http/http_stream_parser.h#newcode192\nnet/http/http_stream_parser.h:192: // Stores an encoded chunk for chunked uploads.\nPlease add a note that this should be improved not to rely on copies.\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/spdy/spdy_http_stream.cc#newcode283\nnet/spdy/spdy_http_stream.cc:283: return OK;\nYou should probably add a\nif (status != 0) {\n  NOTREACHED();\n  return ERR_UNEXPECTED;\n}\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/spdy/spdy_http_stream.cc#newcode287\nnet/spdy/spdy_http_stream.cc:287: *eof = false;\nEr, does this work for the non-chunked case? When will *eof = true be set in the non-chunked case? Do we have a test covering this? If not, please add one.","disapproval":false,"date":"2011-02-24 19:41:34.827116","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"I have addressed all the review comments and added a couple of unit tests for the new code. Please take a look at the latest patch.","disapproval":false,"date":"2011-03-02 14:42:23.080510","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/20001/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/spdy/spdy_http_stream.cc#newcode287\nnet/spdy/spdy_http_stream.cc:287: *eof = false;\nOn 2011/02/24 19:41:34, willchan wrote:\n> Er, does this work for the non-chunked case? When will *eof = true be set in the\n> non-chunked case? Do we have a test covering this? If not, please add one.\n\nWas there a test? Or did you add one?\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/base/upload_data_stream.h\nFile net/base/upload_data_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/base/upload_data_stream.h#newcode30\nnet/base/upload_data_stream.h:30: // TODO: We should ideally have UploadDataStream expose a Read() method which\nPut a username on this TODO, either yours or mine. Doesn't mean you have to fix it, it means someone can ask you for an explanation of what's going on here. I have plenty of TODO(willchan)s that I probably won't be getting around to.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_framer.cc\nFile net/spdy/spdy_framer.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_framer.cc#newcode796\nnet/spdy/spdy_framer.cc:796: } else if (current_data_frame.flags() & DATA_FLAG_FIN) {\nSomeone else will have to verify this change is ok, because I'm not super familiar with spdy_framer.cc.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc\nFile net/spdy/spdy_http_stream_unittest.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc#newcode125\nnet/spdy/spdy_http_stream_unittest.cc:125: host_port_pair));\nhost_port_pair must align with reads a la http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Function_Calls#Function_Calls which says:\n\"If the arguments do not all fit on one line, they should be broken up onto multiple lines, with each subsequent line aligned with the first argument. Do not add spaces after the open paren or before the close paren:\"\n\nreads is the first argument in the InitSession() function call, so parameters on new lines must align with it.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc#newcode138\nnet/spdy/spdy_http_stream_unittest.cc:138: scoped_ptr<SpdyHttpStream> http_stream(\nHow about just instantiating this on the stack? Is there any reason to use a scoped_ptr?\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc#newcode159\nnet/spdy/spdy_http_stream_unittest.cc:159: EXPECT_TRUE(!http_session_->spdy_session_pool()->HasSession(pair));\nThis should be EXPECT_FALSE instead of EXPECT_TRUE(!","disapproval":false,"date":"2011-03-02 18:44:40.894017","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"I have uploaded a new patch with the following major changes:\n\n- SPDY doesn't require a zero-length data frame to mark the end of chunked stream, instead the last valid data frame should have the FIN flag set. This requires the application layer to indicate the last chunk when giving chunks to send, so I have changed the URLFetcher/URLRequest/UploadData/UploadDataStream interfaces by adding a is_last_chunk flag to AppendChunk.\n\n- Due to the above change, spdy_http_stream.cc changes are now much simpler. However SpdyHttpStream::OnSendBody() needs to know when the last chunk is being sent out and UploadDataStream::eof() only returns true AFTER the data was sent out. So I have added a new method UploadDataStream::peek_end_of_chunks() to check if the stream is chunked and if so has the last chunk been read yet (not sent, just read and returned). Using this the SpdyHttpStream::OnSendBody() function now decides when to set the FIN flag in the SPDY frame.\n\n- Changes to spdy_framer.cc have been rolled back\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/20001/net/spdy/spdy_http_stream.cc#newcode287\nnet/spdy/spdy_http_stream.cc:287: *eof = false;\nOn 2011/03/02 18:44:40, willchan wrote:\n> On 2011/02/24 19:41:34, willchan wrote:\n> > Er, does this work for the non-chunked case? When will *eof = true be set in\n> the\n> > non-chunked case? Do we have a test covering this? If not, please add one.\n> \n> Was there a test? Or did you add one?\n\nI added 2 unit tests and they cover this code path as well. This code has also been greatly simplified in the latest patch.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/base/upload_data_stream.h\nFile net/base/upload_data_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/base/upload_data_stream.h#newcode30\nnet/base/upload_data_stream.h:30: // TODO: We should ideally have UploadDataStream expose a Read() method which\nOn 2011/03/02 18:44:40, willchan wrote:\n> Put a username on this TODO, either yours or mine. Doesn't mean you have to fix\n> it, it means someone can ask you for an explanation of what's going on here. I\n> have plenty of TODO(willchan)s that I probably won't be getting around to.\n\nDone.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_framer.cc\nFile net/spdy/spdy_framer.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_framer.cc#newcode796\nnet/spdy/spdy_framer.cc:796: } else if (current_data_frame.flags() & DATA_FLAG_FIN) {\nOn 2011/03/02 18:44:40, willchan wrote:\n> Someone else will have to verify this change is ok, because I'm not super\n> familiar with spdy_framer.cc.\n\nI reverted this change as mentioned above.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc\nFile net/spdy/spdy_http_stream_unittest.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc#newcode125\nnet/spdy/spdy_http_stream_unittest.cc:125: host_port_pair));\nOn 2011/03/02 18:44:40, willchan wrote:\n> host_port_pair must align with reads\n\nDone.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc#newcode138\nnet/spdy/spdy_http_stream_unittest.cc:138: scoped_ptr<SpdyHttpStream> http_stream(\nOn 2011/03/02 18:44:40, willchan wrote:\n> How about just instantiating this on the stack? Is there any reason to use a\n> scoped_ptr?\n\nDone.\n\nhttp://codereview.chromium.org/6292013/diff/28001/net/spdy/spdy_http_stream_unittest.cc#newcode159\nnet/spdy/spdy_http_stream_unittest.cc:159: EXPECT_TRUE(!http_session_->spdy_session_pool()->HasSession(pair));\nOn 2011/03/02 18:44:40, willchan wrote:\n> This should be EXPECT_FALSE instead of EXPECT_TRUE(!\n\nDone.","disapproval":false,"date":"2011-03-03 13:50:09.999901","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/39001/net/base/upload_data.cc\nFile net/base/upload_data.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data.cc#newcode31\nnet/base/upload_data.cc:31: void UploadData::Element::SetToChunk(const char* bytes, int bytes_len,\nhttp://dev.chromium.org/developers/coding-style#Code_Formatting says:\n\n\"\"\"\nFor function declarations and definitions, put each argument on a separate line unless everything fits on one line. You should only break this rule when the arguments have some logical association like \"int x, int y\" or \"char* str, int str_len\" where putting a few arguments together makes semantic sense.  Do NOT collapse function arguments together just because you have \"too many\":\n\"\"\"\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data.cc#newcode145\nnet/base/upload_data.cc:145: void UploadData::AppendChunk(const char* bytes, int bytes_len,\nhttp://dev.chromium.org/developers/coding-style#Code_Formatting says:\n\n\"\"\"\nFor function declarations and definitions, put each argument on a separate line unless everything fits on one line. You should only break this rule when the arguments have some logical association like \"int x, int y\" or \"char* str, int str_len\" where putting a few arguments together makes semantic sense.  Do NOT collapse function arguments together just because you have \"too many\":\n\"\"\"\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc#newcode146\nnet/base/upload_data_stream.cc:146: bool UploadDataStream::peek_end_of_chunks() const {\nThis is not a trivial accessor. Also, this may be better named as IsOnLastChunk().\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc#newcode147\nnet/base/upload_data_stream.cc:147: std::vector<UploadData::Element>& elements = *data_->elements();\nCan you get away with a const reference?\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc#newcode148\nnet/base/upload_data_stream.cc:148: if (!data_->is_chunked())\nIf this doesn't depend on |elements|, then how about moving it above?\n\nBut should this ever be called in the non-chunked control path? Perhaps we should have a DCHECK(data_->is_chunked()); I don't understand what \"peek_end_of_chunks()\" means for a non-chunked UploadDataStream. Rather than forcing weird semantics on the function, I think it's best to disallow it being called. Callers should know they're dealing with chunked UploadDataStreams, or they should check is_chunked().\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc#newcode152\nnet/base/upload_data_stream.cc:152: next_element_ >= elements.size() - 1 &&\nI find |next_element_ > elements.size()| more readable since you don't need the - 1.\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream.cc#newcode288\nnet/spdy/spdy_http_stream.cc:288: int SpdyHttpStream::OnSendBodyComplete(int status, bool* eof) {\nYou should initialize *eof to false. Your comment in spdy_stream.h leaves this state ambiguous. It's probably best to always set *eof. If *eof was already true, then how can the user tell if this code also set it to true?\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream_unittest.cc\nFile net/spdy/spdy_http_stream_unittest.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream_unittest.cc#newcode101\nnet/spdy/spdy_http_stream_unittest.cc:101: TEST_F(SpdyHttpStreamTest, SendChunkedPost) {\nPlease add a test where you have multiple chunks.\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_network_transaction_unittest.cc\nFile net/spdy/spdy_network_transaction_unittest.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_network_transaction_unittest.cc#newcode1545\nnet/spdy/spdy_network_transaction_unittest.cc:1545: TEST_P(SpdyNetworkTransactionTest, ChunkedPost) {\nYou should also have a test with multiple chunks.\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_proxy_client_socket.h\nFile net/spdy/spdy_proxy_client_socket.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_proxy_client_socket.h#newcode98\nnet/spdy/spdy_proxy_client_socket.h:98: virtual void set_chunk_callback(ChunkCallback* /*callback*/) {}\nShouldn't this also do NOTREACHED() and return ERR_UNEXPECTED?\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/url_request/url_request.h\nFile net/url_request/url_request.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/url_request/url_request.h#newcode334\nnet/url_request/url_request.h:334: bool is_last_chunk);\nhttp://dev.chromium.org/developers/coding-style#Code_Formatting says:\n\n\"\"\"\nFor function declarations and definitions, put each argument on a separate line unless everything fits on one line. You should only break this rule when the arguments have some logical association like \"int x, int y\" or \"char* str, int str_len\" where putting a few arguments together makes semantic sense.  Do NOT collapse function arguments together just because you have \"too many\":\n\"\"\"","disapproval":false,"date":"2011-03-03 19:47:47.983638","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Thanks for the quick comments. I have addressed all style issues and some replies below.\n\nAbout adding tests with multiple chunks - that is not possible right now because UploadDataStream combines all the chunks into a single block if they are < 16k and I can only test a single mock read/write with that combined block. \nI'll need some test-only code in UploadDataStream so that it doesn't combine chunks like this. I'd like to submit this CL as is add this test code + additional unit tests in the next CL. Is that ok?\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc#newcode152\nnet/base/upload_data_stream.cc:152: next_element_ >= elements.size() - 1 &&\nOn 2011/03/03 19:47:48, willchan wrote:\n> I find |next_element_ > elements.size()| more readable since you don't need the\n> - 1.\n\nThe condition could only be changed as \"next_element_ > elements.size() - 2\", not as \"next_element_ > elements.size()\". So leaving as is.\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream.cc#newcode288\nnet/spdy/spdy_http_stream.cc:288: int SpdyHttpStream::OnSendBodyComplete(int status, bool* eof) {\nOn 2011/03/03 19:47:48, willchan wrote:\n> You should initialize *eof to false. Your comment in spdy_stream.h leaves this\n> state ambiguous. It's probably best to always set *eof. If *eof was already\n> true, then how can the user tell if this code also set it to true?\n\n*eof is already initialized below in line 292, not to false but to the stream->eof(). Or have I misunderstood?","disapproval":false,"date":"2011-03-03 22:21:43.944839","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Sorry, it's not clear to me why you can't then add chunks that are over 16k?\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/base/upload_data_stream.cc#newcode152\nnet/base/upload_data_stream.cc:152: next_element_ >= elements.size() - 1 &&\nOn 2011/03/03 22:21:44, Satish wrote:\n> On 2011/03/03 19:47:48, willchan wrote:\n> > I find |next_element_ > elements.size()| more readable since you don't need\n> the\n> > - 1.\n> \n> The condition could only be changed as \"next_element_ > elements.size() - 2\",\n> not as \"next_element_ > elements.size()\". So leaving as is.\n\nOops, missed that! Bleh, off by one =/\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream.cc\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/39001/net/spdy/spdy_http_stream.cc#newcode288\nnet/spdy/spdy_http_stream.cc:288: int SpdyHttpStream::OnSendBodyComplete(int status, bool* eof) {\nOn 2011/03/03 22:21:44, Satish wrote:\n> On 2011/03/03 19:47:48, willchan wrote:\n> > You should initialize *eof to false. Your comment in spdy_stream.h leaves this\n> > state ambiguous. It's probably best to always set *eof. If *eof was already\n> > true, then how can the user tell if this code also set it to true?\n> \n> *eof is already initialized below in line 292, not to false but to the\n> stream->eof(). Or have I misunderstood?\n\nOops, I'm blind.","disapproval":false,"date":"2011-03-03 22:26:54.606173","approval":false},{"sender":"satish@chromium.org","recipients":["reply@chromiumcodereview.appspotmail.com"],"text":"> Sorry, it's not clear to me why you can't then add chunks that are over\n16k?\n\nUploadDataStream would chop the chunks in this case to 16k. My point is that\nthe test will be relying on the 16k magic number which is a private\nimplementation detail of UploadDataStream. I think the correct way is to let\nchunks be returned in their original size when in unit test mode and let the\ntest check for the same exact chunks as they were added. If you agree, I'll\ndo this in the next CL.\n","disapproval":false,"date":"2011-03-03 22:35:31.529484","approval":false},{"sender":"willchan@chromium.org","recipients":["reply@chromiumcodereview.appspotmail.com"],"text":"On Thu, Mar 3, 2011 at 2:35 PM, Satish Sampath <satish@chromium.org> wrote:\n>> Sorry, it's not clear to me why you can't then add chunks that are over\n>> 16k?\n> UploadDataStream would chop the chunks in this case to 16k. My point is that\n> the test will be relying on the 16k magic number which is a private\n> implementation detail of UploadDataStream. I think the correct way is to let\n> chunks be returned in their original size when in unit test mode and let the\n> test check for the same exact chunks as they were added. If you agree, I'll\n> do this in the next CL.\n\nI see, you make a very good point. I agree with you that the test\nshould not rely on the 16k magic number. But right now, you are asking\nme to let this change go in without testing perhaps the most important\npart of the changelist! If you want to land your change sooner, I\nsuggest you write a test that relies on the 16k magic number, and fix\nit in a following changelist.\n","disapproval":false,"date":"2011-03-03 22:40:16.992985","approval":false},{"sender":"satish@chromium.org","recipients":["reply@chromiumcodereview.appspotmail.com"],"text":"Makes sense. I couldn't use 16k in the tests because SPDY data frames have a\nlimit of kMaxSpdyFrameChunkSize in code which is < 16k. So I have added a\nflag to UploadDataStream to indicate that chunks should not be merged and\nset this flag from the unit tests. Latest patch uploaded with these changes\nand updated tests.\n","disapproval":false,"date":"2011-03-03 23:32:07.354654","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Great! LGTM.\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.cc#newcode156\nnet/base/upload_data_stream.cc:156: next_element_ == elements.size() &&\nWhat's going on here? Did we catch a bug? It's not immediately obvious what this change is for.\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.h\nFile net/base/upload_data_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.h#newcode65\nnet/base/upload_data_stream.h:65: #if UNIT_TEST\nmost chromium code does defined(UNIT_TEST), not just #if UNIT_TEST. It's probably best to be consistent.\n\nPlease add a TODO to remove this. And I expect you to do this one after you submit this changelist, because this is kludgy. I think you should add stuff to UploadData one by one.","disapproval":false,"date":"2011-03-03 23:42:32.017406","approval":true},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Thanks!\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.cc\nFile net/base/upload_data_stream.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.cc#newcode156\nnet/base/upload_data_stream.cc:156: next_element_ == elements.size() &&\nOn 2011/03/03 23:42:32, willchan wrote:\n> What's going on here? Did we catch a bug? It's not immediately obvious what this\n> change is for.\n\nSorry I missed this. Yes I found a bug when testing with 16k sized chunks. This method should return true only after the whole chunk data was copied over to the IOBuffer. Since we no longer have the old zero-size chunk to indicate the end and instead have the flag on the last valid chunk, next_element_ should have gone past all chunks once the last chunk was read into the IOBuffer.\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.h\nFile net/base/upload_data_stream.h (right):\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/base/upload_data_stream.h#newcode65\nnet/base/upload_data_stream.h:65: #if UNIT_TEST\nOn 2011/03/03 23:42:32, willchan wrote:\n> most chromium code does defined(UNIT_TEST), not just #if UNIT_TEST. It's\n> probably best to be consistent.\n\nWill do.\n\n> Please add a TODO to remove this. And I expect you to do this one after you\n> submit this changelist, because this is kludgy. I think you should add stuff to\n> UploadData one by one.\n\nWith the current mock read/write testing model, I can't find easily how to break in the middle of an ongoing sequence and add more chunks to the stream. If you have any suggestions please let me know, perhaps topic for a separate mail thread.","disapproval":false,"date":"2011-03-03 23:50:58.988693","approval":false},{"sender":"satish@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/37026/net/spdy/spdy_proxy_client_socket.cc\nFile net/spdy/spdy_proxy_client_socket.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/spdy/spdy_proxy_client_socket.cc#newcode502\nnet/spdy/spdy_proxy_client_socket.cc:502: NOTREACHED();\nLooks like adding this was incorrect as SpdyStream is calling this method when sending a request and detaching. SpdyStream doesn't know about the actual POST data so it can't call this method only for chunked POST data. Is it ok if I remove the check and leave the method empty?","disapproval":false,"date":"2011-03-03 23:57:06.659954","approval":false},{"sender":"willchan@chromium.org","recipients":["satish@chromium.org","willchan@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/6292013/diff/37026/net/spdy/spdy_proxy_client_socket.cc\nFile net/spdy/spdy_proxy_client_socket.cc (right):\n\nhttp://codereview.chromium.org/6292013/diff/37026/net/spdy/spdy_proxy_client_socket.cc#newcode502\nnet/spdy/spdy_proxy_client_socket.cc:502: NOTREACHED();\nOn 2011/03/03 23:57:06, Satish wrote:\n> Looks like adding this was incorrect as SpdyStream is calling this method when\n> sending a request and detaching. SpdyStream doesn't know about the actual POST\n> data so it can't call this method only for chunked POST data. Is it ok if I\n> remove the check and leave the method empty?\n\nOK","disapproval":false,"date":"2011-03-04 00:02:55.478793","approval":false}],"owner_email":"satish@chromium.org","private":false,"base_url":"svn://svn.chromium.org/chrome/trunk/src","owner":"Satish","subject":"Add chunked uploads support to SPDY","created":"2011-01-26 22:33:03.245203","patchsets":[1,7002,20001,28001,39001,45002,37026,42008],"modified":"2011-05-24 13:03:44.265582","closed":true,"commit":false,"issue":6292013}