{"files":{"sandbox/linux/seccomp-bpf/sandbox_bpf.cc":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":28,"num_removed":12,"messages":[{"author":"jln","author_email":"jln@chromium.org","text":"I would love if we didn't have to keep track (and delete() manually) a pointer. Obviously we cannot used scoped_ptr here, but I think we could have \"Program program;\" as before, but in an inside block {} that closes before we install the policy (and after we copy the program to the stack obviously).\n\nThis would rely on the same C++ guarantee as the one we have for Errorcode in the for() loop below, etc.","draft":false,"lineno":216,"date":"2012-06-12 19:16:23.250371","left":false},{"author":"jln","author_email":"jln@chromium.org","text":"Please explain further that you're trying to make sure that the program vector gets de-allocated from the heap before installing the filter. As-is, I don't think it'll be clear to reviewers.","draft":false,"lineno":314,"date":"2012-06-12 19:16:23.250496","left":false},{"author":"jln","author_email":"jln@chromium.org","text":"Would a static_cast of program be cleaner here ?","draft":false,"lineno":317,"date":"2012-06-12 19:16:23.250609","left":false},{"author":"Markus (\u9867\u5b5f\u52e4)","author_email":"markus@chromium.org","text":"On 2012/06/12 19:16:23, Julien Tinnes wrote:\n> I would love if we didn't have to keep track (and delete() manually) a pointer.\n> Obviously we cannot used scoped_ptr here, but I think we could have \"Program\n> program;\" as before, but in an inside block {} that closes before we install the\n> policy (and after we copy the program to the stack obviously).\n> \n> This would rely on the same C++ guarantee as the one we have for Errorcode in\n> the for() loop below, etc.\n\nThis is tricky, and I don't think I can do it without writing even crazier code.\n\nThe problem is that we eventually need to allocate the \"bpf\" array on the stack. And when we create it, we still need access to \"program\".\n\nThis results in two mutually exclusive requirements for block scoping.\n\nSo, I think, explicit management of the heap allocated object is required. Feel free to correct me, if you can see an alternative that eludes me.","draft":false,"lineno":216,"date":"2012-06-12 19:35:05.445271","left":false},{"author":"Markus (\u9867\u5b5f\u52e4)","author_email":"markus@chromium.org","text":"On 2012/06/12 19:16:23, Julien Tinnes wrote:\n> Please explain further that you're trying to make sure that the program vector\n> gets de-allocated from the heap before installing the filter. As-is, I don't\n> think it'll be clear to reviewers.\n\nSure, I can add a little more to the comment :-) This is subtle code, and more comments are always helpful.","draft":false,"lineno":314,"date":"2012-06-12 19:35:05.445488","left":false},{"author":"Markus (\u9867\u5b5f\u52e4)","author_email":"markus@chromium.org","text":"On 2012/06/12 19:16:23, Julien Tinnes wrote:\n> Would a static_cast of program be cleaner here ?\n\nI am not convinced a cast would actually do the right thing. I believe we have to make sure we execute the vector::operator[](). Feel free to correct me, if you can find a something in the STL documentation that says otherwise.","draft":false,"lineno":317,"date":"2012-06-12 19:35:05.445697","left":false},{"author":"jln","author_email":"jln@chromium.org","text":"On 2012/06/12 19:35:05, Markus (\u9867\u5b5f\u52e4) wrote:\n> On 2012/06/12 19:16:23, Julien Tinnes wrote:\n> > I would love if we didn't have to keep track (and delete() manually) a\n> pointer.\n> > Obviously we cannot used scoped_ptr here, but I think we could have \"Program\n> > program;\" as before, but in an inside block {} that closes before we install\n> the\n> > policy (and after we copy the program to the stack obviously).\n> > \n> > This would rely on the same C++ guarantee as the one we have for Errorcode in\n> > the for() loop below, etc.\n> \n> This is tricky, and I don't think I can do it without writing even crazier code.\n> \n> The problem is that we eventually need to allocate the \"bpf\" array on the stack.\n> And when we create it, we still need access to \"program\".\n> \n> This results in two mutually exclusive requirements for block scoping.\n> \n> So, I think, explicit management of the heap allocated object is required. Feel\n> free to correct me, if you can see an alternative that eludes me.\n\nYou're right, this becomes even more confusing.","draft":false,"lineno":216,"date":"2012-06-12 20:22:51.094196","left":false},{"author":"jln","author_email":"jln@chromium.org","text":"On 2012/06/12 19:35:05, Markus (\u9867\u5b5f\u52e4) wrote:\n> On 2012/06/12 19:16:23, Julien Tinnes wrote:\n> > Would a static_cast of program be cleaner here ?\n> \n> I am not convinced a cast would actually do the right thing. I believe we have\n> to make sure we execute the vector::operator[](). Feel free to correct me, if\n> you can find a something in the STL documentation that says otherwise.\n\nThe correct solution would be to use the new vector::data(). I presume all of our toolchains already support it, but feel free to stick to the current tired method.","draft":false,"lineno":317,"date":"2012-06-12 20:22:51.094317","left":false}],"id":2,"is_binary":false},"sandbox/linux/seccomp-bpf/sandbox_bpf.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":5,"messages":[],"id":3,"is_binary":false}},"owner_email":"markus@chromium.org","owner":"Markus (\u9867\u5b5f\u52e4)","message":null,"try_job_results":[],"created":"2012-06-08 21:39:04.828807","url":null,"num_comments":8,"modified":"2012-06-12 20:22:51.157309","patchset":1,"issue":10535089}