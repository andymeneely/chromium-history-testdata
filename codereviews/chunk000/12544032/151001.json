{"files":{"cc/trees/proxy.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":4,"num_removed":12,"messages":[],"id":152019,"is_binary":false},"cc/trees/thread_proxy.cc":{"status":"M","num_chunks":11,"no_base_file":false,"property_changes":"","num_added":109,"num_removed":136,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"Not sure why this dcheck, the lth is part of the constructor here. If anything do this in the constructor.","draft":false,"lineno":184,"date":"2013-04-24 15:38:42.342180","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"fix the name in this comment","draft":false,"lineno":209,"date":"2013-04-24 15:38:42.342490","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"s/recreate_succeeded/success/\n","draft":false,"lineno":210,"date":"2013-04-24 15:38:42.342740","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"Will this if() eever be true currently?\n\nIf we ever succeed, we reset the callback, which causes DoCreateAndInitOS() to not be called again. I feel like this is a remnant of the async patch, or is it needed for something else?","draft":false,"lineno":1109,"date":"2013-04-24 15:38:42.343020","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/24 15:38:42, danakj wrote:\n> Not sure why this dcheck, the lth is part of the constructor here. If anything\n> do this in the constructor.\n\nThis is DCHECK-ing that Stop has not been called. After Stop, scheduler no longer exists, which means this can only be called from CompositeAndReadback, which already has a DCHECK for LTH. So yep, moving to constructor.","draft":false,"lineno":184,"date":"2013-04-24 17:48:20.040560","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/24 15:38:42, danakj wrote:\n> Will this if() eever be true currently?\n> \n> If we ever succeed, we reset the callback, which causes DoCreateAndInitOS() to\n> not be called again. I feel like this is a remnant of the async patch, or is it\n> needed for something else?\n\nYes this is needed to prevent re-initializing everything when the output surface is already active (ie DCHECK in scheduler DidCreateAndInitializeOutputSurface)\n\nThis is failing in LayerTreeHostTestDeviceScaleFactorScalesViewportAndLayers (and possibly other tests) which calls LTH::InitializeOutputSurfaceIfNeeded immediately after SetSurfaceReady in the same call stack. The flow goes like this:\n\n* SetSurfaceReady leads to scheduler posting a task to main thread to CreateAndInitializeOutputSurface\n* While this task is waiting in the queue, LTH::InitializeOutputSurfaceIfNeeded is called, successfully initializes output surface, advances scheduler to OUTPUT_SRUFACE_ACTIVE, and cancels the task.\n* CreateAndInitializeOutputSurface finally runs, resets the task, tell LTH that output surface is lost (even though it is not), and the proceeds to create again, and trips into this.\n\nIdealy we would be able to tell in CreateAndInitializeOutputSurface that between when it was scheduled and run, the output surface is recreated so there is no need to run again. So...make this a cancelable task and to be cancelled here if succeeds? I don't know if it can be used across threads like that?\n\n(Didn't do anything in this patch set)","draft":false,"lineno":1109,"date":"2013-04-24 17:48:20.040730","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"On 2013/04/24 17:48:20, boliu wrote:\n> On 2013/04/24 15:38:42, danakj wrote:\n> > Will this if() eever be true currently?\n> > \n> > If we ever succeed, we reset the callback, which causes DoCreateAndInitOS() to\n> > not be called again. I feel like this is a remnant of the async patch, or is\n> it\n> > needed for something else?\n> \n> Yes this is needed to prevent re-initializing everything when the output surface\n> is already active (ie DCHECK in scheduler DidCreateAndInitializeOutputSurface)\n> \n> This is failing in LayerTreeHostTestDeviceScaleFactorScalesViewportAndLayers\n> (and possibly other tests) which calls LTH::InitializeOutputSurfaceIfNeeded\n> immediately after SetSurfaceReady in the same call stack. The flow goes like\n> this:\n> \n> * SetSurfaceReady leads to scheduler posting a task to main thread to\n> CreateAndInitializeOutputSurface\n> * While this task is waiting in the queue, LTH::InitializeOutputSurfaceIfNeeded\n> is called, successfully initializes output surface, advances scheduler to\n> OUTPUT_SRUFACE_ACTIVE, and cancels the task.\n> * CreateAndInitializeOutputSurface finally runs, resets the task, tell LTH that\n> output surface is lost (even though it is not), and the proceeds to create\n> again, and trips into this.\n\nHm, that sounds awkward. Does that leave the LTH with output_surface_lost_ = true in the end? This is also just bad test behaviour..\n\nIf I remove this from the test you cite:\n\n-    ASSERT_TRUE(layer_tree_host()->InitializeRendererIfNeeded());\n-    ResourceUpdateQueue queue;\n-    layer_tree_host()->UpdateLayers(&queue, std::numeric_limits<size_t>::max());\n\nThe test passes fine still, and I don't see why that is there at all! It's super weird to call UpdateLayers() directly from a LTH test.\n\nWe should fix the tests that hit this path I think rather than coding support for it into the proxy, if possible. Can you take a look at the other tests, or post a list of them? I can help out if you like.\n\n> Idealy we would be able to tell in CreateAndInitializeOutputSurface that between\n> when it was scheduled and run, the output surface is recreated so there is no\n> need to run again. So...make this a cancelable task and to be cancelled here if\n> succeeds? I don't know if it can be used across threads like that?\n> \n> (Didn't do anything in this patch set)\n\n","draft":false,"lineno":1109,"date":"2013-04-24 21:01:00.433690","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/24 21:01:00, danakj wrote:\n> Hm, that sounds awkward. Does that leave the LTH with output_surface_lost_ =\n> true in the end?\n\nNope, we are setting *success = true here.\n\n> This is also just bad test behaviour..\n> \n> If I remove this from the test you cite:\n> \n> -    ASSERT_TRUE(layer_tree_host()->InitializeRendererIfNeeded());\n> -    ResourceUpdateQueue queue;\n> -    layer_tree_host()->UpdateLayers(&queue,\n> std::numeric_limits<size_t>::max());\n> \n> The test passes fine still, and I don't see why that is there at all! It's super\n> weird to call UpdateLayers() directly from a LTH test.\n> \n> We should fix the tests that hit this path I think rather than coding support\n> for it into the proxy, if possible. Can you take a look at the other tests, or\n> post a list of them? I can help out if you like.\n\nSo how does the embedder know when is it safe to call CompositeAndReadback? Is this case impossible in practice?\n\nHere's the rest of the list and how I fixed them:\n\n* LayerTreeHostTestCompositeAndReadbackCleanup - Move test to DidRecreateOutputSurface hook so CompositeAndReadback is not force initializing output surface.\n* LayerTreeHostTestCapturePicture - Remove InitializeOutputIfNeeded call, nothing broke\n* ScrollbarLayerTestMaxTextureSize - Remove InitializeOutputIfNeeded call, nothing broke","draft":false,"lineno":1109,"date":"2013-04-24 22:01:00.607390","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"On 2013/04/24 22:01:00, boliu wrote:\n> So how does the embedder know when is it safe to call CompositeAndReadback? Is\n> this case impossible in practice?\n\nYou're right it should be able to call it immediately. I didn't think of the Comp&Readback case immediately after creation.\n\n> \n> Here's the rest of the list and how I fixed them:\n> \n> * LayerTreeHostTestCompositeAndReadbackCleanup - Move test to\n> DidRecreateOutputSurface hook so CompositeAndReadback is not force initializing\n> output surface.\n\nThis one feels wrong, I guess we need to handle this case. I'm glad we have some test coverage of this. I guess in this case we're going to end up calling DidRecreateOutputSurface(true) an extra time for no reason too since we told LTH it lost the context but actually didn't.. doh.\n\nCancellable callback is not threadsafe so it's not something we can use to solve this unfortunately.\n\nSo the problem is basically impl side can tell main thread to create output surface. By the time it gets to that task, it may have already done it, and how can it tell. We need some kind of extra syncronization between threads. We could use a lock and a variable or some kind to signal, but that's kinda ugly.\n\nWhat if the first thing CreateAndInitializeOutputSurface() did was to block the main thread and jump to the impl thread and query if we have an output surface. And then if we do, just early out. That would remove race conditions with the main thread doing it in between, and avoid an extra DidLose() and DidRecreate() from going on.\n\n\n> * LayerTreeHostTestCapturePicture - Remove InitializeOutputIfNeeded call,\n> nothing broke\n> * ScrollbarLayerTestMaxTextureSize - Remove InitializeOutputIfNeeded call,\n> nothing broke\n\nThose look fine to me.","draft":false,"lineno":1109,"date":"2013-04-24 23:17:13.473870","left":false}],"id":152022,"is_binary":false},"cc/test/layer_tree_test.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":2,"messages":[],"id":152012,"is_binary":false},"cc/layers/tiled_layer_unittest.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":152003,"is_binary":false},"cc/scheduler/scheduler_state_machine_unittest.cc":{"status":"M","num_chunks":39,"no_base_file":false,"property_changes":"","num_added":136,"num_removed":36,"messages":[],"id":152008,"is_binary":false},"cc/trees/layer_tree_host_unittest.cc":{"status":"M","num_chunks":10,"no_base_file":false,"property_changes":"","num_added":15,"num_removed":14,"messages":[],"id":152017,"is_binary":false},"cc/trees/layer_tree_host_client.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":152016,"is_binary":false},"cc/trees/thread_proxy.h":{"status":"M","num_chunks":6,"no_base_file":false,"property_changes":"","num_added":14,"num_removed":23,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: extraneous whitespace","draft":false,"lineno":203,"date":"2013-04-24 15:38:42.343280","left":false}],"id":152023,"is_binary":false},"cc/test/fake_proxy.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":8,"num_removed":5,"messages":[],"id":152010,"is_binary":false},"cc/scheduler/scheduler_state_machine.h":{"status":"M","num_chunks":5,"no_base_file":false,"property_changes":"","num_added":8,"num_removed":6,"messages":[],"id":152007,"is_binary":false},"cc/trees/layer_tree_host.cc":{"status":"M","num_chunks":6,"no_base_file":false,"property_changes":"","num_added":54,"num_removed":67,"messages":[],"id":152014,"is_binary":false},"cc/trees/layer_tree_host.h":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":8,"num_removed":8,"messages":[],"id":152015,"is_binary":false},"cc/trees/layer_tree_host_unittest_context.cc":{"status":"M","num_chunks":18,"no_base_file":false,"property_changes":"","num_added":117,"num_removed":42,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: useless constructor/destructor can go away (shouldnt be there in the first place)","draft":false,"lineno":1134,"date":"2013-04-24 15:38:42.341090","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"constructor can go away","draft":false,"lineno":1164,"date":"2013-04-24 15:38:42.341380","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"and this one","draft":false,"lineno":1185,"date":"2013-04-24 15:38:42.341640","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"You can just do this and avoid all the SkBitmap stuff, taken from lth_unittest.cc:\n\nchar pixels[4];\nlayer_tree_host()->CompositeAndReadback(&pixels, gfx::Rect(1, 1));\n\n\nIf you want to use the bitmap you did it right but:\n- omit the 4th argument to setConfig()\n- call bitmap.lockPixels() and unlockPixels() before/after the CompositeAndReadback().","draft":false,"lineno":1202,"date":"2013-04-24 15:38:42.341900","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/24 15:38:42, danakj wrote:\n> char pixels[4];\n> layer_tree_host()->CompositeAndReadback(&pixels, gfx::Rect(1, 1));\n\nThis sounds way better. Also added EXPECT_FALSE to CompositeAndReadback since recreate is supposed to fail here","draft":false,"lineno":1202,"date":"2013-04-24 17:48:20.040380","left":false}],"id":152018,"is_binary":false},"cc/trees/single_thread_proxy.h":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":9,"messages":[],"id":152021,"is_binary":false},"cc/test/fake_proxy.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":4,"messages":[],"id":152011,"is_binary":false},"cc/scheduler/scheduler.cc":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":7,"num_removed":7,"messages":[],"id":152004,"is_binary":false},"cc/scheduler/scheduler_state_machine.cc":{"status":"M","num_chunks":7,"no_base_file":false,"property_changes":"","num_added":22,"num_removed":13,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"Can you stick a TODO in here so we can remember to come back to this one day: \"See if we can remove this when impl-side painting is always on. Does anything on the main thread need to update after recreate?\"","draft":false,"lineno":429,"date":"2013-04-24 15:38:42.340820","left":false}],"id":152006,"is_binary":false},"cc/layers/nine_patch_layer_unittest.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":152001,"is_binary":false},"cc/layers/scrollbar_layer_unittest.cc":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":2,"messages":[],"id":152002,"is_binary":false},"cc/scheduler/scheduler.h":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":3,"messages":[],"id":152005,"is_binary":false},"cc/test/layer_tree_test.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":152013,"is_binary":false},"cc/scheduler/scheduler_unittest.cc":{"status":"M","num_chunks":14,"no_base_file":false,"property_changes":"","num_added":43,"num_removed":15,"messages":[],"id":152009,"is_binary":false},"cc/trees/single_thread_proxy.cc":{"status":"M","num_chunks":9,"no_base_file":false,"property_changes":"","num_added":42,"num_removed":49,"messages":[],"id":152020,"is_binary":false}},"owner_email":"boliu@chromium.org","owner":"boliu","message":"address moar comments","try_job_results":[],"created":"2013-04-24 01:26:50.938460","url":null,"num_comments":16,"modified":"2013-04-24 23:17:13.555080","patchset":151001,"issue":12544032}