{"files":{"cc/trees/proxy.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":3,"num_removed":12,"messages":[],"id":44023,"is_binary":false},"cc/trees/thread_proxy.cc":{"status":"M","num_chunks":11,"no_base_file":false,"property_changes":"","num_added":183,"num_removed":103,"messages":[],"id":44026,"is_binary":false},"cc/test/layer_tree_test.cc":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":30,"num_removed":3,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"instead of only calling this on true, can you call this always, but pass the result to the method. See PrepareToDrawOnThread() and SwapBuffersOnThread() as examples of this.","draft":false,"lineno":93,"date":"2013-04-10 16:40:14.466150","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"This isn't great, there's no guarantee that a test doesn't override CreateOutputSurface and create something that isn't a FakeOutputSurface.","draft":false,"lineno":441,"date":"2013-04-10 16:40:14.466410","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"unretained pointers seems like it's going to potentially cause flake. what if the test shuts down before this task is handled?\n\nwhy do you post-task for this anyways? you're already on the impl thread here.","draft":false,"lineno":449,"date":"2013-04-10 16:40:14.466670","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"who sets frame_time_?","draft":false,"lineno":456,"date":"2013-04-10 16:40:14.466920","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/10 16:40:14, danakj wrote:\n> who sets frame_time_?\n\nNo one! This was a the case with the vsync test and I just moved the code here. Haven't bothered to check what it's used for yet...","draft":false,"lineno":456,"date":"2013-04-10 17:36:36.037640","left":false}],"id":44014,"is_binary":false},"cc/scheduler/scheduler_state_machine_unittest.cc":{"status":"M","num_chunks":45,"no_base_file":false,"property_changes":"","num_added":67,"num_removed":22,"messages":[],"id":44010,"is_binary":false},"cc/trees/layer_tree_host_unittest.cc":{"status":"M","num_chunks":6,"no_base_file":false,"property_changes":"","num_added":9,"num_removed":21,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"typo here","draft":false,"lineno":1570,"date":"2013-04-10 16:40:14.469140","left":false}],"id":44021,"is_binary":false},"cc/trees/thread_proxy.h":{"status":"M","num_chunks":7,"no_base_file":false,"property_changes":"","num_added":40,"num_removed":18,"messages":[],"id":44027,"is_binary":false},"cc/test/fake_proxy.cc":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":10,"num_removed":5,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: no need to dcheck a pointer youre about to deref on the next line.","draft":false,"lineno":20,"date":"2013-04-10 16:40:14.465330","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/10 16:40:14, danakj wrote:\n> nit: no need to dcheck a pointer youre about to deref on the next line.\n\nBenefit is this makes the crash explicit. Without DCHECK, the crash would be somewhere inside OnCreateAttemped","draft":false,"lineno":20,"date":"2013-04-10 17:36:36.037350","left":false}],"id":44012,"is_binary":false},"cc/scheduler/scheduler_state_machine.h":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":3,"messages":[],"id":44009,"is_binary":false},"cc/trees/layer_tree_host.cc":{"status":"M","num_chunks":6,"no_base_file":false,"property_changes":"","num_added":82,"num_removed":73,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"I'm having trouble groking this function.\n\n1. If you have a renderer already, then you check if the output surface was created and retry if not?\n\n2. If you don't have a renderer, and you didn't create an output surface, then it gives up?\n\nWhy is any of the recreate-output-surface part of this function dependent on if you have initialized the renderer? As soon as the output surface is lost, the renderer should be considered lost too, including its capabilities.","draft":false,"lineno":163,"date":"2013-04-10 16:40:14.467300","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"This should happen before we recreate, not after. In the case DidRecreate succeeds above, this wouldn't even happen?","draft":false,"lineno":170,"date":"2013-04-10 16:40:14.467470","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: no else needed, the if() block returned.","draft":false,"lineno":188,"date":"2013-04-10 16:40:14.467620","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"i'm not sure i see the benefit of renaming this variable. has its meaning changed? initialized should be == having capabilities.","draft":false,"lineno":234,"date":"2013-04-10 16:40:14.467780","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"This is kind of a lie. If output surface is not lost but the renderer isn't ready, then this returns true.\n\nI'd rather name this something more precise like IsRendererInitialized() (well, that'd be the opposite, but you get the idea).","draft":false,"lineno":519,"date":"2013-04-10 16:40:14.467970","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"Is it possible that output_surface_lost_ = true, but has_renderer_caps_ = true? That would seem like a bug.\n\nI would think this function would be more like the following to enforce that, if it's true:\n\nDCHECK(!output_surface_lost_ || !has_renderer_capabilities_);\nreturn has_renderer_capabilities_;","draft":false,"lineno":521,"date":"2013-04-10 16:40:14.468140","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"Reuse the IsOutputSurfaceLost() function here?","draft":false,"lineno":721,"date":"2013-04-10 16:40:14.468310","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"Why does not having a renderer cause us to recreate the output surface?","draft":false,"lineno":722,"date":"2013-04-10 16:40:14.468470","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"can reuse IsOutputSurfaceLost here as well.","draft":false,"lineno":724,"date":"2013-04-10 16:40:14.468620","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/10 16:40:14, danakj wrote:\n> This should happen before we recreate, not after. In the case DidRecreate\n> succeeds above, this wouldn't even happen?\n\nThis is the exact same behavior as LayerTreeHost::RecreateOutputSurface before this patch. And I don't think it's wrong, it's *retrying* a recreate after it fails, so if recreate suceeds the first time, it should not be called.","draft":false,"lineno":170,"date":"2013-04-10 17:36:36.037890","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/10 16:40:14, danakj wrote:\n> i'm not sure i see the benefit of renaming this variable. has its meaning\n> changed? initialized should be == having capabilities.\n\nAgree it's a bad name.\n\nThe has_renderer_cap vars are used to distinguish the first creating output surface/initializing renderer, vs something lost and recreating. But as the latest discussion with James, there are code where there should be no distinction like update settings_ above. This also makes has_cap a bad name since capabilities should be updated on recreate.\n\nJust rename to something like is_first_init.","draft":false,"lineno":234,"date":"2013-04-10 17:36:36.038130","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/10 16:40:14, danakj wrote:\n> Is it possible that output_surface_lost_ = true, but has_renderer_caps_ = true?\n> That would seem like a bug.\n\nYes. See above comment, has_renderer_caps should really be renamed to something like has_first_initialized_renderer. Basically once has_first_initialized_renderer is set to true, it's never set to false again.\n\nNote I think that this var might no longer be needed here, but will still be needed in thread_proxy.","draft":false,"lineno":521,"date":"2013-04-10 17:36:36.038400","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"On 2013/04/10 17:36:36, boliu wrote:\n> On 2013/04/10 16:40:14, danakj wrote:\n> > This should happen before we recreate, not after. In the case DidRecreate\n> > succeeds above, this wouldn't even happen?\n> \n> This is the exact same behavior as LayerTreeHost::RecreateOutputSurface before\n> this patch. And I don't think it's wrong, it's *retrying* a recreate after it\n> fails, so if recreate suceeds the first time, it should not be called.\n\nAh, okay, quite right. I guess it's just my general confusion about how this function is used at the moment.","draft":false,"lineno":170,"date":"2013-04-10 17:51:00.330050","left":false}],"id":44016,"is_binary":false},"cc/trees/layer_tree_host.h":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":4,"num_removed":3,"messages":[],"id":44017,"is_binary":false},"cc/trees/layer_tree_host_impl.cc":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":27,"num_removed":13,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"This calls other public functions. Are you planning to remove this function and just make these calls directly in the tests?","draft":false,"lineno":1296,"date":"2013-04-10 16:40:14.468810","left":false},{"author":"boliu","author_email":"boliu@chromium.org","text":"On 2013/04/10 16:40:14, danakj wrote:\n> This calls other public functions. Are you planning to remove this function and\n> just make these calls directly in the tests?\n\nA lot of tests calls this. I don't think it's better replace each callsite with the body of this function due to the DRY principle. But would be better to move this somewhere compiled for tests only, but still available to all tests, any suggestions?","draft":false,"lineno":1296,"date":"2013-04-10 17:36:36.038640","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"On 2013/04/10 17:36:36, boliu wrote:\n> On 2013/04/10 16:40:14, danakj wrote:\n> > This calls other public functions. Are you planning to remove this function\n> and\n> > just make these calls directly in the tests?\n> \n> A lot of tests calls this. I don't think it's better replace each callsite with\n> the body of this function due to the DRY principle. But would be better to move\n> this somewhere compiled for tests only, but still available to all tests, any\n> suggestions?\n\nI think most of the calls are in the LayerTreeHostImpl tests? I'd suggest putting a CreateLayerTreeHostImpl(scoped_ptr<OutputSurface>) function in the LTHI test base class. Then have tests call that instead of calling LTHI::Create();LTHI::InitializeRendererForTesting();\n\nMost other tests could just make the real calls, I think. If there's a bunch of duplication in another test file, you could follow a similar pattern. Seem reasonable?","draft":false,"lineno":1296,"date":"2013-04-10 17:51:00.330330","left":false}],"id":44018,"is_binary":false},"cc/trees/layer_tree_host_impl.h":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":4,"num_removed":1,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: *ForTesting(","draft":false,"lineno":206,"date":"2013-04-10 16:40:14.468970","left":false}],"id":44019,"is_binary":false},"cc/layers/delegated_renderer_layer_impl_unittest.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":44001,"is_binary":false},"cc/trees/layer_tree_host_unittest_context.cc":{"status":"M","num_chunks":8,"no_base_file":false,"property_changes":"","num_added":21,"num_removed":12,"messages":[],"id":44022,"is_binary":false},"cc/trees/single_thread_proxy.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":8,"messages":[],"id":44025,"is_binary":false},"cc/test/fake_proxy.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":4,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: set_layer_tree_host(). this can be an inline method in the header, it's a simple setter.","draft":false,"lineno":20,"date":"2013-04-10 16:40:14.465600","left":false},{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: layer_tree_host_","draft":false,"lineno":50,"date":"2013-04-10 16:40:14.465880","left":false}],"id":44013,"is_binary":false},"cc/scheduler/scheduler.cc":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":15,"num_removed":7,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"Why doesn't this ProcessScheduledActions?","draft":false,"lineno":117,"date":"2013-04-10 16:40:14.464490","left":false}],"id":44006,"is_binary":false},"cc/trees/layer_tree_host_impl_unittest.cc":{"status":"M","num_chunks":17,"no_base_file":false,"property_changes":"","num_added":17,"num_removed":17,"messages":[],"id":44020,"is_binary":false},"cc/layers/layer_impl_unittest.cc":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":2,"messages":[],"id":44002,"is_binary":false},"cc/scheduler/scheduler_state_machine.cc":{"status":"M","num_chunks":7,"no_base_file":false,"property_changes":"","num_added":36,"num_removed":8,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"If the renderer isn't recreated, but the output surface is lost, I think it's wrong to drop the lost event here. We should reset to output surface lost and go from there. Initializing a renderer with a lost output surface isn't helpful, which I think this is going to try to do?\n\nMaybe the renderer init will fail in this case and we'll get back to the lost state, but it's a bit more indirect, and makes HasOutputSurface() lie, is there any reason for that?\n\n(Sounds like a test would be good for this case if there isn't one)","draft":false,"lineno":426,"date":"2013-04-10 16:40:14.464780","left":false}],"id":44008,"is_binary":false},"cc/layers/picture_layer_impl_unittest.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":44004,"is_binary":false},"cc/scheduler/scheduler.h":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":1,"messages":[],"id":44007,"is_binary":false},"cc/test/layer_tree_test.h":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":6,"num_removed":0,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"nit: DidSetOutputSurfaceOnThread","draft":false,"lineno":36,"date":"2013-04-10 16:40:14.467110","left":false}],"id":44015,"is_binary":false},"cc/scheduler/scheduler_unittest.cc":{"status":"M","num_chunks":13,"no_base_file":false,"property_changes":"","num_added":41,"num_removed":1,"messages":[{"author":"danakj","author_email":"danakj@chromium.org","text":"Seems like you don't need this init renderer?","draft":false,"lineno":586,"date":"2013-04-10 16:40:14.465070","left":false}],"id":44011,"is_binary":false},"cc/layers/texture_layer_unittest.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":44005,"is_binary":false},"cc/layers/picture_image_layer_impl_unittest.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":1,"num_removed":1,"messages":[],"id":44003,"is_binary":false},"cc/trees/single_thread_proxy.cc":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":41,"num_removed":51,"messages":[],"id":44024,"is_binary":false}},"owner_email":"boliu@chromium.org","owner":"boliu","message":"First CreateOutputSurface async, chrome starts up and renders, broke a lot of tests again :(","try_job_results":[],"created":"2013-04-10 01:22:36.003340","url":null,"num_comments":31,"modified":"2013-04-10 17:51:00.364710","patchset":43001,"issue":12544032}