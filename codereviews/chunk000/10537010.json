{"description":"Guard Against Bad Classifications\n\nAdded safety valve so that there will be no attempt to set an attribute on an string beyond its end.\nAlso, be consistent in using NSInteger by carrying around |nextOffset| as one.\nEnhanced the diagnostic output for the AutocompleteMatch::ValidateClassifications function so that the underlying perpetrator of the problem can more easily be identified.\n\nNOTE: This is a partial fix in that the true underlying cause of the bad classification range has not yet been addressed. So this bug will be left open.\n\nBUG=121703\nTEST=Visit http://www.hurriyet.com.tr/. Bring up a new tab. Type 's' into the omnibox. No crash means success.\nCommitted: https://src.chromium.org/viewvc/chrome?view=rev&revision=140747","cc":["chromium-reviews@chromium.org","suzhe@chromium.org"],"reviewers":["sail@chromium.org"],"messages":[{"sender":"mrossetti@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"","disapproval":false,"date":"2012-06-05 17:47:07.935583","approval":false},{"sender":"sail@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"https://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\nFile chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode127\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:127: const NSInteger length = nextOffset - static_cast<NSInteger>(i->offset);\nHey Mike! It seems like there are two underlying problems you're trying to address.\n\n#1 Conversion from string16 to NSString.\nI think the best thing to do would be to do something like this:\nNSString* s = base::SysUTF16ToNSString(matchString);\nif ([s length] != matchString.length()) {\n  NOTREACHED();\n  return nil;\n}\n\n#2 That |classifications| has offsets that go beyond the end of matchString. For this you could do something like:\nfor (....) {\n  if (i->offset >= matchString.length()) {\n    NOTREACHED();\n    return nil;\n  }\n\n  nextOffset = 0;\n  if (isLast) {\n     nextOffset = matchString.length();\n  } else {\n    nextOffset = (i + 1)->offset;\n    if (nextOffset >= matchString.length()) {\n      NOTREACHED();\n      return nil;\n    }\n  }\n}\n\nWhat do you think?","disapproval":false,"date":"2012-06-05 18:09:58.988109","approval":false},{"sender":"mrossetti@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"I've not made any of the changes you suggested (explained below) but I have enhanced the diagnostic output of the ValidateClassifications function to that we can more easily identify the autocomplete provider that has failed to handle the classification.\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\nFile chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode127\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:127: const NSInteger length = nextOffset - static_cast<NSInteger>(i->offset);\nOn 2012/06/05 18:09:59, sail wrote:\n> Hey Mike! It seems like there are two underlying problems you're trying to\n> address.\n> \n> #1 Conversion from string16 to NSString.\n> I think the best thing to do would be to do something like this:\n> NSString* s = base::SysUTF16ToNSString(matchString);\n> if ([s length] != matchString.length()) {\n>   NOTREACHED();\n>   return nil;\n> }\n\nI'd prefer to not mix string16's with NSStrings. Their encodings and lengths are not guaranteed to be the same. That's the source of the mismatch that has lead to this crash.\n\nIn the test case, the matchString is 40 char16s long while the converted NSString is 37 magic Apple characters long.\n\nI'm going to fix the underlying problem in how the classifications are getting miscalculated in the face of certain code points but that's going to take a little longer and I'm anxious to get this prophylactic guard code in ASAP so that we at least eliminate the crash.\n\n> \n> #2 That |classifications| has offsets that go beyond the end of matchString. For\n> this you could do something like:\n> for (....) {\n>   if (i->offset >= matchString.length()) {\n>     NOTREACHED();\n>     return nil;\n>   }\n> \n>   nextOffset = 0;\n>   if (isLast) {\n>      nextOffset = matchString.length();\n>   } else {\n>     nextOffset = (i + 1)->offset;\n>     if (nextOffset >= matchString.length()) {\n>       NOTREACHED();\n>       return nil;\n>     }\n>   }\n> }\n> \n> What do you think?\n\nEven in the case of bad classification offsets, some of the classifications can, and probably will, be correct. So the choice is 1) show the user nothing, or 2) show them something possibly incorrect. #1 will probably get no notice while #2 could generate bug reports. Which do you think is best?","disapproval":false,"date":"2012-06-05 22:44:41.102401","approval":false},{"sender":"sail@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"https://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\nFile chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode127\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:127: const NSInteger length = nextOffset - static_cast<NSInteger>(i->offset);\n> In the test case, the matchString is 40 char16s long while the converted\n> NSString is 37 magic Apple characters long.\n\nOuch that really sucks. I didn't realize that this was possible. I hope we aren't affected by this in other places too.\n\n> Even in the case of bad classification offsets, some of the classifications can,\n> and probably will, be correct. So the choice is 1) show the user nothing, or 2)\n> show them something possibly incorrect. #1 will probably get no notice while #2\n> could generate bug reports. Which do you think is best?\n\nI think if we encounter a case where [NSString length] != string16.size() then we should just bail.\n\nAdding temporary code to work around this isn't worth it I think.","disapproval":false,"date":"2012-06-05 23:02:08.653981","approval":false},{"sender":"mrossetti@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"On 2012/06/05 23:02:08, sail wrote:\n> https://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\n> File chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n> \n> https://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode127\n> chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:127: const NSInteger\n> length = nextOffset - static_cast<NSInteger>(i->offset);\n> > In the test case, the matchString is 40 char16s long while the converted\n> > NSString is 37 magic Apple characters long.\n> \n> Ouch that really sucks. I didn't realize that this was possible. I hope we\n> aren't affected by this in other places too.\n> \n> > Even in the case of bad classification offsets, some of the classifications\n> can,\n> > and probably will, be correct. So the choice is 1) show the user nothing, or\n> 2)\n> > show them something possibly incorrect. #1 will probably get no notice while\n> #2\n> > could generate bug reports. Which do you think is best?\n> \n> I think if we encounter a case where [NSString length] != string16.size() then\n> we should just bail.\n> \n> Adding temporary code to work around this isn't worth it I think.\n\nI would normally agree with you except in this case. I'm loathe to be making changes to the functions that call DecorateMatchedString to handle a nil return string. What gave you the impression that this is 'temporary' code: the original code should have guarded against this very condition. Further, as we've discovered, it should not have assumed that an NSString is going to exactly mach a string16.  Yes, it's nasty that they don't match one another (and I'm going to have to do an inventory throughout the History system) but there's a difference between making sure all of the underlying providers serve up good classifications and making sure this function doesn't crash if provided a bad classification.\n\nReturning a nil changes the current contract, complicates the code, and adds responsibilities to the clients of this function.\n\nIf you don't agree, then make a proposal that does not involve intermingling the scanning of the match string (a string16) with the NSString.","disapproval":false,"date":"2012-06-05 23:58:10.670879","approval":false},{"sender":"sail@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"On 2012/06/05 23:58:10, mrossetti wrote:\n> On 2012/06/05 23:02:08, sail wrote:\n> >\n> https://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\n> > File chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n> > \n> >\n> https://chromiumcodereview.appspot.com/10537010/diff/1/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode127\n> > chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:127: const NSInteger\n> > length = nextOffset - static_cast<NSInteger>(i->offset);\n> > > In the test case, the matchString is 40 char16s long while the converted\n> > > NSString is 37 magic Apple characters long.\n> > \n> > Ouch that really sucks. I didn't realize that this was possible. I hope we\n> > aren't affected by this in other places too.\n> > \n> > > Even in the case of bad classification offsets, some of the classifications\n> > can,\n> > > and probably will, be correct. So the choice is 1) show the user nothing, or\n> > 2)\n> > > show them something possibly incorrect. #1 will probably get no notice while\n> > #2\n> > > could generate bug reports. Which do you think is best?\n> > \n> > I think if we encounter a case where [NSString length] != string16.size() then\n> > we should just bail.\n> > \n> > Adding temporary code to work around this isn't worth it I think.\n> \n> I would normally agree with you except in this case. I'm loathe to be making\n> changes to the functions that call DecorateMatchedString to handle a nil return\n> string.\n\nAhh, makes sense.\nInstead of returning nil can we do anything else to bail early? Return an empty string or not call this function in the first place?\n\n> What gave you the impression that this is 'temporary' code: the original\n> code should have guarded against this very condition.\n\nCurrently the function is using offsets from the string16 variable to index into the NSString variable. Since their lengths don't match we'll probably have to come up with a better approach.\n\nI'm not sure what a better approach would be though :-( Sorry.\n\n> Further, as we've\n> discovered, it should not have assumed that an NSString is going to exactly mach\n> a string16.  Yes, it's nasty that they don't match one another (and I'm going to\n> have to do an inventory throughout the History system) but there's a difference\n> between making sure all of the underlying providers serve up good\n> classifications and making sure this function doesn't crash if provided a bad\n> classification.\n> \n> Returning a nil changes the current contract, complicates the code, and adds\n> responsibilities to the clients of this function.\n> \n> If you don't agree, then make a proposal that does not involve intermingling the\n> scanning of the match string (a string16) with the NSString.","disapproval":false,"date":"2012-06-06 00:10:55.385965","approval":false},{"sender":"mrossetti@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"On 2012/06/06 00:10:55, sail wrote:\n> On 2012/06/05 23:58:10, mrossetti wrote:\n> > I would normally agree with you except in this case. I'm loathe to be making\n> > changes to the functions that call DecorateMatchedString to handle a nil\n> return\n> > string.\n> \n> Ahh, makes sense.\n> Instead of returning nil can we do anything else to bail early? Return an empty\n> string \n\nI don't think we can return an empty string because this is the string that is displayed to the user in the autocomplete suggestions, however...\n\n>or not call this function in the first place?\n\n... good idea. I've added one more check earlier in the function that bails with the unadorned NSAttributedString if the lengths don't match. This way the user will get the display string, it'll just be plain.\n\n> > What gave you the impression that this is 'temporary' code: the original\n> > code should have guarded against this very condition.\n> \n> Currently the function is using offsets from the string16 variable to index into\n> the NSString variable. Since their lengths don't match we'll probably have to\n> come up with a better approach.\n> \n> I'm not sure what a better approach would be though :-( Sorry.\n\nThe better approach is to fix the underlying classification issue, which I will work on next. In the meantime, if you're comfortable with this change at least avoiding a crash I'd be grateful for an LG.","disapproval":false,"date":"2012-06-06 01:12:19.176898","approval":false},{"sender":"mrossetti@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"Added an additional check.","disapproval":false,"date":"2012-06-06 01:12:40.027586","approval":false},{"sender":"mrossetti@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"BTW, I'm checking the other platforms to see if they're handling this case in their display code. It could be that Mac is the only one catching this (albeit a bit forcefully) and the other platforms are silently not crashing — a definite security issue.","disapproval":false,"date":"2012-06-06 01:14:31.094976","approval":false},{"sender":"sail@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"LGTM!\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\nFile chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode121\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:121: // the same as the length of the converted NSString.\ncan you add the bug number to this comment?\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode134\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:134: if (i->offset >= [s length] || length <= 0)\nlooks like we don't need this anymore\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode136\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:136: const NSRange range = NSMakeRange(location,\nsame, should need this change anymore","disapproval":false,"date":"2012-06-06 01:17:37.456784","approval":true},{"sender":"sail@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"https://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\nFile chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode136\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:136: const NSRange range = NSMakeRange(location,\nOn 2012/06/06 01:17:37, sail wrote:\n> same, should need this change anymore\n\noops, should be \"shouldn't need this anymore\"","disapproval":false,"date":"2012-06-06 01:18:06.104995","approval":false},{"sender":"mrossetti@chromium.org","recipients":["mrossetti@chromium.org","sail@chromium.org","chromium-reviews@chromium.org","suzhe@chromium.org"],"text":"Will commit as soon as the bots are happy.\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm\nFile chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm (right):\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode121\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:121: // the same as the length of the converted NSString.\nOn 2012/06/06 01:17:37, sail wrote:\n> can you add the bug number to this comment?\n\nDone.\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode134\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:134: if (i->offset >= [s length] || length <= 0)\nOn 2012/06/06 01:17:37, sail wrote:\n> looks like we don't need this anymore\n\nI think we do as there is no guarantee that the classification offsets and lengths have been calculated correctly but the providers. In fact, in one of the specific test cases I'm using the string lengths are equal but one of the classifications has a length of -1.\n\nhttps://chromiumcodereview.appspot.com/10537010/diff/10001/chrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm#newcode136\nchrome/browser/ui/cocoa/omnibox/omnibox_popup_view_mac.mm:136: const NSRange range = NSMakeRange(location,\nOn 2012/06/06 01:17:37, sail wrote:\n> same, should need this change anymore\n\nSee above.","disapproval":false,"date":"2012-06-06 01:22:21.311858","approval":false}],"owner_email":"mrossetti@chromium.org","private":false,"base_url":"svn://svn.chromium.org/chrome/trunk/src/","owner":"mrossetti","subject":"Guard Against Bad Classifications","created":"2012-06-05 17:42:46.102965","patchsets":[1,4002,10001,15001],"modified":"2012-06-06 12:19:35.535794","closed":true,"commit":false,"issue":10537010}