{"description":"Avoid all library calls (including calls to destructors) after enabling the sandbox.\n\nThis ensures that the sandbox doesn't surprisingly fail, if the user instantiated\na particularly strick policy.\n\nBUG=130662\nTEST=make && ./demo32 && ./demo64\n\nCommitted: https://src.chromium.org/viewvc/chrome?view=rev&revision=141851","cc":["chromium-reviews@chromium.org","agl@chromium.org","jln+watch@chromium.org"],"reviewers":["jln@chromium.org","cevans@chromium.org"],"messages":[{"sender":"markus@chromium.org","recipients":["markus@chromium.org","jln@chromium.org","cevans@chromium.org","chromium-reviews@chromium.org","agl@chromium.org","jln+watch@chromium.org"],"text":"I am trying to keep all policy out of the sandbox compiler. But we accidentally required that all policies should allow heap manipulation (i.e. mmap()/munmap()).\n\nThis change list fixes that assumption -- at the cost of us temporarily copying data onto the stack. I know that variable-length arrays are generally frowned-upon, but it seems justified in this particular case.","disapproval":false,"date":"2012-06-08 21:42:48.499159","approval":false},{"sender":"jln@chromium.org","recipients":["markus@chromium.org","jln@chromium.org","cevans@chromium.org","chromium-reviews@chromium.org","agl@chromium.org","jln+watch@chromium.org"],"text":"https://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc\nFile sandbox/linux/seccomp-bpf/sandbox_bpf.cc (right):\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode216\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:216: Program *program = new Program();\nI would love if we didn't have to keep track (and delete() manually) a pointer. Obviously we cannot used scoped_ptr here, but I think we could have \"Program program;\" as before, but in an inside block {} that closes before we install the policy (and after we copy the program to the stack obviously).\n\nThis would rely on the same C++ guarantee as the one we have for Errorcode in the for() loop below, etc.\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode314\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:314: // stack-allocated array.\nPlease explain further that you're trying to make sure that the program vector gets de-allocated from the heap before installing the filter. As-is, I don't think it'll be clear to reviewers.\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode317\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:317: memcpy(bpf, &(*program)[0], sizeof(bpf));\nWould a static_cast of program be cleaner here ?","disapproval":false,"date":"2012-06-12 19:16:23.125967","approval":false},{"sender":"markus@chromium.org","recipients":["markus@chromium.org","jln@chromium.org","cevans@chromium.org","chromium-reviews@chromium.org","agl@chromium.org","jln+watch@chromium.org"],"text":"https://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc\nFile sandbox/linux/seccomp-bpf/sandbox_bpf.cc (right):\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode216\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:216: Program *program = new Program();\nOn 2012/06/12 19:16:23, Julien Tinnes wrote:\n> I would love if we didn't have to keep track (and delete() manually) a pointer.\n> Obviously we cannot used scoped_ptr here, but I think we could have \"Program\n> program;\" as before, but in an inside block {} that closes before we install the\n> policy (and after we copy the program to the stack obviously).\n> \n> This would rely on the same C++ guarantee as the one we have for Errorcode in\n> the for() loop below, etc.\n\nThis is tricky, and I don't think I can do it without writing even crazier code.\n\nThe problem is that we eventually need to allocate the \"bpf\" array on the stack. And when we create it, we still need access to \"program\".\n\nThis results in two mutually exclusive requirements for block scoping.\n\nSo, I think, explicit management of the heap allocated object is required. Feel free to correct me, if you can see an alternative that eludes me.\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode314\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:314: // stack-allocated array.\nOn 2012/06/12 19:16:23, Julien Tinnes wrote:\n> Please explain further that you're trying to make sure that the program vector\n> gets de-allocated from the heap before installing the filter. As-is, I don't\n> think it'll be clear to reviewers.\n\nSure, I can add a little more to the comment :-) This is subtle code, and more comments are always helpful.\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode317\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:317: memcpy(bpf, &(*program)[0], sizeof(bpf));\nOn 2012/06/12 19:16:23, Julien Tinnes wrote:\n> Would a static_cast of program be cleaner here ?\n\nI am not convinced a cast would actually do the right thing. I believe we have to make sure we execute the vector::operator[](). Feel free to correct me, if you can find a something in the STL documentation that says otherwise.","disapproval":false,"date":"2012-06-12 19:35:05.338410","approval":false},{"sender":"jln@chromium.org","recipients":["markus@chromium.org","jln@chromium.org","cevans@chromium.org","chromium-reviews@chromium.org","agl@chromium.org","jln+watch@chromium.org"],"text":"LGTM\n\n(assuming that the review tool is getting really confused because the diff base is not the same in the two iterations of the patch, i.e. that you didn't change anything else than the comment in this revision).\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc\nFile sandbox/linux/seccomp-bpf/sandbox_bpf.cc (right):\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode216\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:216: Program *program = new Program();\nOn 2012/06/12 19:35:05, Markus (顧孟勤) wrote:\n> On 2012/06/12 19:16:23, Julien Tinnes wrote:\n> > I would love if we didn't have to keep track (and delete() manually) a\n> pointer.\n> > Obviously we cannot used scoped_ptr here, but I think we could have \"Program\n> > program;\" as before, but in an inside block {} that closes before we install\n> the\n> > policy (and after we copy the program to the stack obviously).\n> > \n> > This would rely on the same C++ guarantee as the one we have for Errorcode in\n> > the for() loop below, etc.\n> \n> This is tricky, and I don't think I can do it without writing even crazier code.\n> \n> The problem is that we eventually need to allocate the \"bpf\" array on the stack.\n> And when we create it, we still need access to \"program\".\n> \n> This results in two mutually exclusive requirements for block scoping.\n> \n> So, I think, explicit management of the heap allocated object is required. Feel\n> free to correct me, if you can see an alternative that eludes me.\n\nYou're right, this becomes even more confusing.\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/1/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode317\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:317: memcpy(bpf, &(*program)[0], sizeof(bpf));\nOn 2012/06/12 19:35:05, Markus (顧孟勤) wrote:\n> On 2012/06/12 19:16:23, Julien Tinnes wrote:\n> > Would a static_cast of program be cleaner here ?\n> \n> I am not convinced a cast would actually do the right thing. I believe we have\n> to make sure we execute the vector::operator[](). Feel free to correct me, if\n> you can find a something in the STL documentation that says otherwise.\n\nThe correct solution would be to use the new vector::data(). I presume all of our toolchains already support it, but feel free to stick to the current tired method.","disapproval":false,"date":"2012-06-12 20:22:51.023288","approval":true},{"sender":"cevans@chromium.org","recipients":["markus@chromium.org","jln@chromium.org","cevans@chromium.org","chromium-reviews@chromium.org","agl@chromium.org","jln+watch@chromium.org"],"text":"LGTM, one minor nit, do what you will with it.\nI like the spirit of this CL :)\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/5001/sandbox/linux/seccomp-bpf/sandbox_bpf.cc\nFile sandbox/linux/seccomp-bpf/sandbox_bpf.cc (right):\n\nhttps://chromiumcodereview.appspot.com/10535089/diff/5001/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#newcode216\nsandbox/linux/seccomp-bpf/sandbox_bpf.cc:216: if (!program) {\nNit: not sure you need this, the standard c++ runtime should throw upon an allocation failure?","disapproval":false,"date":"2012-06-12 20:26:25.938642","approval":true}],"owner_email":"markus@chromium.org","private":false,"base_url":"svn://svn.chromium.org/chrome/trunk/src","owner":"Markus (顧孟勤)","subject":"Avoid all library calls (including calls to destructors) after enabling the sandbox.","created":"2012-06-08 21:39:04.806791","patchsets":[1,5001],"modified":"2012-06-13 04:00:03.938623","closed":true,"commit":false,"issue":10535089}