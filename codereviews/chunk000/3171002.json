{"description":"Extract connection logic from HttpNetworkTransaction into a new\nHttpStreamFactory.  The HttpNetworkTransaction now deals exclusively with\nstreams rather than connections directly.  This cut the size of HTN roughly in\nin half.\n\nThe HttpNetworkTransaction is still responsible for all proxy and server\nauthentication functions.  This is because the streams may come and go - we\ncould create a stream, have the server declare auth is needed, and then the\nnext attempt would be on a different stream.  So Auth belongs on the HNT.\nThe HNT no longer has direct access to the connection itself; instead, it\nonly knows of an HttpStream.\n\nThe StreamRequest, however, is responsible for determining whether the\nconnection needs to use a proxy, whether AlternateProtocols are available, and\nwhether the connection should be SPDY or HTTP.\n\nOther changes:\n  - moved some static configuration methods from HNT to HttpStreamFactory.\n  - added some methods to the HttpStream.\n\n\nBUG=none\nTEST=all\n\n\n\n\nCommitted: http://src.chromium.org/viewvc/chrome?view=rev&revision=56646","cc":["chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"reviewers":["vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","timurrrr@chromium.org"],"messages":[{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"This is a big change.  So I'm sending it out to several people a little early for feedback.  Any and all feedback is welcome.\n\nThe one area I'm still working on is Client Auth - which I'll work with Wan-Teh tomorrow.\n\nThere are also a couple of \"XXXMB\" left; these are placeholders for me to come back and address.  They will not be checked in until resolved.","disapproval":false,"date":"2010-08-13 07:28:05.812084","approval":false},{"sender":"erikchen@google.com","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"The net_unittest error you are having occurs b/c a SpdySession is being leaked. This is likely occurring b/c there is some test where the final MockRead(true, 0, 0) is not being read. Really we should have a check at the end of every unittest to make sure the spdysession has been released.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode210\nnet/http/http_network_transaction.cc:210: rv = stream_request_->RestartWithCertificate(client_cert, callback);\nshould you be setting next_state_ here?\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode244\nnet/http/http_network_transaction.cc:244: callback);\nshould you be setting next_state_ here?\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode808\nnet/http/http_network_transaction.cc:808: if (result <= 0)\nspdy can return ERR_IO_PENDING and not be done. this function still needs separate logic for using_spdy_.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode967\nnet/http/http_network_transaction.cc:967: stream_->Close(true);\nIs there a reason stream_.reset() is not being called?","disapproval":false,"date":"2010-08-13 19:59:15.318233","approval":false},{"sender":"rch@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/27/38012\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode456\nnet/http/http_network_transaction.cc:456: stream_->Close(!keep_alive);\nJust to reiterate my earlier point, it seems like the stream could easily figure out how to compute keep alive, and that would make HNT's job easier.  In fact, if HttpStream's destructor called Close(), then HNT's destructor here could simply let stream_ destruct itself...\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode464\nnet/http/http_network_transaction.cc:464: return request_->url.SchemeIs(\"https\");\nShould we perhaps change the name of this method from using_ssl (which seems a bit confusing if the url was http://, but we fetched it over spdy+ssl) to something like is_https_request()?\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode577\nnet/http/http_network_transaction.cc:577: stream_request_ = NULL;\nstream_request_.release()?\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode818\nnet/http/http_network_transaction.cc:818: keep_alive = GetResponseHeaders()->IsKeepAlive();\nAgain here, the computation of keep_alive is merely a function of the stream_\n\nhttp://codereview.chromium.org/3171002/diff/27/38017\nFile net/http/http_stream.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38017#newcode79\nnet/http/http_stream.h:79: virtual void Close(bool not_reusable) = 0;\nLooking at HttpNetworkTransaction, it appears that the \"not_reusable\" could be computed by the HttpStream itself.  In the case of a SpdyStream.  The callers seems to be looking at the contents of the response headers, as well as the state of stream_, both of which the http_stream has access to.  If so we could eliminate the parameter all together.  FWIW, it appears that not_reusable is all about the connection underneath the stream, as opposed to the stream itself, since it looks like everywhere the stream is Closed(), stream_ is also reset().\n\nhttp://codereview.chromium.org/3171002/diff/27/38017#newcode103\nnet/http/http_stream.h:103: virtual void GetSSLInfo(SSLInfo* ssl_info) = 0;\nThis interface seems so much cleaner that trying to extract the SSLClientSocket and interrogating it directly!","disapproval":false,"date":"2010-08-13 20:42:04.651385","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/27/38012\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode210\nnet/http/http_network_transaction.cc:210: rv = stream_request_->RestartWithCertificate(client_cert, callback);\nOn 2010/08/13 19:59:15, erikchen wrote:\n> should you be setting next_state_ here?\n\nNope - in this case we're in the STATE_INIT_STREAM_COMPLETED state (the stream_request is still active).  I should add a DCHECK to make this more clear.\n\nI am still working on this part of the code tho.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode244\nnet/http/http_network_transaction.cc:244: callback);\nOn 2010/08/13 19:59:15, erikchen wrote:\n> should you be setting next_state_ here?\n\nNo - same as above.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode808\nnet/http/http_network_transaction.cc:808: if (result <= 0)\nAs per discussion, I don't think so.  We should not be coming into this routine with ERR_IO_PENDING.  I'll DCHECK that just for good measure.\n\nOn 2010/08/13 19:59:15, erikchen wrote:\n> spdy can return ERR_IO_PENDING and not be done. this function still needs\n> separate logic for using_spdy_.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode967\nnet/http/http_network_transaction.cc:967: stream_->Close(true);\nOn 2010/08/13 19:59:15, erikchen wrote:\n> Is there a reason stream_.reset() is not being called?\n\nNo.  added.","disapproval":false,"date":"2010-08-13 20:55:12.553794","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/27/38012\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode456\nnet/http/http_network_transaction.cc:456: stream_->Close(!keep_alive);\nOn 2010/08/13 20:42:04, rch wrote:\n> Just to reiterate my earlier point, it seems like the stream could easily figure\n> out how to compute keep alive, and that would make HNT's job easier.  In fact,\n> if HttpStream's destructor called Close(), then HNT's destructor here could\n> simply let stream_ destruct itself...\n\nI think you're right.  I'm adding a TODO for it.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode464\nnet/http/http_network_transaction.cc:464: return request_->url.SchemeIs(\"https\");\nOn 2010/08/13 20:42:04, rch wrote:\n> Should we perhaps change the name of this method from using_ssl (which seems a\n> bit confusing if the url was http://, but we fetched it over spdy+ssl) to\n> something like is_https_request()?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode577\nnet/http/http_network_transaction.cc:577: stream_request_ = NULL;\nOn 2010/08/13 20:42:04, rch wrote:\n> stream_request_.release()?\n\nNo - that would release the pointer, but not clean it up.  I've updated the comment to not say \"release\" :-)\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode818\nnet/http/http_network_transaction.cc:818: keep_alive = GetResponseHeaders()->IsKeepAlive();\nOn 2010/08/13 20:42:04, rch wrote:\n> Again here, the computation of keep_alive is merely a function of the stream_\n\nAgree, also marked the TODO().\n\nhttp://codereview.chromium.org/3171002/diff/27/38017\nFile net/http/http_stream.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38017#newcode79\nnet/http/http_stream.h:79: virtual void Close(bool not_reusable) = 0;\nOn 2010/08/13 20:42:04, rch wrote:\n> Looking at HttpNetworkTransaction, it appears that the \"not_reusable\" could be\n> computed by the HttpStream itself.  In the case of a SpdyStream.  The callers\n> seems to be looking at the contents of the response headers, as well as the\n> state of stream_, both of which the http_stream has access to.  If so we could\n> eliminate the parameter all together.  FWIW, it appears that not_reusable is all\n> about the connection underneath the stream, as opposed to the stream itself,\n> since it looks like everywhere the stream is Closed(), stream_ is also reset().\n\n\nYes, basically there are times where the HttpNetworkTransaction wants to influence the underlying connection.  As you point out, with a little more smarts in the Stream, maybe the stream can do this and we won't need it to be passed through.  If it is ok with you - I'll take that work on in a separate CL.","disapproval":false,"date":"2010-08-13 21:26:06.904510","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"FYI - I've cleaned up client auth (thanks, wtc!) and finished all nits I have.  So it is fully ready for your review.","disapproval":false,"date":"2010-08-13 22:53:11.582427","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"A few initial comments - starting my review over with patch set 14.\n\nhttp://codereview.chromium.org/3171002/diff/27/38010\nFile net/http/http_network_session.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38010#newcode64\nnet/http/http_network_session.cc:64: ALLOW_THIS_IN_INITIALIZER_LIST(\nIn a later CL, should all the socket factories get moved inside the stream factory?\n\nhttp://codereview.chromium.org/3171002/diff/27/38012\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode390\nnet/http/http_network_transaction.cc:390: int rv = DoLoop(OK);\nYou could just call OnIOComplete at the end of each of these.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode813\nnet/http/http_network_transaction.cc:813: // Note: Just because IsResponseBodyComplete is true, we're not\nHave you seen a case where more data is read after IsResponseBodyComplete returns true, are you just changing the semantic of exactly when we cleanup the connection?\n\nhttp://codereview.chromium.org/3171002/diff/27/38020\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38020#newcode579\nnet/http/http_stream_parser.cc:579: if (request_->url.SchemeIs(\"https\")) {\nShould this and GetSSLCertRequestInfo also check connection_->IsConnected() first?  It might prevent an incorrect cast in some in-between states, like during tunnel auth. (or maybe not)\n\nhttp://codereview.chromium.org/3171002/diff/27/38021\nFile net/http/http_stream_parser.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38021#newcode66\nnet/http/http_stream_parser.h:66: void GetSSLInfo(SSLInfo* ssl_info);\nI think these should be handled in the HttpBasicStream class.  The idea is to have multiple HttpStreamParsers on a single socket in the pipelined case.","disapproval":false,"date":"2010-08-13 23:00:01.869899","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/27/38010\nFile net/http/http_network_session.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38010#newcode64\nnet/http/http_network_session.cc:64: ALLOW_THIS_IN_INITIALIZER_LIST(\nOn 2010/08/13 23:00:01, vandebo wrote:\n> In a later CL, should all the socket factories get moved inside the stream\n> factory?\n\nYup - I think that is a better container.  Added a TODO().\n\nhttp://codereview.chromium.org/3171002/diff/27/38012\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode390\nnet/http/http_network_transaction.cc:390: int rv = DoLoop(OK);\nOn 2010/08/13 23:00:01, vandebo wrote:\n> You could just call OnIOComplete at the end of each of these.\n\nGood call. done.\n\nhttp://codereview.chromium.org/3171002/diff/27/38012#newcode813\nnet/http/http_network_transaction.cc:813: // Note: Just because IsResponseBodyComplete is true, we're not\nI actually don't think I changed the semantics here - the semantics were just weird.  I think it could maybe further be simplified.  The reason I don't think it changes is because we should get a zero length read when the stream is really finshed; closing the stream before that is wrong.  Previously we would reset the connection (releasing it to the pool) one read earlier, but the overall semantics are equivalent.  Hopefully that sounds right?\n\nOn 2010/08/13 23:00:01, vandebo wrote:\n> Have you seen a case where more data is read after IsResponseBodyComplete\n> returns true, are you just changing the semantic of exactly when we cleanup the\n> connection?\n\nhttp://codereview.chromium.org/3171002/diff/27/38020\nFile net/http/http_stream_parser.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38020#newcode579\nnet/http/http_stream_parser.cc:579: if (request_->url.SchemeIs(\"https\")) {\nOn 2010/08/13 23:00:01, vandebo wrote:\n> Should this and GetSSLCertRequestInfo also check connection_->IsConnected()\n> first?  It might prevent an incorrect cast in some in-between states, like\n> during tunnel auth. (or maybe not)\n\nDone.  (BTW - this exposed a bug in the MockSSLClientSocket where it isn't tracking connected state properly- separate CL in progress for that now)\n\nhttp://codereview.chromium.org/3171002/diff/27/38021\nFile net/http/http_stream_parser.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/27/38021#newcode66\nnet/http/http_stream_parser.h:66: void GetSSLInfo(SSLInfo* ssl_info);\nOn 2010/08/13 23:00:01, vandebo wrote:\n> I think these should be handled in the HttpBasicStream class.  The idea is to\n> have multiple HttpStreamParsers on a single socket in the pipelined case.\n\nThat would be fine by me - but for now, the connection_ (which is needed here) is owned at the HttpStreamParser level...","disapproval":false,"date":"2010-08-16 03:38:44.410431","approval":false},{"sender":"wtc@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Mike,\n\nI don't have time to review this CL.  Sorry.  I trust\nthat between you and vandebo the refactoring\nwill be done right.","disapproval":false,"date":"2010-08-16 18:52:28.520596","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"+eroman, +gavinp","disapproval":false,"date":"2010-08-16 21:34:07.513248","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"My comments so far...\n\nhttp://codereview.chromium.org/3171002/diff/57006/26014\nFile net/http/http_network_session.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26014#newcode65\nnet/http/http_network_session.cc:65: http_stream_factory_(new HttpStreamFactory(this))),\nI think this will create a circular reference on HttpNetworkSession, preventing it from ever being freed.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26015\nFile net/http/http_network_session.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26015#newcode172\nnet/http/http_network_session.h:172: scoped_refptr<HttpStreamFactory> http_stream_factory_;\nShould this be just a scoped_refptr<StreamFactory> ?  Or is the StreamFactory / HttpStreamFactory distinction actually an explicit HTTP support issue?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (left):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode436\nnet/http/http_network_transaction.cc:436: if (!using_spdy_ && !connection_->is_initialized()) {\nShouldn't this turn into if(!stream_.get()) ?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode314\nnet/http/http_network_transaction.cc:314: stream_request_.get() && stream_request_->establishing_tunnel()) {\nIs it possible to get a Read with stream_request_ != NULL and not establishing a tunnel?  I'm thinking it's not.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\nnet/http/http_network_transaction.cc:1065: if (connection_is_proven && !has_received_headers)\nI don't think this captures all of cases that used to, but you've probably thought about it more?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26020\nFile net/http/http_response_info.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26020#newcode10\nnet/http/http_response_info.h:10: #include \"net/base/ssl_cert_request_info.h\"\nIs this change needed?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021\nFile net/http/http_stream.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode26\nnet/http/http_stream.h:26: class SSLCertRequestInfo;\nAlphabetize\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode77\nnet/http/http_stream.h:77: // |not_reusable| indicates if the stream can be used for further requests.\nIs it the stream that's reusable, or the underlying connection?  I think a stream is still only good for a single transaction.  This is fine, just clarifying the comment would be good.\n\nI'm not sure we could completely fold in the flag, but we could probably do some of the checking within the Close method and the flag could then only indicate the cases where the consumers of the class think it shouldn't be reused.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode102\nnet/http/http_stream.h:102: virtual void SetConnectionReused() = 0;\nIs it possible to establish this state automatically?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode104\nnet/http/http_stream.h:104: // Get the SSLInfo associated with this stream's connection.\nIt would be good to document the behavior of this method and the next for the non-ssl connection case.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26022\nFile net/http/http_stream_factory.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26022#newcode22\nnet/http/http_stream_factory.cc:22: const HostMappingRules* HttpStreamFactory::host_mapping_rules_ = NULL;\n// static ?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023\nFile net/http/http_stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023#newcode8\nnet/http/http_stream_factory.h:8: #include <map>\nis map needed?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023#newcode46\nnet/http/http_stream_factory.h:46: // TLS Intolerant Server API\nWhy are these not exposed in the HttpStream interface?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023#newcode86\nnet/http/http_stream_factory.h:86: // Sets the HttpNetworkTransaction into a mode where it can ignore\nHttpNetworkTransaction -> HttpSteamFactory\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026\nFile net/http/http_stream_request.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode71\nnet/http/http_stream_request.cc:71: if (!using_spdy_ && connection_.get())\nFYI, this isn't strictly necessary because it will happen anyway due to scoped_ptr<ClientSocketHandle>\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode78\nnet/http/http_stream_request.cc:78: int HttpStreamRequest::Start(const HttpRequestInfo* request_info,\nLooks like this returns a net error code and theoretically could return synchronously.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode145\nnet/http/http_stream_request.cc:145: DCHECK(using_ssl_);\nShould also DCHECK(!establishing_tunnel)\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode213\nnet/http/http_stream_request.cc:213: switch (result) {\nIf you want to get rid of this switch, you can fold at least the error cases into DoInitConnectionComplete.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode241\nnet/http/http_stream_request.cc:241: user_callback_ = callback;\nWhy do we even have usercallback?  Completion in immediate or singalled to the delegate by OnStreamReady.\nShould only set usercallback if callback != NULL\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode815\nnet/http/http_stream_request.cc:815: next_state_ = STATE_INIT_CONNECTION;\nIt would be good to DCHECK(!connection_.get() || !connection_->socket()).\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028\nFile net/http/stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode5\nnet/http/stream_factory.h:5: #ifndef NET_HTTP_STREAM_FACTORY_H_\nDo you have both this interface and the HttpStreamFactory class per my request to ease pipelined streams?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode34\nnet/http/stream_factory.h:34: // This is the success case.\nCan you comment on ownership of the passed stream?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode47\nnet/http/stream_factory.h:47: // the authentication failure and restart the StreamRequest entirely.\nComment on ownership of the pointers?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode49\nnet/http/stream_factory.h:49: const HttpResponseInfo* proxy_response) = 0;\nconst ref?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode52\nnet/http/stream_factory.h:52: virtual void OnNeedsClientAuth(SSLCertRequestInfo* cert_info) = 0;\nconst ref?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode65\nnet/http/stream_factory.h:65: // 3 parameters are passed in by reference.  The caller asserts that the\nThis sentence seems redundant with the next.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode69\nnet/http/stream_factory.h:69: virtual int Start(const HttpRequestInfo* request_info,\nIt seems that StreamFactory is already HTTP specific.  So maybe it should be HttpStreamFactory and the current HttpStreamFactory should be HttpStreamFactoryImpl?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode71\nnet/http/stream_factory.h:71: ProxyInfo* proxy_info,\nGiven the warning in the comment, can you make these const refs ?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode84\nnet/http/stream_factory.h:84: virtual int RestartWithCertificate(X509Certificate* client_cert,\nWill const ref work?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode101\nnet/http/stream_factory.h:101: virtual bool establishing_tunnel() const = 0;\nDoesn't seem that this interface needs this method.  Either the request is outstanding and the caller doesn't yet have the stream, or the caller knows and can keep track of being between OnNeedsProxyAuth() and RestartTunnelWithProxyAuth().\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode119\nnet/http/stream_factory.h:119: // This method always completes asynchronously and returns the new stream via\nIs this comment out of date?  I don't see a request id handle on the Cancel method.  Should this method just return the scoped_refptr<StreamRequestJob> ?","disapproval":false,"date":"2010-08-16 22:31:30.651203","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Rest of my comments from patch set 14.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (left):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode699\nnet/http/http_network_transaction.cc:699: DCHECK(!connection_->is_initialized());\nThese two DCHECKs didn't make the move.  Are they trivially true now?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode1024\nnet/http/http_network_transaction.cc:1024: if (result == ERR_PROXY_AUTH_REQUESTED)\nThis check didn't make the move the HttpStreamRequest, and I think it's required.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode1096\nnet/http/http_network_transaction.cc:1096: if (request_headers_.empty() && !using_spdy_) {\nIIRC, spdy doesn't use the passed headers, so why bother to generate them in the spdy case?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode619\nnet/http/http_network_transaction.cc:619: if (stream_.get())\nWhat's going on with this change?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode713\nnet/http/http_network_transaction.cc:713: response_.cert_request_info = new SSLCertRequestInfo;\nSince you removed the if(using_ssl_), this should probably DCHECK that we are using SSL before trying to get the CertRequestInfo.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode751\nnet/http/http_network_transaction.cc:751: if (result == ERR_CONNECTION_CLOSED) {\nMaybe just pull this if above the Log call and DCHECK(result == OK) ?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26031\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26031#newcode22\nnet/spdy/spdy_http_stream.cc:22: \nExtra line\n\nhttp://codereview.chromium.org/3171002/diff/57006/26033\nFile net/spdy/spdy_network_transaction_unittest.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26033#newcode1251\nnet/spdy/spdy_network_transaction_unittest.cc:1251: MockWrite(false, ERR_IO_PENDING, 0)\nDo these changes indicate a small change in behavior?","disapproval":false,"date":"2010-08-16 23:24:02.035940","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"nits on patch set 21.\n\nhttp://codereview.chromium.org/3171002/diff/7039/22048\nFile net/http/http_stream_handle.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/7039/22048#newcode10\nnet/http/http_stream_handle.h:10: \nShould also include client_socket_handle.h\n\nhttp://codereview.chromium.org/3171002/diff/7039/22052\nFile net/http/http_stream_request.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/7039/22052#newcode73\nnet/http/http_stream_request.h:73: STATE_WAITING_USER_ACTION,\nnit: AWAITING / WAITING_FOR ?","disapproval":false,"date":"2010-08-16 23:36:57.810387","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/57006/26014\nFile net/http/http_network_session.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26014#newcode65\nnet/http/http_network_session.cc:65: http_stream_factory_(new HttpStreamFactory(this))),\nOn 2010/08/16 22:31:30, vandebo wrote:\n> I think this will create a circular reference on HttpNetworkSession, preventing\n> it from ever being freed.\n\nNice spot on this - you're right.  I found it yesterday and fixed it this morning in the latest revision.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode314\nnet/http/http_network_transaction.cc:314: stream_request_.get() && stream_request_->establishing_tunnel()) {\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Is it possible to get a Read with stream_request_ != NULL and not establishing a\n> tunnel?  I'm thinking it's not.\n\nI agree.  Changed the if and added a DCHECK.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\nnet/http/http_network_transaction.cc:1065: if (connection_is_proven && !has_received_headers)\nOn 2010/08/16 22:31:30, vandebo wrote:\n> I don't think this captures all of cases that used to, but you've probably\n> thought about it more?\n\nI did spend a lot of time thinking about this.  It was tricky to untangle exactly what the old code was trying to do.  In particular, there is a case of ShouldResendFailedRequest where it differentiated \"unused\" vs \"unused_idle\" sockets, which I didn't think was correct.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26020\nFile net/http/http_response_info.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26020#newcode10\nnet/http/http_response_info.h:10: #include \"net/base/ssl_cert_request_info.h\"\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Is this change needed?\n\nI was hoping you didn't notice.  It's some C++ include error I can't figure out.  I get a template problem with SSLCertRequestInfo being referenced via refptr<> without it.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021\nFile net/http/http_stream.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode26\nnet/http/http_stream.h:26: class SSLCertRequestInfo;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Alphabetize\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode77\nnet/http/http_stream.h:77: // |not_reusable| indicates if the stream can be used for further requests.\nI updated the comment.\n\nI agree on the TODO() - and I will revisit.\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Is it the stream that's reusable, or the underlying connection?  I think a\n> stream is still only good for a single transaction.  This is fine, just\n> clarifying the comment would be good.\n> \n> I'm not sure we could completely fold in the flag, but we could probably do some\n> of the checking within the Close method and the flag could then only indicate\n> the cases where the consumers of the class think it shouldn't be reused.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode102\nnet/http/http_stream.h:102: virtual void SetConnectionReused() = 0;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Is it possible to establish this state automatically?\n\nIt might be.  I'd rather not change the logic back to HttpNetworkTransaction here.  I updated the TODO to cover this as well.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode104\nnet/http/http_stream.h:104: // Get the SSLInfo associated with this stream's connection.\nOn 2010/08/16 22:31:30, vandebo wrote:\n> It would be good to document the behavior of this method and the next for the\n> non-ssl connection case.\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26022\nFile net/http/http_stream_factory.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26022#newcode22\nnet/http/http_stream_factory.cc:22: const HostMappingRules* HttpStreamFactory::host_mapping_rules_ = NULL;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> // static ?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023\nFile net/http/http_stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023#newcode8\nnet/http/http_stream_factory.h:8: #include <map>\nOn 2010/08/16 22:31:30, vandebo wrote:\n> is map needed?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023#newcode46\nnet/http/http_stream_factory.h:46: // TLS Intolerant Server API\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Why are these not exposed in the HttpStream interface?\n\nI liked them here, because the settings persist longer than the lifetime of the stream.  However, they could be added to the stream as well; they are generic, not specific to any particular stream type (http/spdy)\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023#newcode86\nnet/http/http_stream_factory.h:86: // Sets the HttpNetworkTransaction into a mode where it can ignore\nOn 2010/08/16 22:31:30, vandebo wrote:\n> HttpNetworkTransaction -> HttpSteamFactory\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026\nFile net/http/http_stream_request.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode71\nnet/http/http_stream_request.cc:71: if (!using_spdy_ && connection_.get())\nYeah - code removed!\n\nOn 2010/08/16 22:31:30, vandebo wrote:\n> FYI, this isn't strictly necessary because it will happen anyway due to\n> scoped_ptr<ClientSocketHandle>\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode78\nnet/http/http_stream_request.cc:78: int HttpStreamRequest::Start(const HttpRequestInfo* request_info,\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Looks like this returns a net error code and theoretically could return\n> synchronously.\n\nYes.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode145\nnet/http/http_stream_request.cc:145: DCHECK(using_ssl_);\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Should also DCHECK(!establishing_tunnel)\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode213\nnet/http/http_stream_request.cc:213: switch (result) {\nOn 2010/08/16 22:31:30, vandebo wrote:\n> If you want to get rid of this switch, you can fold at least the error cases\n> into DoInitConnectionComplete.\n\nI know - I tried this a couple of different ways.  Which do you think is better?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode241\nnet/http/http_stream_request.cc:241: user_callback_ = callback;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Why do we even have usercallback?  Completion in immediate or singalled to the\n> delegate by OnStreamReady.\n> Should only set usercallback if callback != NULL\n\nDuh - of course.  I can prune this out.  We never call it, just pass it around...  Removed!\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode815\nnet/http/http_stream_request.cc:815: next_state_ = STATE_INIT_CONNECTION;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> It would be good to DCHECK(!connection_.get() || !connection_->socket()).\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028\nFile net/http/stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode5\nnet/http/stream_factory.h:5: #ifndef NET_HTTP_STREAM_FACTORY_H_\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Do you have both this interface and the HttpStreamFactory class per my request\n> to ease pipelined streams?\n\nYes, partially.  Does it meet your needs?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode34\nnet/http/stream_factory.h:34: // This is the success case.\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Can you comment on ownership of the passed stream?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode47\nnet/http/stream_factory.h:47: // the authentication failure and restart the StreamRequest entirely.\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Comment on ownership of the pointers?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode49\nnet/http/stream_factory.h:49: const HttpResponseInfo* proxy_response) = 0;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> const ref?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode52\nnet/http/stream_factory.h:52: virtual void OnNeedsClientAuth(SSLCertRequestInfo* cert_info) = 0;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> const ref?\n\nNo - this is a reference counted object; documented the lifetime.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode65\nnet/http/stream_factory.h:65: // 3 parameters are passed in by reference.  The caller asserts that the\nOn 2010/08/16 22:31:30, vandebo wrote:\n> This sentence seems redundant with the next.\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode69\nnet/http/stream_factory.h:69: virtual int Start(const HttpRequestInfo* request_info,\nOn 2010/08/16 22:31:30, vandebo wrote:\n> It seems that StreamFactory is already HTTP specific.  So maybe it should be\n> HttpStreamFactory and the current HttpStreamFactory should be\n> HttpStreamFactoryImpl?\n\nFor now that may be true, but I do think that websockets will add another dimension.  Even if the arguments are less than perfect now, I'd prefer the current naming, and then expand to make more generic as necessary?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode71\nnet/http/stream_factory.h:71: ProxyInfo* proxy_info,\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Given the warning in the comment, can you make these const refs ?\n\nNo-  they get modified on both sides.  That's the strange part of the contract between these two classes.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode84\nnet/http/stream_factory.h:84: virtual int RestartWithCertificate(X509Certificate* client_cert,\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Will const ref work?\n\nThe receiver is likely going to stick this cert into the SSLConfig, which is not-const.  I don't really want to dig into the const-ness of that object?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode119\nnet/http/stream_factory.h:119: // This method always completes asynchronously and returns the new stream via\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Is this comment out of date?  I don't see a request id handle on the Cancel\n> method.  Should this method just return the scoped_refptr<StreamRequestJob> ?\n\nComment was out of date.  I waffled on the return value.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26031\nFile net/spdy/spdy_http_stream.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26031#newcode22\nnet/spdy/spdy_http_stream.cc:22: \nOn 2010/08/16 23:24:02, vandebo wrote:\n> Extra line\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26033\nFile net/spdy/spdy_network_transaction_unittest.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26033#newcode1251\nnet/spdy/spdy_network_transaction_unittest.cc:1251: MockWrite(false, ERR_IO_PENDING, 0)\nOn 2010/08/16 23:24:02, vandebo wrote:\n> Do these changes indicate a small change in behavior?\n\nYes, it has to do with that we post back through the message loop instead of completing immediately.  In looking through the old code, I realize my comment at our discussion today was incorrect - the old code does *not* post back through the messageloop.","disapproval":false,"date":"2010-08-16 23:55:11.695426","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Thanks, Steve - your comments are really helpful.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (left):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode699\nnet/http/http_network_transaction.cc:699: DCHECK(!connection_->is_initialized());\nOn 2010/08/16 23:24:02, vandebo wrote:\n> These two DCHECKs didn't make the move.  Are they trivially true now?\n\nRe-added...\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode1024\nnet/http/http_network_transaction.cc:1024: if (result == ERR_PROXY_AUTH_REQUESTED)\nOn 2010/08/16 23:24:02, vandebo wrote:\n> This check didn't make the move the HttpStreamRequest, and I think it's\n> required.\n\nI don't think so; this result will simply pass through and be returned to the caller; we'll fall through RunLoop, and then call the delegate for OnNeedsProxyAuth.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode1096\nnet/http/http_network_transaction.cc:1096: if (request_headers_.empty() && !using_spdy_) {\nOn 2010/08/16 23:24:02, vandebo wrote:\n> IIRC, spdy doesn't use the passed headers, so why bother to generate them in the\n> spdy case?\n\nRight you are - my oversight.  Fixed.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode619\nnet/http/http_network_transaction.cc:619: if (stream_.get())\nOn 2010/08/16 23:24:02, vandebo wrote:\n> What's going on with this change?\n\nThe change looks funny because the state \"STATE_INIT_STREAM\" has different meaning than before.  If we have a stream after we got our auth credentials, we're ready to go straight into STATE_SEND_REQUEST.  If we don't have a stream, then we need to go get one.\n\nIn the old state machine STATE_INIT_STREAM was kind of a pseudo-state for SPDY which was used just before calling STATE_SEND_REQUEST.\n\nI might be able to get away with a DCHECK(stream_.get()) and always proceeding to STATE_SEND_REQUEST.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode713\nnet/http/http_network_transaction.cc:713: response_.cert_request_info = new SSLCertRequestInfo;\nOn 2010/08/16 23:24:02, vandebo wrote:\n> Since you removed the if(using_ssl_), this should probably DCHECK that we are\n> using SSL before trying to get the CertRequestInfo.\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode751\nnet/http/http_network_transaction.cc:751: if (result == ERR_CONNECTION_CLOSED) {\nOn 2010/08/16 23:24:02, vandebo wrote:\n> Maybe just pull this if above the Log call and DCHECK(result == OK) ?\n\nHmm - I don't understand?  Looks like we can drop through with other codes?\n\nhttp://codereview.chromium.org/3171002/diff/7039/22048\nFile net/http/http_stream_handle.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/7039/22048#newcode10\nnet/http/http_stream_handle.h:10: \nOn 2010/08/16 23:36:57, vandebo wrote:\n> Should also include client_socket_handle.h\n\nDone.","disapproval":false,"date":"2010-08-17 00:35:26.569026","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Just some small/interface clarity stuff.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (left):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#oldcode1024\nnet/http/http_network_transaction.cc:1024: if (result == ERR_PROXY_AUTH_REQUESTED)\nOn 2010/08/17 00:35:26, Mike Belshe wrote:\n> On 2010/08/16 23:24:02, vandebo wrote:\n> > This check didn't make the move the HttpStreamRequest, and I think it's\n> > required.\n> \n> I don't think so; this result will simply pass through and be returned to the\n> caller; we'll fall through RunLoop, and then call the delegate for\n> OnNeedsProxyAuth.\n\nHmm, it does seem that ReconsiderProxyAfterError has no side-effects when getting this error code, but the function name doesn't imply that.  It might make things easier to understand in the future to handle this error explicitly (even if it's just to return it up the stack).\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode619\nnet/http/http_network_transaction.cc:619: if (stream_.get())\nOn 2010/08/17 00:35:26, Mike Belshe wrote:\n> On 2010/08/16 23:24:02, vandebo wrote:\n> > What's going on with this change?\n> \n> The change looks funny because the state \"STATE_INIT_STREAM\" has different\n> meaning than before.  If we have a stream after we got our auth credentials,\n> we're ready to go straight into STATE_SEND_REQUEST.  If we don't have a stream,\n> then we need to go get one.\n> \n> In the old state machine STATE_INIT_STREAM was kind of a pseudo-state for SPDY\n> which was used just before calling STATE_SEND_REQUEST.\n> \n> I might be able to get away with a DCHECK(stream_.get()) and always proceeding\n> to STATE_SEND_REQUEST.\n\nYea, it looks like the only way to get to this state is through DoInitStreamComplete.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode751\nnet/http/http_network_transaction.cc:751: if (result == ERR_CONNECTION_CLOSED) {\nOn 2010/08/17 00:35:26, Mike Belshe wrote:\n> On 2010/08/16 23:24:02, vandebo wrote:\n> > Maybe just pull this if above the Log call and DCHECK(result == OK) ?\n> \n> Hmm - I don't understand?  Looks like we can drop through with other codes?\n\nThis is nothing - I was just saying that you add the if (OK); instead, you could move the CONNECTION_CLOSED block above the LogTransaction... block and DCHECK_EQ(OK, result)\n\nhttp://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\nnet/http/http_network_transaction.cc:1065: if (connection_is_proven && !has_received_headers)\nOn 2010/08/16 23:55:11, Mike Belshe wrote:\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > I don't think this captures all of cases that used to, but you've probably\n> > thought about it more?\n> \n> I did spend a lot of time thinking about this.  It was tricky to untangle\n> exactly what the old code was trying to do.  In particular, there is a case of\n> ShouldResendFailedRequest where it differentiated \"unused\" vs \"unused_idle\"\n> sockets, which I didn't think was correct. \n\nSometimes we end up connecting a socket, but not needing it because we reuse another socket first.  So we can end up with a socket that hasn't ever been used, but has sat idle for a long time.  For this purpose, we should treat it as a reused socket because it might have timed out - meaning we should try again with a fresh socket.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26020\nFile net/http/http_response_info.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26020#newcode10\nnet/http/http_response_info.h:10: #include \"net/base/ssl_cert_request_info.h\"\nOn 2010/08/16 23:55:11, Mike Belshe wrote:\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > Is this change needed?\n> \n> I was hoping you didn't notice.  It's some C++ include error I can't figure out.\n>  I get a template problem with SSLCertRequestInfo being referenced via refptr<>\n> without it.\n\nMan those can be a real PITA. Should probably figure it out though. What context are you getting the error in?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021\nFile net/http/http_stream.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26021#newcode21\nnet/http/http_stream.h:21: struct HttpRequestInfo;\nI know it's not you, but this is in the wrong order too.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023\nFile net/http/http_stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26023#newcode46\nnet/http/http_stream_factory.h:46: // TLS Intolerant Server API\nOn 2010/08/16 23:55:11, Mike Belshe wrote:\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > Why are these not exposed in the HttpStream interface?\n> \n> I liked them here, because the settings persist longer than the lifetime of the\n> stream.  However, they could be added to the stream as well; they are generic,\n> not specific to any particular stream type (http/spdy)\n\nSorry, I meant StreamFactory interface.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026\nFile net/http/http_stream_request.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode78\nnet/http/http_stream_request.cc:78: int HttpStreamRequest::Start(const HttpRequestInfo* request_info,\nOn 2010/08/16 23:55:11, Mike Belshe wrote:\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > Looks like this returns a net error code and theoretically could return\n> > synchronously.\n> \n> Yes.\n\nOk, so the comment in StreamFactory should just say that Start returns a net error node, but the delegate will always be called. Hmm.  If that's the case, why return anything at all?\n\nhttp://codereview.chromium.org/3171002/diff/57006/26026#newcode213\nnet/http/http_stream_request.cc:213: switch (result) {\nOn 2010/08/16 23:55:11, Mike Belshe wrote:\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > If you want to get rid of this switch, you can fold at least the error cases\n> > into DoInitConnectionComplete.\n> \n> I know - I tried this a couple of different ways.  Which do you think is better?\n\nShorter functions are better, but RunLoop is kind of strange with DoLoop as well.  If folding them in would get rid of RunLoop, it might be worth it.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028\nFile net/http/stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode5\nnet/http/stream_factory.h:5: #ifndef NET_HTTP_STREAM_FACTORY_H_\nOn 2010/08/16 23:55:11, Mike Belshe wrote:\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > Do you have both this interface and the HttpStreamFactory class per my request\n> > to ease pipelined streams?\n> \n> Yes, partially.  Does it meet your needs?\n\nBecause of the TLSIntolerant and alternate protocol stuff it makes it much less clear if it's a win. The PiplinedHttpStreamFactory should be below that level... If it's not too much trouble, you can get rid of the extra layer and I'll deal with it later.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode71\nnet/http/stream_factory.h:71: ProxyInfo* proxy_info,\nOn 2010/08/16 23:55:11, Mike Belshe wrote:\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > Given the warning in the comment, can you make these const refs ?\n> \n> No-  they get modified on both sides.  That's the strange part of the contract\n> between these two classes.\n\nHmm, indeed.  Since they are both in and out arguments, should the net_log come first?  I know it usually goes at the end, but the style guide says it should be the first arg in this case.  I'm ok ignoring the style guide here, just pointing it out.\n\nhttp://codereview.chromium.org/3171002/diff/57006/26028#newcode101\nnet/http/stream_factory.h:101: virtual bool establishing_tunnel() const = 0;\nOn 2010/08/16 22:31:30, vandebo wrote:\n> Doesn't seem that this interface needs this method.  Either the request is\n> outstanding and the caller doesn't yet have the stream, or the caller knows and\n> can keep track of being between OnNeedsProxyAuth() and\n> RestartTunnelWithProxyAuth().\n\nWhat do you think of killing this method?\n\nhttp://codereview.chromium.org/3171002/diff/75006/28029\nFile net/http/http_stream_request.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/75006/28029#newcode161\nnet/http/http_stream_request.cc:161: const HttpRequestInfo& HttpStreamRequest::request_info() const {\nIs there are reason for these three accessors to return references instead of just returning the pointers?  It seems that half the time, you end up taking the address of the reference anyway.\n\nhttp://codereview.chromium.org/3171002/diff/75006/28031\nFile net/http/stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/75006/28031#newcode33\nnet/http/stream_factory.h:33: virtual ~StreamRequestDelegate() {};\nextra ; ?\n\nhttp://codereview.chromium.org/3171002/diff/75006/28031#newcode53\nnet/http/stream_factory.h:53: virtual void OnNeedsProxyAuth(HttpAuthController* auth_controller,\nhow about making this a const scoped_refptr<HttpAuthController>& auth_controller\n\nhttp://codereview.chromium.org/3171002/diff/75006/28031#newcode60\nnet/http/stream_factory.h:60: virtual void OnNeedsClientAuth(SSLCertRequestInfo* cert_info) = 0;\nconst scoped_refptr<SSLCertRequestInfo>& cert_info ?\n\nhttp://codereview.chromium.org/3171002/diff/75006/28031#newcode95\nnet/http/stream_factory.h:95: virtual int RestartWithCertificate(X509Certificate* client_cert) = 0;\nconst scoped_refptr<X509Certificate>& client_cert ?","disapproval":false,"date":"2010-08-17 17:18:52.576662","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"[Had to snip, because rietveld can't handle more than 10K characters]\n\nOn 2010/08/17 17:18:52, vandebo:\n> http://codereview.chromium.org/3171002/diff/57006/26016#oldcode1024\n> net/http/http_network_transaction.cc:1024: if (result ==\n> ERR_PROXY_AUTH_REQUESTED)\n> On 2010/08/17 00:35:26, Mike Belshe wrote:\n> > On 2010/08/16 23:24:02, vandebo wrote:\n> > [snip]\n> > I don't think so; this result will simply pass through and be returned to the\n> > caller; we'll fall through RunLoop, and then call the delegate for\n> > OnNeedsProxyAuth.\n> \n> Hmm, it does seem that ReconsiderProxyAfterError has no side-effects when\n> getting this error code, but the function name doesn't imply that.  It might\n> make things easier to understand in the future to handle this error explicitly\n> (even if it's just to return it up the stack).\n\nOK - done.\n\n> http://codereview.chromium.org/3171002/diff/57006/26016#newcode619\n> net/http/http_network_transaction.cc:619: if (stream_.get())\n> On 2010/08/17 00:35:26, Mike Belshe wrote:\n> > On 2010/08/16 23:24:02, vandebo wrote:\n> > > What's going on with this change?\n> > \n> > [snip]\n> \n> Yea, it looks like the only way to get to this state is through\n> DoInitStreamComplete.\n\nok\n\n\n> \n> http://codereview.chromium.org/3171002/diff/57006/26016#newcode751\n> net/http/http_network_transaction.cc:751: if (result == ERR_CONNECTION_CLOSED) {\n> On 2010/08/17 00:35:26, Mike Belshe wrote:\n> > On 2010/08/16 23:24:02, vandebo wrote:\n> > > Maybe just pull this if above the Log call and DCHECK(result == OK) ?\n> > \n> > Hmm - I don't understand?  Looks like we can drop through with other codes?\n> \n> This is nothing - I was just saying that you add the if (OK); instead, you could\n> move the CONNECTION_CLOSED block above the LogTransaction... block and\n> DCHECK_EQ(OK, result)\n\nok\n\n> \n> http://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\n> net/http/http_network_transaction.cc:1065: if (connection_is_proven &&\n> !has_received_headers)\n> On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > On 2010/08/16 22:31:30, vandebo wrote:\n> > > I don't think this captures all of cases that used to, but you've probably\n> > > thought about it more?\n> > \n> > I did spend a lot of time thinking about this.  It was tricky to untangle\n> > exactly what the old code was trying to do.  In particular, there is a case of\n> > ShouldResendFailedRequest where it differentiated \"unused\" vs \"unused_idle\"\n> > sockets, which I didn't think was correct. \n> \n> Sometimes we end up connecting a socket, but not needing it because we reuse\n> another socket first.  So we can end up with a socket that hasn't ever been\n> used, but has sat idle for a long time.  For this purpose, we should treat it as\n> a reused socket because it might have timed out - meaning we should try again\n> with a fresh socket.\n\nI agree.  So, an unused-idle socket should be treated the same as an unused socket.  We've never successfully sent data across it, and a retry should be in order.  I think the new logic preserves that.  Or did I still muck something up?\n\n> http://codereview.chromium.org/3171002/diff/57006/26020#newcode10\n> net/http/http_response_info.h:10: #include \"net/base/ssl_cert_request_info.h\"\n> On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > On 2010/08/16 22:31:30, vandebo wrote:\n> > > Is this change needed?\n> > \n> > I was hoping you didn't notice.  It's some C++ include error I can't figure\n> out.\n> >  I get a template problem with SSLCertRequestInfo being referenced via\n> refptr<>\n> > without it.\n> \n> Man those can be a real PITA. Should probably figure it out though. What context\n> are you getting the error in?\n\nI'm not going to figure it out.  I spent over an hour on it already, and it's not worth it.\n\nIt thinks we're using SSLCertRequestInfo in http_response_info.h. \n\n\n\n> http://codereview.chromium.org/3171002/diff/57006/26021#newcode21\n> net/http/http_stream.h:21: struct HttpRequestInfo;\n> I know it's not you, but this is in the wrong order too.\n\nNo idea what the right order is.  I alphabetized in hopes that it matches the style guide.\n\n> \n> http://codereview.chromium.org/3171002/diff/57006/26023\n> File net/http/http_stream_factory.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/57006/26023#newcode46\n> net/http/http_stream_factory.h:46: // TLS Intolerant Server API\n> On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > On 2010/08/16 22:31:30, vandebo wrote:\n> > > Why are these not exposed in the HttpStream interface?\n> > \n> > I liked them here, because the settings persist longer than the lifetime of\n> the\n> > stream.  However, they could be added to the stream as well; they are generic,\n> > not specific to any particular stream type (http/spdy)\n> \n> Sorry, I meant StreamFactory interface.\n\nOh- that makes more sense.\n\n> \n> http://codereview.chromium.org/3171002/diff/57006/26026\n> File net/http/http_stream_request.cc (right):\n> \n> http://codereview.chromium.org/3171002/diff/57006/26026#newcode78\n> net/http/http_stream_request.cc:78: int HttpStreamRequest::Start(const\n> HttpRequestInfo* request_info,\n> On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > On 2010/08/16 22:31:30, vandebo wrote:\n> > > Looks like this returns a net error code and theoretically could return\n> > > synchronously.\n> > \n> > Yes.\n> \n> Ok, so the comment in StreamFactory should just say that Start returns a net\n> error node, but the delegate will always be called. Hmm.  If that's the case,\n> why return anything at all?\n\nOK\n\n> \n> http://codereview.chromium.org/3171002/diff/57006/26026#newcode213\n> net/http/http_stream_request.cc:213: switch (result) {\n> On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > On 2010/08/16 22:31:30, vandebo wrote:\n> > > If you want to get rid of this switch, you can fold at least the error cases\n> > > into DoInitConnectionComplete.\n> > \n> > I know - I tried this a couple of different ways.  Which do you think is\n> better?\n> \n> Shorter functions are better, but RunLoop is kind of strange with DoLoop as\n> well.  If folding them in would get rid of RunLoop, it might be worth it.\n\nNot all exits from the state machine are guaranteed to come through\nDoInitConnectionComplete, so it's not clearly better.  Since it seems like\na lateral change, I'd to leave as is, and get this landed, and then we can\npolish things like that much more easily. \n\n\n> \n> http://codereview.chromium.org/3171002/diff/57006/26028\n> File net/http/stream_factory.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/57006/26028#newcode5\n> net/http/stream_factory.h:5: #ifndef NET_HTTP_STREAM_FACTORY_H_\n> On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > On 2010/08/16 22:31:30, vandebo wrote:\n> > > Do you have both this interface and the HttpStreamFactory class per my\n> request\n> > > to ease pipelined streams?\n> > \n> > Yes, partially.  Does it meet your needs?\n> \n> Because of the TLSIntolerant and alternate protocol stuff it makes it much less\n> clear if it's a win. The PiplinedHttpStreamFactory should be below that level...\n> If it's not too much trouble, you can get rid of the extra layer and I'll deal\n> with it later.\n\nRight - isn't it really just the StreamRequestJob that you want?\n\n\n> \n> http://codereview.chromium.org/3171002/diff/57006/26028#newcode101\n> net/http/stream_factory.h:101: virtual bool establishing_tunnel() const = 0;\n> On 2010/08/16 22:31:30, vandebo wrote:\n> > Doesn't seem that this interface needs this method.  Either the request is\n> > outstanding and the caller doesn't yet have the stream, or the caller knows\n> and\n> > can keep track of being between OnNeedsProxyAuth() and\n> > RestartTunnelWithProxyAuth().\n> \n> What do you think of killing this method?\n\nOK - it is only used for DCHECKS.  Removed.\n\n\n> http://codereview.chromium.org/3171002/diff/75006/28029#newcode161\n> net/http/http_stream_request.cc:161: const HttpRequestInfo&\n> HttpStreamRequest::request_info() const {\n> Is there are reason for these three accessors to return references instead of\n> just returning the pointers?  It seems that half the time, you end up taking the\n> address of the reference anyway.\n\nThe only purpose is to DCHECK(!cancelled_).  I thought that having pointers which\nbelonged to the caller was dangerous, but by using the accessor consistently (which\nwe do), we can always DCHECK, and if anyone ever introduces a bug, it will pop.\n\n\n\n> http://codereview.chromium.org/3171002/diff/75006/28031#newcode33\n> net/http/stream_factory.h:33: virtual ~StreamRequestDelegate() {};\n> extra ; ?\n\nFixed\n\n> \n> http://codereview.chromium.org/3171002/diff/75006/28031#newcode53\n> net/http/stream_factory.h:53: virtual void OnNeedsProxyAuth(HttpAuthController*\n> auth_controller,\n> how about making this a const scoped_refptr<HttpAuthController>& auth_controller\n\nDone\n\n> \n> http://codereview.chromium.org/3171002/diff/75006/28031#newcode60\n> net/http/stream_factory.h:60: virtual void OnNeedsClientAuth(SSLCertRequestInfo*\n> cert_info) = 0;\n> const scoped_refptr<SSLCertRequestInfo>& cert_info ?\n\nDone\n\n> \n> http://codereview.chromium.org/3171002/diff/75006/28031#newcode95\n> net/http/stream_factory.h:95: virtual int\n> RestartWithCertificate(X509Certificate* client_cert) = 0;\n> const scoped_refptr<X509Certificate>& client_cert ?\n\nDone","disapproval":false,"date":"2010-08-17 19:13:15.064798","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"FYI - I think I have addressed all comments.\n\nThe trybot failures are all bogus; I'm running over and over again, trying to get a clean run, but everything fails for a different reason:\n   - mac - GREEN!\n   - windows, I'm told to clobber- it isn't even compiling after repeated runs (not related to my change)\n   - linux valgrind, some non-x64 link error? (I am getting clean runs on my own machine)\n   - linux - random ui test failures that aren't related to this change.","disapproval":false,"date":"2010-08-17 21:31:41.735769","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"On 2010/08/17 19:13:15, Mike Belshe wrote:\n> > http://codereview.chromium.org/3171002/diff/57006/26016#newcode619\n> > net/http/http_network_transaction.cc:619: if (stream_.get())\n> > On 2010/08/17 00:35:26, Mike Belshe wrote:\n> > > On 2010/08/16 23:24:02, vandebo wrote:\n> > > > What's going on with this change?\n> > >\n> > > [snip]\n> >\n> > Yea, it looks like the only way to get to this state is through\n> > DoInitStreamComplete.\n>\n> ok\n\nSo, stream_.get() should always be true.\n\n> > http://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\n> > net/http/http_network_transaction.cc:1065: if (connection_is_proven &&\n> > !has_received_headers)\n> > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > I don't think this captures all of cases that used to, but you've probably\n> > > > thought about it more?\n> > >\n> > > I did spend a lot of time thinking about this.  It was tricky to untangle\n> > > exactly what the old code was trying to do.  In particular, there is a case\n> of\n> > > ShouldResendFailedRequest where it differentiated \"unused\" vs \"unused_idle\"\n> > > sockets, which I didn't think was correct.\n> >\n> > Sometimes we end up connecting a socket, but not needing it because we reuse\n> > another socket first.  So we can end up with a socket that hasn't ever been\n> > used, but has sat idle for a long time.  For this purpose, we should treat it\n> as\n> > a reused socket because it might have timed out - meaning we should try again\n> > with a fresh socket.\n>\n> I agree.  So, an unused-idle socket should be treated the same as an unused\n> socket.  We've never successfully sent data across it, and a retry should be in\n> order.  I think the new logic preserves that.  Or did I still muck something up?\n\nIn the new logic, an unused idle socket isn't proven, so ShouldResendRequest will return false.  Though, the old logic only returns true for an unused idle socket when the error code is ERR_CONNECTION_RESET.\n\n> > http://codereview.chromium.org/3171002/diff/57006/26020#newcode10\n> > net/http/http_response_info.h:10: #include \"net/base/ssl_cert_request_info.h\"\n> > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > Is this change needed?\n> > >\n> > > I was hoping you didn't notice.  It's some C++ include error I can't figure\n> > out.\n> > >  I get a template problem with SSLCertRequestInfo being referenced via\n> > refptr<>\n> > > without it.\n> >\n> > Man those can be a real PITA. Should probably figure it out though. What\n> context\n> > are you getting the error in?\n\nI think net/http/http_stream_request.cc needs to include net/base/ssl_cert_request_info.h\n\n\n> > http://codereview.chromium.org/3171002/diff/57006/26023\n> > File net/http/http_stream_factory.h (right):\n> >\n> > http://codereview.chromium.org/3171002/diff/57006/26023#newcode46\n> > net/http/http_stream_factory.h:46: // TLS Intolerant Server API\n> > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > Why are these not exposed in the HttpStream interface?\n> > >\n> > > I liked them here, because the settings persist longer than the lifetime of\n> > the\n> > > stream.  However, they could be added to the stream as well; they are\n> generic,\n> > > not specific to any particular stream type (http/spdy)\n> >\n> > Sorry, I meant StreamFactory interface.\n>\n> Oh- that makes more sense.\n\nSo, my question was, why are is the TLS Intolerant Server API, etc not exposed in the StreamFactory interface?\n\n> > http://codereview.chromium.org/3171002/diff/57006/26028\n> > File net/http/stream_factory.h (right):\n> >\n> > http://codereview.chromium.org/3171002/diff/57006/26028#newcode5\n> > net/http/stream_factory.h:5: #ifndef NET_HTTP_STREAM_FACTORY_H_\n> > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > Do you have both this interface and the HttpStreamFactory class per my\n> > request\n> > > > to ease pipelined streams?\n> > >\n> > > Yes, partially.  Does it meet your needs?\n> >\n> > Because of the TLSIntolerant and alternate protocol stuff it makes it much\n> less\n> > clear if it's a win. The PiplinedHttpStreamFactory should be below that\n> level...\n> > If it's not too much trouble, you can get rid of the extra layer and I'll deal\n> > with it later.\n>\n> Right - isn't it really just the StreamRequestJob that you want?\n\nHmm, quite possibly.\n\n> > http://codereview.chromium.org/3171002/diff/75006/28029#newcode161\n> > net/http/http_stream_request.cc:161: const HttpRequestInfo&\n> > HttpStreamRequest::request_info() const {\n> > Is there are reason for these three accessors to return references instead of\n> > just returning the pointers?  It seems that half the time, you end up taking\n> the\n> > address of the reference anyway.\n>\n> The only purpose is to DCHECK(!cancelled_).  I thought that having pointers\n> which\n> belonged to the caller was dangerous, but by using the accessor consistently\n> (which\n> we do), we can always DCHECK, and if anyone ever introduces a bug, it will pop.\n\nSorry, I think you misunderstood my question.  Is there a reason to return ProxyInfo& instead of ProxyInfo* ?\n\nhttp://codereview.chromium.org/3171002/diff/3010/27020\nFile net/http/http_stream_factory.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/3010/27020#newcode59\nnet/http/http_stream_factory.cc:59: return ERR_IO_PENDING;\nWhy not just return void instead of a constant?\n\nhttp://codereview.chromium.org/3171002/diff/3010/27026\nFile net/http/http_stream_request.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/3010/27026#newcode33\nnet/http/http_stream_request.h:33: HttpNetworkSession* session);\nThese two can be a scoped_refptr<>& as well.\n\nhttp://codereview.chromium.org/3171002/diff/3010/27026#newcode43\nnet/http/http_stream_request.h:43: int RestartWithCertificate(const scoped_refptr<X509Certificate> client_cert);\nIf you make these const scoped_refptr<>&'s it'll avoid an atomic ref/deref pair.","disapproval":false,"date":"2010-08-17 22:29:59.944534","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"On 2010/08/17 22:29:59, vandebo wrote:\n> On 2010/08/17 19:13:15, Mike Belshe wrote:\n> > > http://codereview.chromium.org/3171002/diff/57006/26016#newcode619\n> > > net/http/http_network_transaction.cc:619: if (stream_.get())\n> > > On 2010/08/17 00:35:26, Mike Belshe wrote:\n> > > > On 2010/08/16 23:24:02, vandebo wrote:\n> > > > > What's going on with this change?\n> > > >\n> > > > [snip]\n> > >\n> > > Yea, it looks like the only way to get to this state is through\n> > > DoInitStreamComplete.\n> >\n> > ok\n> \n> So, stream_.get() should always be true.\n\nDone.\n\n\n> \n> > > http://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\n> > > net/http/http_network_transaction.cc:1065: if (connection_is_proven &&\n> > > !has_received_headers)\n> > > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > > I don't think this captures all of cases that used to, but you've\n> probably\n> > > > > thought about it more?\n> > > >\n> > > > I did spend a lot of time thinking about this.  It was tricky to untangle\n> > > > exactly what the old code was trying to do.  In particular, there is a\n> case\n> > of\n> > > > ShouldResendFailedRequest where it differentiated \"unused\" vs\n> \"unused_idle\"\n> > > > sockets, which I didn't think was correct.\n> > >\n> > > Sometimes we end up connecting a socket, but not needing it because we reuse\n> > > another socket first.  So we can end up with a socket that hasn't ever been\n> > > used, but has sat idle for a long time.  For this purpose, we should treat\n> it\n> > as\n> > > a reused socket because it might have timed out - meaning we should try\n> again\n> > > with a fresh socket.\n> >\n> > I agree.  So, an unused-idle socket should be treated the same as an unused\n> > socket.  We've never successfully sent data across it, and a retry should be\n> in\n> > order.  I think the new logic preserves that.  Or did I still muck something\n> up?\n> \n> In the new logic, an unused idle socket isn't proven, so ShouldResendRequest\n> will return false.  Though, the old logic only returns true for an unused idle\n> socket when the error code is ERR_CONNECTION_RESET.\n\nOk - thanks for looking through this.  I don't like the notion of exposing \"unused_idle\".  It's a pretty detailed and esoteric state.  In the future, I think we can hide it from the public API of ClientSocketHandle.\n\nI've now modified the HttpStreamParser to return true for IsConnectionReused() if the state is UNUSED_IDLE.  I believe this really what we want - to treat a unused idle as though it's a reused connection.  Even for metrics, it's true - if it has been sitting in the pool for a long time, its as though we got a reused connection rather than having to wait for one.\n\nNotice that the callers of ShouldResendRequest are already checking the error status.  I think this is correct.\n\nThe one last change is that I think we should retry *always* for an unused-idle socket, not just for the ERR_CONNECTION_RESET.  I believe this is a bug in the old code.  For example, imagine you have an unused-idle socket, and the client is sending a request just as the server is timing it out.  We'll get a CONNECTION_RESET, but we want to retry this case (it's just like if we had a resused() connection).\n\n\n\n\n> \n> > > http://codereview.chromium.org/3171002/diff/57006/26020#newcode10\n> > > net/http/http_response_info.h:10: #include\n> \"net/base/ssl_cert_request_info.h\"\n> > > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > > Is this change needed?\n> > > >\n> > > > I was hoping you didn't notice.  It's some C++ include error I can't\n> figure\n> > > out.\n> > > >  I get a template problem with SSLCertRequestInfo being referenced via\n> > > refptr<>\n> > > > without it.\n> > >\n> > > Man those can be a real PITA. Should probably figure it out though. What\n> > context\n> > > are you getting the error in?\n> \n> I think net/http/http_stream_request.cc needs to include\n> net/base/ssl_cert_request_info.h\n\nYou're a genius!\n\n\n> \n> \n> > > http://codereview.chromium.org/3171002/diff/57006/26023\n> > > File net/http/http_stream_factory.h (right):\n> > >\n> > > http://codereview.chromium.org/3171002/diff/57006/26023#newcode46\n> > > net/http/http_stream_factory.h:46: // TLS Intolerant Server API\n> > > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > > Why are these not exposed in the HttpStream interface?\n> > > >\n> > > > I liked them here, because the settings persist longer than the lifetime\n> of\n> > > the\n> > > > stream.  However, they could be added to the stream as well; they are\n> > generic,\n> > > > not specific to any particular stream type (http/spdy)\n> > >\n> > > Sorry, I meant StreamFactory interface.\n> >\n> > Oh- that makes more sense.\n> \n> So, my question was, why are is the TLS Intolerant Server API, etc not exposed\n> in the StreamFactory interface?\n\nDone.\n\n> \n> > > http://codereview.chromium.org/3171002/diff/57006/26028\n> > > File net/http/stream_factory.h (right):\n> > >\n> > > http://codereview.chromium.org/3171002/diff/57006/26028#newcode5\n> > > net/http/stream_factory.h:5: #ifndef NET_HTTP_STREAM_FACTORY_H_\n> > > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > > Do you have both this interface and the HttpStreamFactory class per my\n> > > request\n> > > > > to ease pipelined streams?\n> > > >\n> > > > Yes, partially.  Does it meet your needs?\n> > >\n> > > Because of the TLSIntolerant and alternate protocol stuff it makes it much\n> > less\n> > > clear if it's a win. The PiplinedHttpStreamFactory should be below that\n> > level...\n> > > If it's not too much trouble, you can get rid of the extra layer and I'll\n> deal\n> > > with it later.\n> >\n> > Right - isn't it really just the StreamRequestJob that you want?\n> \n> Hmm, quite possibly.\n> \n> > > http://codereview.chromium.org/3171002/diff/75006/28029#newcode161\n> > > net/http/http_stream_request.cc:161: const HttpRequestInfo&\n> > > HttpStreamRequest::request_info() const {\n> > > Is there are reason for these three accessors to return references instead\n> of\n> > > just returning the pointers?  It seems that half the time, you end up taking\n> > the\n> > > address of the reference anyway.\n> >\n> > The only purpose is to DCHECK(!cancelled_).  I thought that having pointers\n> > which\n> > belonged to the caller was dangerous, but by using the accessor consistently\n> > (which\n> > we do), we can always DCHECK, and if anyone ever introduces a bug, it will\n> pop.\n> \n> Sorry, I think you misunderstood my question.  Is there a reason to return\n> ProxyInfo& instead of ProxyInfo* ?\n\nJust preference, really.\n\nOK - I have now changed proxy_info() and ssl_info() to be pointers, because I think that matches style, since they are non-const.  I left request_info() since it is const.\n\n> \n> http://codereview.chromium.org/3171002/diff/3010/27020\n> File net/http/http_stream_factory.cc (right):\n> \n> http://codereview.chromium.org/3171002/diff/3010/27020#newcode59\n> net/http/http_stream_factory.cc:59: return ERR_IO_PENDING;\n> Why not just return void instead of a constant?\n\nDone.\n\n> \n> http://codereview.chromium.org/3171002/diff/3010/27026\n> File net/http/http_stream_request.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/3010/27026#newcode33\n> net/http/http_stream_request.h:33: HttpNetworkSession* session);\n> These two can be a scoped_refptr<>& as well.\n\nDone\n\n> \n> http://codereview.chromium.org/3171002/diff/3010/27026#newcode43\n> net/http/http_stream_request.h:43: int RestartWithCertificate(const\n> scoped_refptr<X509Certificate> client_cert);\n> If you make these const scoped_refptr<>&'s it'll avoid an atomic ref/deref pair.\n\nOops - Done","disapproval":false,"date":"2010-08-17 23:42:24.510629","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"LGTM except for the one thing below.\n\nOn 2010/08/17 23:42:24, Mike Belshe \n> > > > http://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\n> > > > net/http/http_network_transaction.cc:1065: if (connection_is_proven &&\n> > > > !has_received_headers)\n> > > > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > > > I don't think this captures all of cases that used to, but you've\n> > probably\n> > > > > > thought about it more?\n> > > > >\n> > > > > I did spend a lot of time thinking about this.  It was tricky to\n> untangle\n> > > > > exactly what the old code was trying to do.  In particular, there is a\n> > case\n> > > of\n> > > > > ShouldResendFailedRequest where it differentiated \"unused\" vs\n> > \"unused_idle\"\n> > > > > sockets, which I didn't think was correct.\n> > > >\n> > > > Sometimes we end up connecting a socket, but not needing it because we\n> reuse\n> > > > another socket first.  So we can end up with a socket that hasn't ever\n> been\n> > > > used, but has sat idle for a long time.  For this purpose, we should treat\n> > it\n> > > as\n> > > > a reused socket because it might have timed out - meaning we should try\n> > again\n> > > > with a fresh socket.\n> > >\n> > > I agree.  So, an unused-idle socket should be treated the same as an unused\n> > > socket.  We've never successfully sent data across it, and a retry should be\n> > in\n> > > order.  I think the new logic preserves that.  Or did I still muck something\n> > up?\n> > \n> > In the new logic, an unused idle socket isn't proven, so ShouldResendRequest\n> > will return false.  Though, the old logic only returns true for an unused idle\n> > socket when the error code is ERR_CONNECTION_RESET.\n> \n> Ok - thanks for looking through this.  I don't like the notion of exposing\n> \"unused_idle\".  It's a pretty detailed and esoteric state.  In the future, I\n> think we can hide it from the public API of ClientSocketHandle.\n> \n> I've now modified the HttpStreamParser to return true for IsConnectionReused()\n> if the state is UNUSED_IDLE.  I believe this really what we want - to treat a\n> unused idle as though it's a reused connection.  Even for metrics, it's true -\n> if it has been sitting in the pool for a long time, its as though we got a\n> reused connection rather than having to wait for one.\n\nThis will mess up other things.  For example, jar recently added UMA histograms to\ndetermine how useful preconnect is.  As I recall, it uses IsConnectionReused() to\npick the histogram bucket.  For now, you could readd the original ShouldResendRequest method back to ClientSocketHandle.\n \n> Notice that the callers of ShouldResendRequest are already checking the error\n> status.  I think this is correct.\n> \n> The one last change is that I think we should retry *always* for an unused-idle\n> socket, not just for the ERR_CONNECTION_RESET.  I believe this is a bug in the\n> old code.  For example, imagine you have an unused-idle socket, and the client\n> is sending a request just as the server is timing it out.  We'll get a\n> CONNECTION_RESET, but we want to retry this case (it's just like if we had a\n> resused() connection).\n\nFor the purpose of \"ShouldResendRequest,\" yes, it makes sense to interpret it this way.","disapproval":false,"date":"2010-08-18 07:22:20.451336","approval":true},{"sender":"cbentzel@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"I like this change. I'm sorry if I duplicated any previous comments.\n\nhttp://codereview.chromium.org/3171002/diff/70013/6047\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/70013/6047#newcode241\nnet/http/http_network_transaction.cc:241: if (target == HttpAuth::AUTH_PROXY && establishing_tunnel_) {\nIs establishing_tunnel_ needed? Would non-NULL stream_request_ be sufficient here?\n\nhttp://codereview.chromium.org/3171002/diff/70013/6047#newcode623\nnet/http/http_network_transaction.cc:623: DCHECK(stream_.get());\nThe stream_.get() seems a little disconnected here. Should this be done at DoInitStreamComplete time instead?\n\nhttp://codereview.chromium.org/3171002/diff/70013/6052\nFile net/http/http_stream_factory.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/70013/6052#newcode15\nnet/http/http_stream_factory.cc:15: #include \"net/spdy/spdy_http_stream.h\"\nNone of the net/spdy includes look necessary. Perhaps some of the other includes could also be purged.\n\nhttp://codereview.chromium.org/3171002/diff/70013/6054\nFile net/http/http_stream_handle.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/70013/6054#newcode1\nnet/http/http_stream_handle.h:1: // Copyright (c) 2009 The Chromium Authors. All rights reserved.\nNit: 2010\n\nhttp://codereview.chromium.org/3171002/diff/70013/6054#newcode19\nnet/http/http_stream_handle.h:19: // underlying ClientSocketHandle manually.\nIt doesn't seem like this class buys much over just having a scoped_ptr<ClientSocketHandle> and scoped_ptr<HttpStream> at the same location, but I'm assuming that you added it to simplify/dedup logic.\n\nhttp://codereview.chromium.org/3171002/diff/70013/6057\nFile net/http/http_stream_request.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/70013/6057#newcode102\nnet/http/http_stream_request.cc:102: void HttpStreamRequest::Cancel() {\nShould delegate_ be null'ed out in this case? For example, it's called in the HttpNetworkTransaction's destructor. It's preferable to get a segfault in that case than touching arbitrary memory.\n\nhttp://codereview.chromium.org/3171002/diff/70013/6057#newcode180\nnet/http/http_stream_request.cc:180: void HttpStreamRequest::OnStreamReadyCallback(HttpStreamHandle* stream) {\nThese callbacks should guard for the case that the HttpStreamRequest was cancelled between when RunLoop was called and the IO thread processes the task associated with this callback.\n\nhttp://codereview.chromium.org/3171002/diff/70013/6057#newcode349\nnet/http/http_stream_request.cc:349: DCHECK_LE(HttpAlternateProtocols::NPN_SPDY_1, alternate.protocol);\nShould you be trying to use the alternate procotol in NPN_SPDY_1 case? We'll do the PAC lookup for https, and then just do a standard http request.\n\nhttp://codereview.chromium.org/3171002/diff/70013/6057#newcode376\nnet/http/http_stream_request.cc:376: \nI don't think we were doing this in the old code, but it might be worth retrying ResolveProxy with a non-alternate-endpoint-url_ if there was an error or an unsupported proxy scheme is found (as well as marking broken alternate protocol). I'm fine with leaving it as a TODO here.\n\nhttp://codereview.chromium.org/3171002/diff/70013/6057#newcode581\nnet/http/http_stream_request.cc:581: // complete the auth.  The tunnel restart code is carefully to remove it\nNit: s/carefully/careful\n\nhttp://codereview.chromium.org/3171002/diff/70013/6058\nFile net/http/http_stream_request.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/70013/6058#newcode33\nnet/http/http_stream_request.h:33: scoped_refptr<HttpNetworkSession>& session);\nsession should be const-ref here (it's just used as argument for session_'s copy constructor)\n\nhttp://codereview.chromium.org/3171002/diff/70013/6058#newcode37\nnet/http/http_stream_request.h:37: void Start(const HttpRequestInfo* request_info,\nNit: not necessary, but maybe prefix with virtual here to help indicate that these are part of the interface?\n\nhttp://codereview.chromium.org/3171002/diff/70013/6058#newcode65\nnet/http/http_stream_request.h:65: enum State {\nNit: move State above request_info() etc.,\n\nhttp://codereview.chromium.org/3171002/diff/70013/6058#newcode147\nnet/http/http_stream_request.h:147: scoped_refptr<HttpStreamFactory> factory_;\nQuestion: will this be a circular reference?\n\nhttp://codereview.chromium.org/3171002/diff/70013/6059\nFile net/http/stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/70013/6059#newcode70\nnet/http/stream_factory.h:70: class StreamRequestJob : public base::RefCounted<StreamRequestJob> {\nDo the RequestJob's need to be refcounted? It appears that there will only be one owner at a time (the HttpNetworkTransaction which generates it). Destroying it at the same time as the HttpNetworkTransaction is destroyed would remove the need for any cancelled_ logic in HttpStreamRequest.","disapproval":false,"date":"2010-08-18 17:23:57.968506","approval":false},{"sender":"cbentzel@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Also, I'm hoping in the future that some of the http_network_transaction_unittest's can be migrated over to http_stream_request_unittest, but I think you made the correct call in retaining all existing unit tests.","disapproval":false,"date":"2010-08-18 17:28:50.539963","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"On 2010/08/18 07:22:20, vandebo wrote:\n> LGTM except for the one thing below.\n> \n> On 2010/08/17 23:42:24, Mike Belshe \n> > > > > http://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\n> > > > > net/http/http_network_transaction.cc:1065: if (connection_is_proven &&\n> > > > > !has_received_headers)\n> > > > > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > > > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > > > > I don't think this captures all of cases that used to, but you've\n> > > probably\n> > > > > > > thought about it more?\n> > > > > >\n> > > > > > I did spend a lot of time thinking about this.  It was tricky to\n> > untangle\n> > > > > > exactly what the old code was trying to do.  In particular, there is a\n> > > case\n> > > > of\n> > > > > > ShouldResendFailedRequest where it differentiated \"unused\" vs\n> > > \"unused_idle\"\n> > > > > > sockets, which I didn't think was correct.\n> > > > >\n> > > > > Sometimes we end up connecting a socket, but not needing it because we\n> > reuse\n> > > > > another socket first.  So we can end up with a socket that hasn't ever\n> > been\n> > > > > used, but has sat idle for a long time.  For this purpose, we should\n> treat\n> > > it\n> > > > as\n> > > > > a reused socket because it might have timed out - meaning we should try\n> > > again\n> > > > > with a fresh socket.\n> > > >\n> > > > I agree.  So, an unused-idle socket should be treated the same as an\n> unused\n> > > > socket.  We've never successfully sent data across it, and a retry should\n> be\n> > > in\n> > > > order.  I think the new logic preserves that.  Or did I still muck\n> something\n> > > up?\n> > > \n> > > In the new logic, an unused idle socket isn't proven, so ShouldResendRequest\n> > > will return false.  Though, the old logic only returns true for an unused\n> idle\n> > > socket when the error code is ERR_CONNECTION_RESET.\n> > \n> > Ok - thanks for looking through this.  I don't like the notion of exposing\n> > \"unused_idle\".  It's a pretty detailed and esoteric state.  In the future, I\n> > think we can hide it from the public API of ClientSocketHandle.\n> > \n> > I've now modified the HttpStreamParser to return true for IsConnectionReused()\n> > if the state is UNUSED_IDLE.  I believe this really what we want - to treat a\n> > unused idle as though it's a reused connection.  Even for metrics, it's true -\n> > if it has been sitting in the pool for a long time, its as though we got a\n> > reused connection rather than having to wait for one.\n> \n> This will mess up other things.  For example, jar recently added UMA histograms\n> to\n> determine how useful preconnect is.  As I recall, it uses IsConnectionReused()\n> to\n> pick the histogram bucket.  For now, you could readd the original\n> ShouldResendRequest method back to ClientSocketHandle.\n\nJim's tapping in at the ClientSocketHandle layer, which I didn't change.  I spoke to him about it, and this information was new to him - he's already considering adding more metrics on the ClientSocket (not the handle) so that he can track when he caused the connection directly.  That is the information he's really after - idleness is an indicator but never 100% accurate for his purpose.\n\n>  \n> > Notice that the callers of ShouldResendRequest are already checking the error\n> > status.  I think this is correct.\n> > \n> > The one last change is that I think we should retry *always* for an\n> unused-idle\n> > socket, not just for the ERR_CONNECTION_RESET.  I believe this is a bug in the\n> > old code.  For example, imagine you have an unused-idle socket, and the client\n> > is sending a request just as the server is timing it out.  We'll get a\n> > CONNECTION_RESET, but we want to retry this case (it's just like if we had a\n> > resused() connection).\n> \n> For the purpose of \"ShouldResendRequest,\" yes, it makes sense to interpret it\n> this way.\n\nWell, thats good.  I hope we can revisit these APIs and simplify them globally in the future.","disapproval":false,"date":"2010-08-18 18:16:38.298140","approval":false},{"sender":"vandebo@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"On 2010/08/18 18:16:38, Mike Belshe wrote:\n> On 2010/08/18 07:22:20, vandebo wrote:\n> > LGTM except for the one thing below.\n> > \n> > On 2010/08/17 23:42:24, Mike Belshe \n> > > > > > http://codereview.chromium.org/3171002/diff/57006/26016#newcode1065\n> > > > > > net/http/http_network_transaction.cc:1065: if (connection_is_proven &&\n> > > > > > !has_received_headers)\n> > > > > > On 2010/08/16 23:55:11, Mike Belshe wrote:\n> > > > > > > On 2010/08/16 22:31:30, vandebo wrote:\n> > > > > > > > I don't think this captures all of cases that used to, but you've\n> > > > probably\n> > > > > > > > thought about it more?\n> > > > > > >\n> > > > > > > I did spend a lot of time thinking about this.  It was tricky to\n> > > untangle\n> > > > > > > exactly what the old code was trying to do.  In particular, there is\n> a\n> > > > case\n> > > > > of\n> > > > > > > ShouldResendFailedRequest where it differentiated \"unused\" vs\n> > > > \"unused_idle\"\n> > > > > > > sockets, which I didn't think was correct.\n> > > > > >\n> > > > > > Sometimes we end up connecting a socket, but not needing it because we\n> > > reuse\n> > > > > > another socket first.  So we can end up with a socket that hasn't ever\n> > > been\n> > > > > > used, but has sat idle for a long time.  For this purpose, we should\n> > treat\n> > > > it\n> > > > > as\n> > > > > > a reused socket because it might have timed out - meaning we should\n> try\n> > > > again\n> > > > > > with a fresh socket.\n> > > > >\n> > > > > I agree.  So, an unused-idle socket should be treated the same as an\n> > unused\n> > > > > socket.  We've never successfully sent data across it, and a retry\n> should\n> > be\n> > > > in\n> > > > > order.  I think the new logic preserves that.  Or did I still muck\n> > something\n> > > > up?\n> > > > \n> > > > In the new logic, an unused idle socket isn't proven, so\n> ShouldResendRequest\n> > > > will return false.  Though, the old logic only returns true for an unused\n> > idle\n> > > > socket when the error code is ERR_CONNECTION_RESET.\n> > > \n> > > Ok - thanks for looking through this.  I don't like the notion of exposing\n> > > \"unused_idle\".  It's a pretty detailed and esoteric state.  In the future, I\n> > > think we can hide it from the public API of ClientSocketHandle.\n> > > \n> > > I've now modified the HttpStreamParser to return true for\n> IsConnectionReused()\n> > > if the state is UNUSED_IDLE.  I believe this really what we want - to treat\n> a\n> > > unused idle as though it's a reused connection.  Even for metrics, it's true\n> -\n> > > if it has been sitting in the pool for a long time, its as though we got a\n> > > reused connection rather than having to wait for one.\n> > \n> > This will mess up other things.  For example, jar recently added UMA\n> histograms\n> > to\n> > determine how useful preconnect is.  As I recall, it uses IsConnectionReused()\n> > to\n> > pick the histogram bucket.  For now, you could readd the original\n> > ShouldResendRequest method back to ClientSocketHandle.\n> \n> Jim's tapping in at the ClientSocketHandle layer, which I didn't change.  I\n> spoke to him about it, and this information was new to him - he's already\n> considering adding more metrics on the ClientSocket (not the handle) so that he\n> can track when he caused the connection directly.  That is the information he's\n> really after - idleness is an indicator but never 100% accurate for his purpose.\n\nOk, bad example.  It looks like it will affect a couple of the metrics in LogTransactionConnectedMetrics.  reused_socket_ gets set from this method.","disapproval":false,"date":"2010-08-18 18:23:50.451494","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"On 2010/08/18 17:23:57, cbentzel wrote:\n> I like this change. I'm sorry if I duplicated any previous comments.\n\nThanks for making the time to look!\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6047\n> File net/http/http_network_transaction.cc (right):\n> \n> http://codereview.chromium.org/3171002/diff/70013/6047#newcode241\n> net/http/http_network_transaction.cc:241: if (target == HttpAuth::AUTH_PROXY &&\n> establishing_tunnel_) {\n> Is establishing_tunnel_ needed? Would non-NULL stream_request_ be sufficient\n> here?\n\nIt would, but I think it is a lot more subtle.  I like tracking the bool for establishing_tunnel_ just for code readability.  Is that ok?\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6047#newcode623\n> net/http/http_network_transaction.cc:623: DCHECK(stream_.get());\n> The stream_.get() seems a little disconnected here. Should this be done at\n> DoInitStreamComplete time instead?\n\nGood suggestion.  Done.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6052\n> File net/http/http_stream_factory.cc (right):\n> \n> http://codereview.chromium.org/3171002/diff/70013/6052#newcode15\n> net/http/http_stream_factory.cc:15: #include \"net/spdy/spdy_http_stream.h\"\n> None of the net/spdy includes look necessary. Perhaps some of the other includes\n> could also be purged.\n\nThanks - pruned.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6054\n> File net/http/http_stream_handle.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/70013/6054#newcode1\n> net/http/http_stream_handle.h:1: // Copyright (c) 2009 The Chromium Authors. All\n> rights reserved.\n> Nit: 2010\n\nDone.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6054#newcode19\n> net/http/http_stream_handle.h:19: // underlying ClientSocketHandle manually.\n> It doesn't seem like this class buys much over just having a\n> scoped_ptr<ClientSocketHandle> and scoped_ptr<HttpStream> at the same location,\n> but I'm assuming that you added it to simplify/dedup logic.\n> \n\nYeah - I spent a lot of time on this.  I'm trying to keep the HttpNetworkTransaction free of the ClientSocketHandle.  But the stream itself can't contain the ClientSocketHandle, because doing so breaks how our HttpProxyClientSocket works.\n\nAn alternate approach would be to let the HttpStream own the ClientSocketHandle, and then provide a method on the HttpStream such as ReleaseStream(), which would rip the ClientSocketHandle away from the stream.\n\nI didn't like either approach. :-(\n\n\n> http://codereview.chromium.org/3171002/diff/70013/6057\n> File net/http/http_stream_request.cc (right):\n> \n> http://codereview.chromium.org/3171002/diff/70013/6057#newcode102\n> net/http/http_stream_request.cc:102: void HttpStreamRequest::Cancel() {\n> Should delegate_ be null'ed out in this case? For example, it's called in the\n> HttpNetworkTransaction's destructor. It's preferable to get a segfault in that\n> case than touching arbitrary memory.\n\nYes - thanks!\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6057#newcode180\n> net/http/http_stream_request.cc:180: void\n> HttpStreamRequest::OnStreamReadyCallback(HttpStreamHandle* stream) {\n> These callbacks should guard for the case that the HttpStreamRequest was\n> cancelled between when RunLoop was called and the IO thread processes the task\n> associated with this callback.\n\nOh excellent - I love you Chris!!!  You just caught what would have been a top crasher.  I've fixed and added a test case which traps it (see HttpNetworkTransaction.SimpleCancel)\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6057#newcode349\n> net/http/http_stream_request.cc:349:\n> DCHECK_LE(HttpAlternateProtocols::NPN_SPDY_1, alternate.protocol);\n> Should you be trying to use the alternate procotol in NPN_SPDY_1 case? We'll do\n> the PAC lookup for https, and then just do a standard http request.\n\nThis DCHECK just verifies that the number is within the right range.  But your question is good - are we restricting AlternateProtocol to just spdy/2?  I think you're right, the switch from spdy/1 to spdy/2 did *not* properly update the AlternateProtocol handling.\n\nI'm modifying HttpStreamFactory::ProcessAlternateProtocol to only work with NPN_SPDY_V2.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6057#newcode376\n> net/http/http_stream_request.cc:376: \n> I don't think we were doing this in the old code, but it might be worth retrying\n> ResolveProxy with a non-alternate-endpoint-url_ if there was an error or an\n> unsupported proxy scheme is found (as well as marking broken alternate\n> protocol). I'm fine with leaving it as a TODO here.\n\nAdded a TODO.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6057#newcode581\n> net/http/http_stream_request.cc:581: // complete the auth.  The tunnel restart\n> code is carefully to remove it\n> Nit: s/carefully/careful\n\nDone\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6058\n> File net/http/http_stream_request.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/70013/6058#newcode33\n> net/http/http_stream_request.h:33: scoped_refptr<HttpNetworkSession>& session);\n> session should be const-ref here (it's just used as argument for session_'s copy\n> constructor)\n\nGood catch.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6058#newcode37\n> net/http/http_stream_request.h:37: void Start(const HttpRequestInfo*\n> request_info,\n> Nit: not necessary, but maybe prefix with virtual here to help indicate that\n> these are part of the interface?\n\nDone.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6058#newcode65\n> net/http/http_stream_request.h:65: enum State {\n> Nit: move State above request_info() etc.,\n\nDone\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6058#newcode147\n> net/http/http_stream_request.h:147: scoped_refptr<HttpStreamFactory> factory_;\n> Question: will this be a circular reference?\n\nNope- the factory does not have references to the StreamRequests.\n\n> \n> http://codereview.chromium.org/3171002/diff/70013/6059\n> File net/http/stream_factory.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/70013/6059#newcode70\n> net/http/stream_factory.h:70: class StreamRequestJob : public\n> base::RefCounted<StreamRequestJob> {\n> Do the RequestJob's need to be refcounted? It appears that there will only be\n> one owner at a time (the HttpNetworkTransaction which generates it). Destroying\n> it at the same time as the HttpNetworkTransaction is destroyed would remove the\n> need for any cancelled_ logic in HttpStreamRequest.\n\nYou're right, it only has one owner, but the RequestJob has callbacks from IOs and such which are ongoing.  It's nice to be able to cleanup the transaction asynchronously from that.","disapproval":false,"date":"2010-08-18 19:08:49.124182","approval":false},{"sender":"cbentzel@chromium.org","recipients":["reply@chromiumcodereview.appspotmail.com"],"text":"LGTM\n\nOn Wed, Aug 18, 2010 at 3:08 PM, <mbelshe@chromium.org> wrote:\n\n>\n>>\n>> Is establishing_tunnel_ needed? Would non-NULL stream_request_ be\n>> sufficient\n>> here?\n>>\n>\n> It would, but I think it is a lot more subtle.  I like tracking the bool\n> for\n> establishing_tunnel_ just for code readability.  Is that ok?\n\n\nYes.\n\n\n>\n> Oh excellent - I love you Chris!!!  You just caught what would have been a\n> top\n> crasher.  I've fixed and added a test case which traps it (see\n> HttpNetworkTransaction.SimpleCancel)\n\n\nThanks for adding the test (and the love)\n\n>\n>\n>\n>  http://codereview.chromium.org/3171002/diff/70013/6057#newcode349\n>> net/http/http_stream_request.cc:349:\n>> DCHECK_LE(HttpAlternateProtocols::NPN_SPDY_1, alternate.protocol);\n>> Should you be trying to use the alternate procotol in NPN_SPDY_1 case?\n>> We'll\n>>\n> do\n>\n>> the PAC lookup for https, and then just do a standard http request.\n>>\n>\n> This DCHECK just verifies that the number is within the right range.  But\n> your\n> question is good - are we restricting AlternateProtocol to just spdy/2?  I\n> think\n> you're right, the switch from spdy/1 to spdy/2 did *not* properly update\n> the\n> AlternateProtocol handling.\n>\n> I'm modifying HttpStreamFactory::ProcessAlternateProtocol to only work with\n> NPN_SPDY_V2.\n\n\nDo you want to do this in another CL for the pre-refactored code?\n","disapproval":false,"date":"2010-08-18 20:20:42.032069","approval":true},{"sender":"eroman@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Some preliminary nits before I dive into the details:\n\nhttp://codereview.chromium.org/3171002/diff/71044/79013\nFile net/http/http_network_session.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79013#newcode65\nnet/http/http_network_session.cc:65: ALLOW_THIS_IN_INITIALIZER_LIST(\nwhere is |this| used?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79014\nFile net/http/http_network_session.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79014#newcode105\nnet/http/http_network_session.h:105: const scoped_refptr<HttpStreamFactory>& http_stream_factory() {\ndoes this have to be refcounted?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79016\nFile net/http/http_network_transaction.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79016#newcode67\nnet/http/http_network_transaction.h:67: const scoped_refptr<HttpAuthController> auth_controller,\ncan you make this a const _reference_ ?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79016#newcode70\nnet/http/http_network_transaction.h:70: const scoped_refptr<SSLCertRequestInfo> cert_info);\ncan you make this a const _reference_ ?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021\nFile net/http/http_stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021#newcode42\nnet/http/http_stream_factory.h:42: scoped_refptr<HttpNetworkSession>& session,\nplease don't use a non-const reference. If this needs to be mutated make it a pointer instead.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021#newcode51\nnet/http/http_stream_factory.h:51: const std::string alternate_protocol_str,\nreference.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021#newcode55\nnet/http/http_stream_factory.h:55: GURL ApplyHostMappingRules(const GURL& url, HostPortPair& endpoint);\nplease dont use non-const references.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79026\nFile net/http/http_stream_request.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79026#newcode86\nnet/http/http_stream_request.h:86: const scoped_refptr<HttpAuthController> auth_controller,\nreference?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79026#newcode89\nnet/http/http_stream_request.h:89: const scoped_refptr<SSLCertRequestInfo> cert_info);\nreference?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027\nFile net/http/stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode15\nnet/http/stream_factory.h:15: struct HttpRequestInfo;\nnit: order\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode57\nnet/http/stream_factory.h:57: const scoped_refptr<HttpAuthController> auth_controller,\nreference?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode65\nnet/http/stream_factory.h:65: const scoped_refptr<SSLCertRequestInfo> cert_info) = 0;\nreference?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode115\nnet/http/stream_factory.h:115: virtual bool was_alternate_protocol_available() const = 0;\nWe should only use_hacker_notation() for accessors. A virtual method is not an accessor so ShouldUseCamelCase().","disapproval":false,"date":"2010-08-18 22:41:15.572249","approval":false},{"sender":"eroman@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/71044/79014\nFile net/http/http_network_session.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79014#newcode105\nnet/http/http_network_session.h:105: const scoped_refptr<HttpStreamFactory>& http_stream_factory() {\nOn 2010/08/18 22:41:15, eroman wrote:\n> does this have to be refcounted?\n\nActually this comment was a note to myself, so don't answer it.","disapproval":false,"date":"2010-08-18 22:42:24.873675","approval":false},{"sender":"mbelshe@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/71044/79013\nFile net/http/http_network_session.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79013#newcode65\nnet/http/http_network_session.cc:65: ALLOW_THIS_IN_INITIALIZER_LIST(\nOn 2010/08/18 22:41:15, eroman wrote:\n> where is |this| used?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79016\nFile net/http/http_network_transaction.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79016#newcode67\nnet/http/http_network_transaction.h:67: const scoped_refptr<HttpAuthController> auth_controller,\nOn 2010/08/18 22:41:15, eroman wrote:\n> can you make this a const _reference_ ?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79016#newcode70\nnet/http/http_network_transaction.h:70: const scoped_refptr<SSLCertRequestInfo> cert_info);\nOn 2010/08/18 22:41:15, eroman wrote:\n> can you make this a const _reference_ ?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021\nFile net/http/http_stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021#newcode42\nnet/http/http_stream_factory.h:42: scoped_refptr<HttpNetworkSession>& session,\nOn 2010/08/18 22:41:15, eroman wrote:\n> please don't use a non-const reference. If this needs to be mutated make it a\n> pointer instead.\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021#newcode51\nnet/http/http_stream_factory.h:51: const std::string alternate_protocol_str,\nOn 2010/08/18 22:41:15, eroman wrote:\n> reference.\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79021#newcode55\nnet/http/http_stream_factory.h:55: GURL ApplyHostMappingRules(const GURL& url, HostPortPair& endpoint);\nOn 2010/08/18 22:41:15, eroman wrote:\n> please dont use non-const references.\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79026\nFile net/http/http_stream_request.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79026#newcode86\nnet/http/http_stream_request.h:86: const scoped_refptr<HttpAuthController> auth_controller,\nOn 2010/08/18 22:41:15, eroman wrote:\n> reference?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79026#newcode89\nnet/http/http_stream_request.h:89: const scoped_refptr<SSLCertRequestInfo> cert_info);\nOn 2010/08/18 22:41:15, eroman wrote:\n> reference?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027\nFile net/http/stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode15\nnet/http/stream_factory.h:15: struct HttpRequestInfo;\nOn 2010/08/18 22:41:15, eroman wrote:\n> nit: order\n\nWhat order do you want?  I did structs first, then classes; each alphabetic...  Style guide doesn't seem to care?\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode57\nnet/http/stream_factory.h:57: const scoped_refptr<HttpAuthController> auth_controller,\nOn 2010/08/18 22:41:15, eroman wrote:\n> reference?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode65\nnet/http/stream_factory.h:65: const scoped_refptr<SSLCertRequestInfo> cert_info) = 0;\nOn 2010/08/18 22:41:15, eroman wrote:\n> reference?\n\nDone.\n\nhttp://codereview.chromium.org/3171002/diff/71044/79027#newcode115\nnet/http/stream_factory.h:115: virtual bool was_alternate_protocol_available() const = 0;\nOn 2010/08/18 22:41:15, eroman wrote:\n> We should only use_hacker_notation() for accessors. A virtual method is not an\n> accessor so ShouldUseCamelCase().\n\nSo interfaces can't have accessors?","disapproval":false,"date":"2010-08-18 23:44:39.575564","approval":false},{"sender":"timurrrr@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","timurrrr@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"Hi Mike,\nthis CL has introduced a crash on TSan/Win bot:\nhttp://build.chromium.org/buildbot/memory/builders/Windows%20Tests%20(tsan)/builds/1717/steps/memory%20test:%20net/logs/stdio\n[ RUN      ] HttpNetworkTransactionTest.UseAlternateProtocolForNpnSpdyWithExistingSpdySession\n[3952:868:0819/001717:1208032157:FATAL:net/socket/socket_test_util.h(441)] Check failed: next_index_ < data_providers_.size() (2 vs. 2)\nBacktrace:\n\tStackTrace::StackTrace [0x00DF3058+16] (c:\\b\\slave\\chromium-dbg-win-tsan\\build\\src\\base\\debug_util_win.cc:230)\n\tnet::SocketDataProviderArray<net::SocketDataProvider>::GetNext [0x00E1C50C+101] (c:\\b\\slave\\chromium-dbg-win-tsan\\build\\src\\net\\socket\\socket_test_util.h:442)\n\tnet::MockClientSocketFactory::CreateTCPClientSocket [0x00E1C624+15] (c:\\b\\slave\\chromium-dbg-win-tsan\\build\\src\\net\\socket\\socket_test_util.cc:905)\n\tnet::TCPConnectJob::DoTCPConnect [0x00E58CEA+44] (c:\\b\\slave\\chromium-dbg-win-tsan\\build\\src\\net\\socket\\tcp_client_socket_pool.cc:146)\n\t_free_dbg [0x00EFF456+102] (f:\\dd\\vctools\\crt_bld\\self_x86\\crt\\src\\dbgheap.c:1225)\n\nOn 2010/08/18 23:44:39, Mike Belshe wrote:\n> http://codereview.chromium.org/3171002/diff/71044/79013\n> File net/http/http_network_session.cc (right):\n> \n> http://codereview.chromium.org/3171002/diff/71044/79013#newcode65\n> net/http/http_network_session.cc:65: ALLOW_THIS_IN_INITIALIZER_LIST(\n> On 2010/08/18 22:41:15, eroman wrote:\n> > where is |this| used?\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79016\n> File net/http/http_network_transaction.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/71044/79016#newcode67\n> net/http/http_network_transaction.h:67: const scoped_refptr<HttpAuthController>\n> auth_controller,\n> On 2010/08/18 22:41:15, eroman wrote:\n> > can you make this a const _reference_ ?\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79016#newcode70\n> net/http/http_network_transaction.h:70: const scoped_refptr<SSLCertRequestInfo>\n> cert_info);\n> On 2010/08/18 22:41:15, eroman wrote:\n> > can you make this a const _reference_ ?\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79021\n> File net/http/http_stream_factory.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/71044/79021#newcode42\n> net/http/http_stream_factory.h:42: scoped_refptr<HttpNetworkSession>& session,\n> On 2010/08/18 22:41:15, eroman wrote:\n> > please don't use a non-const reference. If this needs to be mutated make it a\n> > pointer instead.\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79021#newcode51\n> net/http/http_stream_factory.h:51: const std::string alternate_protocol_str,\n> On 2010/08/18 22:41:15, eroman wrote:\n> > reference.\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79021#newcode55\n> net/http/http_stream_factory.h:55: GURL ApplyHostMappingRules(const GURL& url,\n> HostPortPair& endpoint);\n> On 2010/08/18 22:41:15, eroman wrote:\n> > please dont use non-const references.\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79026\n> File net/http/http_stream_request.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/71044/79026#newcode86\n> net/http/http_stream_request.h:86: const scoped_refptr<HttpAuthController>\n> auth_controller,\n> On 2010/08/18 22:41:15, eroman wrote:\n> > reference?\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79026#newcode89\n> net/http/http_stream_request.h:89: const scoped_refptr<SSLCertRequestInfo>\n> cert_info);\n> On 2010/08/18 22:41:15, eroman wrote:\n> > reference?\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79027\n> File net/http/stream_factory.h (right):\n> \n> http://codereview.chromium.org/3171002/diff/71044/79027#newcode15\n> net/http/stream_factory.h:15: struct HttpRequestInfo;\n> On 2010/08/18 22:41:15, eroman wrote:\n> > nit: order\n> \n> What order do you want?  I did structs first, then classes; each alphabetic... \n> Style guide doesn't seem to care?\n> \n> http://codereview.chromium.org/3171002/diff/71044/79027#newcode57\n> net/http/stream_factory.h:57: const scoped_refptr<HttpAuthController>\n> auth_controller,\n> On 2010/08/18 22:41:15, eroman wrote:\n> > reference?\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79027#newcode65\n> net/http/stream_factory.h:65: const scoped_refptr<SSLCertRequestInfo> cert_info)\n> = 0;\n> On 2010/08/18 22:41:15, eroman wrote:\n> > reference?\n> \n> Done.\n> \n> http://codereview.chromium.org/3171002/diff/71044/79027#newcode115\n> net/http/stream_factory.h:115: virtual bool was_alternate_protocol_available()\n> const = 0;\n> On 2010/08/18 22:41:15, eroman wrote:\n> > We should only use_hacker_notation() for accessors. A virtual method is not an\n> > accessor so ShouldUseCamelCase().\n> \n> So interfaces can't have accessors?","disapproval":false,"date":"2010-08-19 08:39:23.156765","approval":false},{"sender":"eroman@chromium.org","recipients":["mbelshe@chromium.org","vandebo@chromium.org","erikchen@google.com","rch@chromium.org","wtc@chromium.org","eroman@chromium.org","gavinp@google.com","cbentzel@chromium.org","timurrrr@chromium.org","chromium-reviews@chromium.org","cbentzel+watch@chromium.org","darin-cc@chromium.org","phajdan.jr@chromium.org"],"text":"http://codereview.chromium.org/3171002/diff/20039/10022\nFile net/http/http_network_transaction.cc (right):\n\nhttp://codereview.chromium.org/3171002/diff/20039/10022#newcode317\nnet/http/http_network_transaction.cc:317: if (headers_valid_ && headers.get() && stream_request_.get()) {\nI don't understand how establishing_tunnel_ has been translated to stream_request_.get()\n\nhttp://codereview.chromium.org/3171002/diff/20039/10022#newcode429\nnet/http/http_network_transaction.cc:429: establishing_tunnel_ = true;\nI don't understand the changes you have made around establishing_tunnel_. This is the only place where establishing_tunnel_ is now being set to true, but why would OnNeedsProxyAuth() imply we are establishing a tunnel?\n\nAFAICT in the context of this file \"establishing_tunnel_\" meant we were calling the CONNECT method on an HTTP proxy, which will happen when you are trying to use non-HTTP over an HTTP proxy (i.e. for an https:// request).\n\nhttp://codereview.chromium.org/3171002/diff/20039/10028\nFile net/http/http_stream_factory.h (right):\n\nhttp://codereview.chromium.org/3171002/diff/20039/10028#newcode10\nnet/http/http_stream_factory.h:10: \nnit: most other files only separate by 1 newline\n\nhttp://codereview.chromium.org/3171002/diff/20039/10028#newcode21\nnet/http/http_stream_factory.h:21: \nditto.\n\nhttp://codereview.chromium.org/3171002/diff/20039/10028#newcode100\nnet/http/http_stream_factory.h:100: static const HostMappingRules* host_mapping_rules_;\nhmm. aren't these going to be leaked on exit?\n\nI am very wary of having globals. My hope for the network module was that it be embeddable by other applications, and runnable from multiple threads (even though most classes are not thread safe, if all of the globals are encapsulated in the URLRequestContext you can still run separate contexts on separate threads).","disapproval":false,"date":"2010-08-19 19:15:47.030495","approval":false}],"owner_email":"mbelshe@chromium.org","private":false,"base_url":"svn://chrome-svn/chrome/trunk/src/","owner":"Mike Belshe","subject":"Extract connection logic from HttpNetworkTransaction into a new...","created":"2010-08-10 19:01:34.155771","patchsets":[1,20001,3002,48001,55001,64001,23028,1025,6032,34007,47004,27,50005,57006,39010,67003,19008,40004,14008,82002,7039,20035,75006,57010,87001,3010,70013,8007,46013,71044,43010,20039],"modified":"2011-07-01 18:31:33.547492","closed":true,"commit":false,"issue":3171002}