{"files":{"webkit/appcache/mock_appcache_storage.h":{"status":"M    ","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":5,"num_removed":0,"messages":[],"id":4004,"is_binary":false},"webkit/appcache/appcache_update_job.cc":{"status":"M    ","num_chunks":16,"no_base_file":false,"property_changes":"","num_added":210,"num_removed":59,"messages":[{"author":"michaeln","author_email":"michaeln@chromium.org","text":"nit: Setup... but i see both SetUp and Setup in use in the code base","draft":false,"lineno":40,"date":"2009-10-28 21:19:52.363660","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"its much more common to define storage for CallbackImpls inline rather than heap allocate them...\n\nclass UpdateJobInfo {\n  UpdateJobInfo() \n      : bar_(0),\n        ALLOW_THIS_IN_INITIALIZER_LIST(\n            write_callback_(this, &UpdateJobInfo::OnWriteComplete)) {\n  }\n\n  int bar_;\n  net::CompletionCallbackImpl<UpdateJobInfo> write_callback_;\n};\n\n","draft":false,"lineno":49,"date":"2009-10-28 21:19:52.363883","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"is this really specific to 'response info' or is this for the 'data'... oh i see (after looking at the callsite)... after 'info' is written then you write this amount of 'data'.\n\nthat's a little awkward?","draft":false,"lineno":68,"date":"2009-10-28 21:19:52.364097","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"Can you add a DCHECK(bytes_read > 0) here so readers know w/o examining the callsite?","draft":false,"lineno":232,"date":"2009-10-28 21:19:52.364270","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"nit: maybe \"wait for async completion to continue reading\"... if it fits on the line?","draft":false,"lineno":239,"date":"2009-10-28 21:19:52.364446","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"response_writer_-> should work here","draft":false,"lineno":467,"date":"2009-10-28 21:19:52.364623","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"i think we can leave this out for now, and revisit if needed when we get to persistent storage... wdyt?","draft":false,"lineno":482,"date":"2009-10-28 21:19:52.364836","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"don't need the .get() on the smart ptr","draft":false,"lineno":549,"date":"2009-10-28 21:19:52.365016","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"ditto... more common to define inline","draft":false,"lineno":551,"date":"2009-10-28 21:19:52.365185","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"maybe call this 'initial_bytes_to_write_', and instead of delivering the value back to the UpdateJob via an argument in each call to OnWriteReponseComplete, have that method check for a non-zero value in the info class... or maybe have a seperate UpdateJob method for OnWriteResponseInfoComplete? Something like that may be less awkward... wdyt?\n\nInfo::OnWriteComplete(int result) {\n if (initial_bytes_to_write_)\n    update_job_->OnWriteResponseInfoComplete(result, info);\n else\n    update_job_->OnWriteResponseComplete(result, info);\n}\n\n","draft":false,"lineno":68,"date":"2009-10-28 21:57:25.420657","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"How you're handling the refcounted ioBuffer parameter is susceptible to leaks. If the callee doesn't take then later release a ref to the ioBuffer, the object will be leaked. There are code paths where the callee may skip the taking a ref of its own. A safer pattern is to load the newly created refcounted object into a scoped_refptr in the current scope as follows...\n\nscoped_refptr<HttpResponseInfoIOBuffer> info_buffer(new ...);\ninfo->response_writer_->WriteInfo(info_buffer, callback);\n\n... on exit from the current scope, Release will get called and if the callee didn't take a ref of its own, the object will be deleted.\n\nDitto other refcounted info ioBuffer arg usages for the writing of the manifest entry.\n\n\nAlso, with the smart ptr, you don't need to the .get() to invoke the method.","draft":false,"lineno":256,"date":"2009-10-28 21:57:25.420839","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"ditto... more common to define inline\n\nalso, where is this heap allocated block deleted?","draft":false,"lineno":536,"date":"2009-10-28 21:57:25.421025","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"I think we may have some racey'ness here, and I missed this in the design of the storage APIs :(\n\nOur data structures can get into an inconsistent state if the the store call fails. The in-memory group will reflect the new cache, but that's not how it is on disk, and thats not how it will look after the group falls out of the working-set and gets reloaded into memory.\n\nThoughts?","draft":false,"lineno":577,"date":"2009-10-28 21:57:25.421187","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"ditto","draft":false,"lineno":868,"date":"2009-10-28 21:57:25.421363","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> nit: Setup... but i see both SetUp and Setup in use in the code base\n\nI was once lectured: \"set up\" is a verb, \"setup\" is a noun.","draft":false,"lineno":40,"date":"2009-10-29 21:25:40.765722","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> its much more common to define storage for CallbackImpls inline rather than heap\n> allocate them...\n> \n> class UpdateJobInfo {\n>   UpdateJobInfo() \n>       : bar_(0),\n>         ALLOW_THIS_IN_INITIALIZER_LIST(\n>             write_callback_(this, &UpdateJobInfo::OnWriteComplete)) {\n>   }\n> \n>   int bar_;\n>   net::CompletionCallbackImpl<UpdateJobInfo> write_callback_;\n> };\n> \n> \n\nDone.","draft":false,"lineno":49,"date":"2009-10-29 21:25:40.765983","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> is this really specific to 'response info' or is this for the 'data'... oh i see\n> (after looking at the callsite)... after 'info' is written then you write this\n> amount of 'data'.\n> \n> that's a little awkward?\n\nReworked flow to write all data first, then write response info.","draft":false,"lineno":68,"date":"2009-10-29 21:25:40.766160","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> Can you add a DCHECK(bytes_read > 0) here so readers know w/o examining the\n> callsite?\n\nDone.","draft":false,"lineno":232,"date":"2009-10-29 21:25:40.766333","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> nit: maybe \"wait for async completion to continue reading\"... if it fits on the\n> line?\n\nDone.","draft":false,"lineno":239,"date":"2009-10-29 21:25:40.766509","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:57:25, michaeln wrote:\n> How you're handling the refcounted ioBuffer parameter is susceptible to leaks.\n> If the callee doesn't take then later release a ref to the ioBuffer, the object\n> will be leaked. There are code paths where the callee may skip the taking a ref\n> of its own. A safer pattern is to load the newly created refcounted object into\n> a scoped_refptr in the current scope as follows...\n> \n> scoped_refptr<HttpResponseInfoIOBuffer> info_buffer(new ...);\n> info->response_writer_->WriteInfo(info_buffer, callback);\n> \n> ... on exit from the current scope, Release will get called and if the callee\n> didn't take a ref of its own, the object will be deleted.\n> \n> Ditto other refcounted info ioBuffer arg usages for the writing of the manifest\n> entry.\n> \n> \n> Also, with the smart ptr, you don't need to the .get() to invoke the method.\n\nDone.","draft":false,"lineno":256,"date":"2009-10-29 21:25:40.766749","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> response_writer_-> should work here\n\nDone.","draft":false,"lineno":467,"date":"2009-10-29 21:25:40.766974","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> i think we can leave this out for now, and revisit if needed when we get to\n> persistent storage... wdyt?\n\nDone.","draft":false,"lineno":482,"date":"2009-10-29 21:25:40.767214","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:57:25, michaeln wrote:\n> ditto... more common to define inline\n> \n> also, where is this heap allocated block deleted?\n\nDone.","draft":false,"lineno":536,"date":"2009-10-29 21:25:40.767400","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> don't need the .get() on the smart ptr\n\nDone.","draft":false,"lineno":549,"date":"2009-10-29 21:25:40.767590","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:19:52, michaeln wrote:\n> ditto... more common to define inline\n\nDone.","draft":false,"lineno":551,"date":"2009-10-29 21:25:40.767767","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:57:25, michaeln wrote:\n> I think we may have some racey'ness here, and I missed this in the design of the\n> storage APIs :(\n> \n> Our data structures can get into an inconsistent state if the the store call\n> fails. The in-memory group will reflect the new cache, but that's not how it is\n> on disk, and thats not how it will look after the group falls out of the\n> working-set and gets reloaded into memory.\n> \n> Thoughts?\n\nAdded code to restore in-memory state of group upon storage failure.","draft":false,"lineno":577,"date":"2009-10-29 21:25:40.767948","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/28 21:57:25, michaeln wrote:\n> ditto\n\nDone.","draft":false,"lineno":868,"date":"2009-10-29 21:25:40.768159","left":false},{"author":"michaeln","author_email":"michaeln@chromium.org","text":"\n> Added code to restore in-memory state of group upon storage failure.\n\nI think this is OK for now, but its still racey. Can you add a TODO here to revisit at a later date?\n","draft":false,"lineno":577,"date":"2009-10-30 00:25:30.901444","left":false},{"author":"jennb","author_email":"jennb@chromium.org","text":"On 2009/10/30 00:25:30, michaeln wrote:\n> \n> > Added code to restore in-memory state of group upon storage failure.\n> \n> I think this is OK for now, but its still racey. Can you add a TODO here to\n> revisit at a later date?\n> \n\nDone.","draft":false,"lineno":577,"date":"2009-10-30 17:31:17.593866","left":false}],"id":4002,"is_binary":false},"webkit/appcache/appcache_update_job.h":{"status":"M    ","num_chunks":5,"no_base_file":false,"property_changes":"","num_added":24,"num_removed":8,"messages":[],"id":4001,"is_binary":false},"webkit/appcache/appcache_update_job_unittest.cc":{"status":"M    ","num_chunks":5,"no_base_file":false,"property_changes":"","num_added":26,"num_removed":8,"messages":[],"id":4003,"is_binary":false}},"owner_email":"jennb@chromium.org","owner":"jennb","message":"''","try_job_results":[{"parent_name":null,"tests":[],"slave":null,"url":"http://build.chromium.org/buildbot/try-server/buildstatus?builder=linux&number=5365","timestamp":"2009-10-30 17:31:17.681986","builder":"linux","clobber":null,"project":null,"reason":null,"result":"0","key":"ahdzfmNocm9taXVtY29kZXJldmlldy1ocnIvCxIFSXNzdWUY8vITDAsSCFBhdGNoU2V0GLkXDAsSDFRyeUpvYlJlc3VsdBi0bQw","requester":null,"buildnumber":null,"revision":null},{"parent_name":null,"tests":[],"slave":null,"url":"http://build.chromium.org/buildbot/try-server/buildstatus?builder=mac&number=5415","timestamp":"2009-10-30 17:31:17.681986","builder":"mac","clobber":null,"project":null,"reason":null,"result":"0","key":"ahdzfmNocm9taXVtY29kZXJldmlldy1ocnIvCxIFSXNzdWUY8vITDAsSCFBhdGNoU2V0GLkXDAsSDFRyeUpvYlJlc3VsdBi1bQw","requester":null,"buildnumber":null,"revision":null},{"parent_name":null,"tests":[],"slave":null,"url":"http://build.chromium.org/buildbot/try-server/buildstatus?builder=win&number=5698","timestamp":"2009-10-30 17:31:17.681986","builder":"win","clobber":null,"project":null,"reason":null,"result":"0","key":"ahdzfmNocm9taXVtY29kZXJldmlldy1ocnIvCxIFSXNzdWUY8vITDAsSCFBhdGNoU2V0GLkXDAsSDFRyeUpvYlJlc3VsdBi2bQw","requester":null,"buildnumber":null,"revision":null}],"created":"2009-10-28 01:43:57.716929","url":null,"num_comments":29,"modified":"2012-01-13 14:30:09.691910","patchset":3001,"issue":326002}