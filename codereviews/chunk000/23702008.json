{"description":"Adds the UserInputMonitor implementation for Windows.\n\nBUG=274623\n\nCommitted: https://src.chromium.org/viewvc/chrome?view=rev&revision=223223\n\nCommitted: https://src.chromium.org/viewvc/chrome?view=rev&revision=223260","cc":["chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"reviewers":["sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org"],"messages":[{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","dalecurtis@google.com","sergeyu@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"PTAL. Thanks!","disapproval":false,"date":"2013-08-28 23:02:01.029210","approval":false},{"sender":"dalecurtis@chromium.org","recipients":["jiayl@chromium.org","dalecurtis@google.com","sergeyu@chromium.org","dalecurtis@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc\nFile media/base/user_input_monitor_unittest.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc#newcode88\nmedia/base/user_input_monitor_unittest.cc:88: base::Thread io_thread(\"UserInputMonitorTestIOThread\");\nDo you actually need these threads? Can you just create a MessageLoop on the stack and pass it in for both UI and IO? Then use a RunLoop.RunUntilIdle() before exiting?\n\nhttps://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc#newcode102\nmedia/base/user_input_monitor_unittest.cc:102: #if defined(OS_MACOSX)\n!defined ?\n\nhttps://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_win.cc#newcode20\nmedia/base/user_input_monitor_win.cc:20: // From the HID Usage Tables specification.\nYou'll need to find mark@'s equivalent for the Windows stuff here. I don't know enough about the API to give this a thorough review.","disapproval":false,"date":"2013-08-29 19:02:41.929620","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","dalecurtis@google.com","sergeyu@chromium.org","dalecurtis@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc\nFile media/base/user_input_monitor_unittest.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc#newcode88\nmedia/base/user_input_monitor_unittest.cc:88: base::Thread io_thread(\"UserInputMonitorTestIOThread\");\nOn 2013/08/29 19:02:42, DaleCurtis wrote:\n> Do you actually need these threads? Can you just create a MessageLoop on the\n> stack and pass it in for both UI and IO? Then use a RunLoop.RunUntilIdle()\n> before exiting?\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc#newcode102\nmedia/base/user_input_monitor_unittest.cc:102: #if defined(OS_MACOSX)\nOn 2013/08/29 19:02:42, DaleCurtis wrote:\n> !defined ?\n\nDone.","disapproval":false,"date":"2013-08-29 21:05:39.993860","approval":false},{"sender":"jiayl@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"Sergey/James,\r\n\r\ncould you review the Windows specific code?\r\n\r\n\r\nOn Thu, Aug 29, 2013 at 2:05 PM, <jiayl@chromium.org> wrote:\r\n\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/1/media/**\r\n> base/user_input_monitor_**unittest.cc<https://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc>\r\n> File media/base/user_input_monitor_**unittest.cc (right):\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/1/media/**\r\n> base/user_input_monitor_**unittest.cc#newcode88<https://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc#newcode88>\r\n> media/base/user_input_monitor_**unittest.cc:88: base::Thread\r\n> io_thread(\"**UserInputMonitorTestIOThread\")**;\r\n> On 2013/08/29 19:02:42, DaleCurtis wrote:\r\n>\r\n>> Do you actually need these threads? Can you just create a MessageLoop\r\n>>\r\n> on the\r\n>\r\n>> stack and pass it in for both UI and IO? Then use a\r\n>>\r\n> RunLoop.RunUntilIdle()\r\n>\r\n>> before exiting?\r\n>>\r\n>\r\n> Done.\r\n>\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/1/media/**\r\n> base/user_input_monitor_**unittest.cc#newcode102<https://codereview.chromium.org/23702008/diff/1/media/base/user_input_monitor_unittest.cc#newcode102>\r\n> media/base/user_input_monitor_**unittest.cc:102: #if defined(OS_MACOSX)\r\n> On 2013/08/29 19:02:42, DaleCurtis wrote:\r\n>\r\n>> !defined ?\r\n>>\r\n>\r\n> Done.\r\n>\r\n> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-03 18:36:54.129870","approval":false},{"sender":"wez@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode31\nmedia/base/user_input_monitor_win.cc:31: virtual size_t GetKeyPressCount() const OVERRIDE;\nnit: Suggest comment \"UserInputMonitor public interface\"\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode38\nmedia/base/user_input_monitor_win.cc:38: static int NumberOfRawInputDevices(uint8 target_events);\nnit: |target_events| -> |event_mask| to make it clearer that this should be a combination of EventBitMask values? Or add a comment to explain the method's usage.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode40\nmedia/base/user_input_monitor_win.cc:40: virtual void StartMouseMonitoring() OVERRIDE;\nnit: Suggest comment \"UserInputMonitor private interface\" to introduce this block.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode59\nmedia/base/user_input_monitor_win.cc:59: RAWINPUTDEVICE* GetRawInputDevices(uint8 target_events, DWORD flags);\nIf you make this return std::vector<RAWINPUTDEVICE> then you don't end up returning a bare pointer, and you fold NummberOfRawInputDevices() into GetRawInputDevices.\n\n(If you're worried about the vector copying overhead it could return a scoped_ptr<std::vector<...> >)\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode65\nmedia/base/user_input_monitor_win.cc:65: // Members only accessed on the UI thread.\nIf all the methods above are called only on the UI message loop, and all these members are called only on the UI thread, why do you need these comments?\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\nmedia/base/user_input_monitor_win.cc:101: base::Unretained(this),\nThis will use-after-free if the StartMouseMonitoring() is called, and the caller then deletes the UserInputMonitor immediately on the calling thread, since the task will still be processed on the UI thread.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode105\nmedia/base/user_input_monitor_win.cc:105: StartMonitor(MOUSE_EVENT_MASK);\nThis path will never be hit unless the caller is also on the UI thread. Better to have the PostTask, above, re-post StartMouseMonitoring().\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode142\nmedia/base/user_input_monitor_win.cc:142: DCHECK(ui_task_runner_->BelongsToCurrentThread());\nnit: I prefer pre-condition DCHECKs to be followed by a blank line before the rest of the method logic, for ease of readability.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode151\nmedia/base/user_input_monitor_win.cc:151: window_.reset(new base::win::MessageWindow());\nWhy re-create the window every time a new event is requested? Can't you just create the window if |events_monitored_| was empty, and call RegisterRawInputDevices() to start it receiving events?\n\nYou're also never un-registering for notifications to the old window.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode165\nmedia/base/user_input_monitor_win.cc:165: if (window_) {\nClarify that |window_| may be NULL if we failed to monitor events.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode169\nmedia/base/user_input_monitor_win.cc:169: // The error is harmless, ignore it.\nWhich error? Why not trap & at least LOG_SYSERR(WARNING) it?\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode183\nmedia/base/user_input_monitor_win.cc:183: input_handle, RID_INPUT, NULL, &size, sizeof(RAWINPUTHEADER));\nnit: Verify that |result| is not greater than zero here, or some other -ve value than -1?\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode194\nmedia/base/user_input_monitor_win.cc:194: if (result == -1) {\nnit: See above re verifying |result|\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode230\nmedia/base/user_input_monitor_win.cc:230: if (RegisterRawInputDevices(devices.get(),\nHave you checked the semantics if e.g. two separate calls are made to RegisterRawInputDevices() that direct the same type of input to different windows, to know how this will interact w/ other users of the API in Chrome?","disapproval":false,"date":"2013-09-03 20:07:04.356900","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\nmedia/base/user_input_monitor_win.cc:101: base::Unretained(this),\nOn 2013/09/03 20:07:04, Wez wrote:\n> This will use-after-free if the StartMouseMonitoring() is called, and the caller\n> then deletes the UserInputMonitor immediately on the calling thread, since the\n> task will still be processed on the UI thread.\n\nYou are right. I was assuming the caller should make sure UserInputMonitor is not deleted too early, but that seems not a good assumption. I'm going to change UserInputMonitor to ref counted. WeakPtr won't work since UserInputMonitor is destroyed and called back on different threads.","disapproval":false,"date":"2013-09-03 21:41:28.396230","approval":false},{"sender":"dalecurtis@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\nmedia/base/user_input_monitor_win.cc:101: base::Unretained(this),\nOn 2013/09/03 21:41:28, jiayl wrote:\n> On 2013/09/03 20:07:04, Wez wrote:\n> > This will use-after-free if the StartMouseMonitoring() is called, and the\n> caller\n> > then deletes the UserInputMonitor immediately on the calling thread, since the\n> > task will still be processed on the UI thread.\n> \n> You are right. I was assuming the caller should make sure UserInputMonitor is\n> not deleted too early, but that seems not a good assumption. I'm going to change\n> UserInputMonitor to ref counted. WeakPtr won't work since UserInputMonitor is\n> destroyed and called back on different threads.\n\nIsn't it invalid for a client to call StartMouseMonitoring() then delete without calling StopMouseMonitoring() ? If we can avoid ref-counting anything that'd be great.","disapproval":false,"date":"2013-09-03 22:59:32.593650","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"On 2013/09/03 22:59:32, DaleCurtis wrote:\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\n> File media/base/user_input_monitor_win.cc (right):\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\n> media/base/user_input_monitor_win.cc:101: base::Unretained(this),\n> On 2013/09/03 21:41:28, jiayl wrote:\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > This will use-after-free if the StartMouseMonitoring() is called, and the\n> > caller\n> > > then deletes the UserInputMonitor immediately on the calling thread, since\n> the\n> > > task will still be processed on the UI thread.\n> > \n> > You are right. I was assuming the caller should make sure UserInputMonitor is\n> > not deleted too early, but that seems not a good assumption. I'm going to\n> change\n> > UserInputMonitor to ref counted. WeakPtr won't work since UserInputMonitor is\n> > destroyed and called back on different threads.\n> \n> Isn't it invalid for a client to call StartMouseMonitoring() then delete without\n> calling StopMouseMonitoring() ? If we can avoid ref-counting anything that'd be\n> great.\n\nThat's true. But if StopMouseMonitoring is called right before UserInputMonitor, the queued async events on the UI thread may still call back to the destroyed UserInputMonitor.","disapproval":false,"date":"2013-09-03 23:01:51.148230","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","wez@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"PTAL. \n\nsky, could you review the change in browser_main_loop.h?\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode31\nmedia/base/user_input_monitor_win.cc:31: virtual size_t GetKeyPressCount() const OVERRIDE;\nOn 2013/09/03 20:07:04, Wez wrote:\n> nit: Suggest comment \"UserInputMonitor public interface\"\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode38\nmedia/base/user_input_monitor_win.cc:38: static int NumberOfRawInputDevices(uint8 target_events);\nOn 2013/09/03 20:07:04, Wez wrote:\n> nit: |target_events| -> |event_mask| to make it clearer that this should be a\n> combination of EventBitMask values? Or add a comment to explain the method's\n> usage.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode40\nmedia/base/user_input_monitor_win.cc:40: virtual void StartMouseMonitoring() OVERRIDE;\nOn 2013/09/03 20:07:04, Wez wrote:\n> nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> block.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode40\nmedia/base/user_input_monitor_win.cc:40: virtual void StartMouseMonitoring() OVERRIDE;\nOn 2013/09/03 20:07:04, Wez wrote:\n> nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> block.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode59\nmedia/base/user_input_monitor_win.cc:59: RAWINPUTDEVICE* GetRawInputDevices(uint8 target_events, DWORD flags);\nOn 2013/09/03 20:07:04, Wez wrote:\n> If you make this return std::vector<RAWINPUTDEVICE> then you don't end up\n> returning a bare pointer, and you fold NummberOfRawInputDevices() into\n> GetRawInputDevices.\n> \n> (If you're worried about the vector copying overhead it could return a\n> scoped_ptr<std::vector<...> >)\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode65\nmedia/base/user_input_monitor_win.cc:65: // Members only accessed on the UI thread.\nOn 2013/09/03 20:07:04, Wez wrote:\n> If all the methods above are called only on the UI message loop, and all these\n> members are called only on the UI thread, why do you need these comments?\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\nmedia/base/user_input_monitor_win.cc:101: base::Unretained(this),\nOn 2013/09/03 20:07:04, Wez wrote:\n> This will use-after-free if the StartMouseMonitoring() is called, and the caller\n> then deletes the UserInputMonitor immediately on the calling thread, since the\n> task will still be processed on the UI thread.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode105\nmedia/base/user_input_monitor_win.cc:105: StartMonitor(MOUSE_EVENT_MASK);\nOn 2013/09/03 20:07:04, Wez wrote:\n> This path will never be hit unless the caller is also on the UI thread. Better\n> to have the PostTask, above, re-post StartMouseMonitoring().\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode142\nmedia/base/user_input_monitor_win.cc:142: DCHECK(ui_task_runner_->BelongsToCurrentThread());\nOn 2013/09/03 20:07:04, Wez wrote:\n> nit: I prefer pre-condition DCHECKs to be followed by a blank line before the\n> rest of the method logic, for ease of readability.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode151\nmedia/base/user_input_monitor_win.cc:151: window_.reset(new base::win::MessageWindow());\nOn 2013/09/03 20:07:04, Wez wrote:\n> Why re-create the window every time a new event is requested? Can't you just\n> create the window if |events_monitored_| was empty, and call\n> RegisterRawInputDevices() to start it receiving events?\n> \n> You're also never un-registering for notifications to the old window.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode165\nmedia/base/user_input_monitor_win.cc:165: if (window_) {\nOn 2013/09/03 20:07:04, Wez wrote:\n> Clarify that |window_| may be NULL if we failed to monitor events.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode169\nmedia/base/user_input_monitor_win.cc:169: // The error is harmless, ignore it.\nOn 2013/09/03 20:07:04, Wez wrote:\n> Which error? Why not trap & at least LOG_SYSERR(WARNING) it?\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode183\nmedia/base/user_input_monitor_win.cc:183: input_handle, RID_INPUT, NULL, &size, sizeof(RAWINPUTHEADER));\nOn 2013/09/03 20:07:04, Wez wrote:\n> nit: Verify that |result| is not greater than zero here, or some other -ve value\n> than -1?\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode194\nmedia/base/user_input_monitor_win.cc:194: if (result == -1) {\nOn 2013/09/03 20:07:04, Wez wrote:\n> nit: See above re verifying |result|\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode230\nmedia/base/user_input_monitor_win.cc:230: if (RegisterRawInputDevices(devices.get(),\nOn 2013/09/03 20:07:04, Wez wrote:\n> Have you checked the semantics if e.g. two separate calls are made to\n> RegisterRawInputDevices() that direct the same type of input to different\n> windows, to know how this will interact w/ other users of the API in Chrome?\nHmm...I verified that only one window will receive the event if multiple ones are registered. Chrome has no other callers though.","disapproval":false,"date":"2013-09-03 23:44:12.527430","approval":false},{"sender":"wez@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"On 2013/09/03 23:01:51, jiayl wrote:\n> On 2013/09/03 22:59:32, DaleCurtis wrote:\n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\n> > File media/base/user_input_monitor_win.cc (right):\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\n> > media/base/user_input_monitor_win.cc:101: base::Unretained(this),\n> > On 2013/09/03 21:41:28, jiayl wrote:\n> > > On 2013/09/03 20:07:04, Wez wrote:\n> > > > This will use-after-free if the StartMouseMonitoring() is called, and the\n> > > caller\n> > > > then deletes the UserInputMonitor immediately on the calling thread, since\n> > the\n> > > > task will still be processed on the UI thread.\n> > > \n> > > You are right. I was assuming the caller should make sure UserInputMonitor\n> is\n> > > not deleted too early, but that seems not a good assumption. I'm going to\n> > change\n> > > UserInputMonitor to ref counted. WeakPtr won't work since UserInputMonitor\n> is\n> > > destroyed and called back on different threads.\n> > \n> > Isn't it invalid for a client to call StartMouseMonitoring() then delete\n> without\n> > calling StopMouseMonitoring() ? If we can avoid ref-counting anything that'd\n> be\n> > great.\n> \n> That's true. But if StopMouseMonitoring is called right before UserInputMonitor,\n> the queued async events on the UI thread may still call back to the destroyed\n> UserInputMonitor.\n\nNot if those events were bound to WeakPtrs to the UserInputMonitor. :)","disapproval":false,"date":"2013-09-04 00:07:51.743390","approval":false},{"sender":"wez@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"On 2013/09/03 23:44:12, jiayl wrote:\n> PTAL. \n> \n> sky, could you review the change in browser_main_loop.h?\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\n> File media/base/user_input_monitor_win.cc (right):\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode31\n> media/base/user_input_monitor_win.cc:31: virtual size_t GetKeyPressCount() const\n> OVERRIDE;\n> On 2013/09/03 20:07:04, Wez wrote:\n> > nit: Suggest comment \"UserInputMonitor public interface\"\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode38\n> media/base/user_input_monitor_win.cc:38: static int\n> NumberOfRawInputDevices(uint8 target_events);\n> On 2013/09/03 20:07:04, Wez wrote:\n> > nit: |target_events| -> |event_mask| to make it clearer that this should be a\n> > combination of EventBitMask values? Or add a comment to explain the method's\n> > usage.\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode40\n> media/base/user_input_monitor_win.cc:40: virtual void StartMouseMonitoring()\n> OVERRIDE;\n> On 2013/09/03 20:07:04, Wez wrote:\n> > nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> > block.\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode40\n> media/base/user_input_monitor_win.cc:40: virtual void StartMouseMonitoring()\n> OVERRIDE;\n> On 2013/09/03 20:07:04, Wez wrote:\n> > nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> > block.\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode59\n> media/base/user_input_monitor_win.cc:59: RAWINPUTDEVICE*\n> GetRawInputDevices(uint8 target_events, DWORD flags);\n> On 2013/09/03 20:07:04, Wez wrote:\n> > If you make this return std::vector<RAWINPUTDEVICE> then you don't end up\n> > returning a bare pointer, and you fold NummberOfRawInputDevices() into\n> > GetRawInputDevices.\n> > \n> > (If you're worried about the vector copying overhead it could return a\n> > scoped_ptr<std::vector<...> >)\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode65\n> media/base/user_input_monitor_win.cc:65: // Members only accessed on the UI\n> thread.\n> On 2013/09/03 20:07:04, Wez wrote:\n> > If all the methods above are called only on the UI message loop, and all these\n> > members are called only on the UI thread, why do you need these comments?\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\n> media/base/user_input_monitor_win.cc:101: base::Unretained(this),\n> On 2013/09/03 20:07:04, Wez wrote:\n> > This will use-after-free if the StartMouseMonitoring() is called, and the\n> caller\n> > then deletes the UserInputMonitor immediately on the calling thread, since the\n> > task will still be processed on the UI thread.\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode105\n> media/base/user_input_monitor_win.cc:105: StartMonitor(MOUSE_EVENT_MASK);\n> On 2013/09/03 20:07:04, Wez wrote:\n> > This path will never be hit unless the caller is also on the UI thread. Better\n> > to have the PostTask, above, re-post StartMouseMonitoring().\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode142\n> media/base/user_input_monitor_win.cc:142:\n> DCHECK(ui_task_runner_->BelongsToCurrentThread());\n> On 2013/09/03 20:07:04, Wez wrote:\n> > nit: I prefer pre-condition DCHECKs to be followed by a blank line before the\n> > rest of the method logic, for ease of readability.\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode151\n> media/base/user_input_monitor_win.cc:151: window_.reset(new\n> base::win::MessageWindow());\n> On 2013/09/03 20:07:04, Wez wrote:\n> > Why re-create the window every time a new event is requested? Can't you just\n> > create the window if |events_monitored_| was empty, and call\n> > RegisterRawInputDevices() to start it receiving events?\n> > \n> > You're also never un-registering for notifications to the old window.\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode165\n> media/base/user_input_monitor_win.cc:165: if (window_) {\n> On 2013/09/03 20:07:04, Wez wrote:\n> > Clarify that |window_| may be NULL if we failed to monitor events.\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode169\n> media/base/user_input_monitor_win.cc:169: // The error is harmless, ignore it.\n> On 2013/09/03 20:07:04, Wez wrote:\n> > Which error? Why not trap & at least LOG_SYSERR(WARNING) it?\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode183\n> media/base/user_input_monitor_win.cc:183: input_handle, RID_INPUT, NULL, &size,\n> sizeof(RAWINPUTHEADER));\n> On 2013/09/03 20:07:04, Wez wrote:\n> > nit: Verify that |result| is not greater than zero here, or some other -ve\n> value\n> > than -1?\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode194\n> media/base/user_input_monitor_win.cc:194: if (result == -1) {\n> On 2013/09/03 20:07:04, Wez wrote:\n> > nit: See above re verifying |result|\n> \n> Done.\n> \n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode230\n> media/base/user_input_monitor_win.cc:230: if\n> (RegisterRawInputDevices(devices.get(),\n> On 2013/09/03 20:07:04, Wez wrote:\n> > Have you checked the semantics if e.g. two separate calls are made to\n> > RegisterRawInputDevices() that direct the same type of input to different\n> > windows, to know how this will interact w/ other users of the API in Chrome?\n> Hmm...I verified that only one window will receive the event if multiple ones\n> are registered. Chrome has no other callers though.\n\nDo you only create a single UserInputMonitor no matter how many capture streams are active, then?","disapproval":false,"date":"2013-09-04 00:08:51.668220","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"On 2013/09/04 00:08:51, Wez wrote:\n> On 2013/09/03 23:44:12, jiayl wrote:\n> > PTAL. \n> > \n> > sky, could you review the change in browser_main_loop.h?\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\n> > File media/base/user_input_monitor_win.cc (right):\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode31\n> > media/base/user_input_monitor_win.cc:31: virtual size_t GetKeyPressCount()\n> const\n> > OVERRIDE;\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > nit: Suggest comment \"UserInputMonitor public interface\"\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode38\n> > media/base/user_input_monitor_win.cc:38: static int\n> > NumberOfRawInputDevices(uint8 target_events);\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > nit: |target_events| -> |event_mask| to make it clearer that this should be\n> a\n> > > combination of EventBitMask values? Or add a comment to explain the method's\n> > > usage.\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode40\n> > media/base/user_input_monitor_win.cc:40: virtual void StartMouseMonitoring()\n> > OVERRIDE;\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> > > block.\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode40\n> > media/base/user_input_monitor_win.cc:40: virtual void StartMouseMonitoring()\n> > OVERRIDE;\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> > > block.\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode59\n> > media/base/user_input_monitor_win.cc:59: RAWINPUTDEVICE*\n> > GetRawInputDevices(uint8 target_events, DWORD flags);\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > If you make this return std::vector<RAWINPUTDEVICE> then you don't end up\n> > > returning a bare pointer, and you fold NummberOfRawInputDevices() into\n> > > GetRawInputDevices.\n> > > \n> > > (If you're worried about the vector copying overhead it could return a\n> > > scoped_ptr<std::vector<...> >)\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode65\n> > media/base/user_input_monitor_win.cc:65: // Members only accessed on the UI\n> > thread.\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > If all the methods above are called only on the UI message loop, and all\n> these\n> > > members are called only on the UI thread, why do you need these comments?\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\n> > media/base/user_input_monitor_win.cc:101: base::Unretained(this),\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > This will use-after-free if the StartMouseMonitoring() is called, and the\n> > caller\n> > > then deletes the UserInputMonitor immediately on the calling thread, since\n> the\n> > > task will still be processed on the UI thread.\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode105\n> > media/base/user_input_monitor_win.cc:105: StartMonitor(MOUSE_EVENT_MASK);\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > This path will never be hit unless the caller is also on the UI thread.\n> Better\n> > > to have the PostTask, above, re-post StartMouseMonitoring().\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode142\n> > media/base/user_input_monitor_win.cc:142:\n> > DCHECK(ui_task_runner_->BelongsToCurrentThread());\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > nit: I prefer pre-condition DCHECKs to be followed by a blank line before\n> the\n> > > rest of the method logic, for ease of readability.\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode151\n> > media/base/user_input_monitor_win.cc:151: window_.reset(new\n> > base::win::MessageWindow());\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > Why re-create the window every time a new event is requested? Can't you just\n> > > create the window if |events_monitored_| was empty, and call\n> > > RegisterRawInputDevices() to start it receiving events?\n> > > \n> > > You're also never un-registering for notifications to the old window.\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode165\n> > media/base/user_input_monitor_win.cc:165: if (window_) {\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > Clarify that |window_| may be NULL if we failed to monitor events.\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode169\n> > media/base/user_input_monitor_win.cc:169: // The error is harmless, ignore it.\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > Which error? Why not trap & at least LOG_SYSERR(WARNING) it?\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode183\n> > media/base/user_input_monitor_win.cc:183: input_handle, RID_INPUT, NULL,\n> &size,\n> > sizeof(RAWINPUTHEADER));\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > nit: Verify that |result| is not greater than zero here, or some other -ve\n> > value\n> > > than -1?\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode194\n> > media/base/user_input_monitor_win.cc:194: if (result == -1) {\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > nit: See above re verifying |result|\n> > \n> > Done.\n> > \n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode230\n> > media/base/user_input_monitor_win.cc:230: if\n> > (RegisterRawInputDevices(devices.get(),\n> > On 2013/09/03 20:07:04, Wez wrote:\n> > > Have you checked the semantics if e.g. two separate calls are made to\n> > > RegisterRawInputDevices() that direct the same type of input to different\n> > > windows, to know how this will interact w/ other users of the API in Chrome?\n> > Hmm...I verified that only one window will receive the event if multiple ones\n> > are registered. Chrome has no other callers though.\n> \n> Do you only create a single UserInputMonitor no matter how many capture streams\n> are active, then?\n\nCorrect.","disapproval":false,"date":"2013-09-04 00:10:28.446000","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"On 2013/09/04 00:07:51, Wez wrote:\n> On 2013/09/03 23:01:51, jiayl wrote:\n> > On 2013/09/03 22:59:32, DaleCurtis wrote:\n> > >\n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc\n> > > File media/base/user_input_monitor_win.cc (right):\n> > > \n> > >\n> >\n> https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101\n> > > media/base/user_input_monitor_win.cc:101: base::Unretained(this),\n> > > On 2013/09/03 21:41:28, jiayl wrote:\n> > > > On 2013/09/03 20:07:04, Wez wrote:\n> > > > > This will use-after-free if the StartMouseMonitoring() is called, and\n> the\n> > > > caller\n> > > > > then deletes the UserInputMonitor immediately on the calling thread,\n> since\n> > > the\n> > > > > task will still be processed on the UI thread.\n> > > > \n> > > > You are right. I was assuming the caller should make sure UserInputMonitor\n> > is\n> > > > not deleted too early, but that seems not a good assumption. I'm going to\n> > > change\n> > > > UserInputMonitor to ref counted. WeakPtr won't work since UserInputMonitor\n> > is\n> > > > destroyed and called back on different threads.\n> > > \n> > > Isn't it invalid for a client to call StartMouseMonitoring() then delete\n> > without\n> > > calling StopMouseMonitoring() ? If we can avoid ref-counting anything that'd\n> > be\n> > > great.\n> > \n> > That's true. But if StopMouseMonitoring is called right before\n> UserInputMonitor,\n> > the queued async events on the UI thread may still call back to the destroyed\n> > UserInputMonitor.\n> \n> Not if those events were bound to WeakPtrs to the UserInputMonitor. :)\n\nBut the WeakPtrs need to be deref'd on the callback thread while UserInputMonitor is destroyed on the main thread, which means WeakPtrs are invalidated and deref'd on different threads.","disapproval":false,"date":"2013-09-04 00:12:14.724530","approval":false},{"sender":"wez@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"On 3 September 2013 17:12, <jiayl@chromium.org> wrote:\r\n\r\n> On 2013/09/04 00:07:51, Wez wrote:\r\n>\r\n>> On 2013/09/03 23:01:51, jiayl wrote:\r\n>> > On 2013/09/03 22:59:32, DaleCurtis wrote:\r\n>> > >\r\n>> >\r\n>>\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/8001/media/**\r\n> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc>\r\n>\r\n>> > > File media/base/user_input_monitor_**win.cc (right):\r\n>> > >\r\n>> > >\r\n>> >\r\n>>\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/8001/media/**\r\n> base/user_input_monitor_win.**cc#newcode101<https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101>\r\n>\r\n>> > > media/base/user_input_monitor_**win.cc:101: base::Unretained(this),\r\n>>\r\n>> > > On 2013/09/03 21:41:28, jiayl wrote:\r\n>> > > > On 2013/09/03 20:07:04, Wez wrote:\r\n>> > > > > This will use-after-free if the StartMouseMonitoring() is called,\r\n>> and\r\n>> the\r\n>> > > > caller\r\n>> > > > > then deletes the UserInputMonitor immediately on the calling\r\n>> thread,\r\n>> since\r\n>> > > the\r\n>> > > > > task will still be processed on the UI thread.\r\n>> > > >\r\n>> > > > You are right. I was assuming the caller should make sure\r\n>>\r\n> UserInputMonitor\r\n>\r\n>> > is\r\n>> > > > not deleted too early, but that seems not a good assumption. I'm\r\n>> going\r\n>>\r\n> to\r\n>\r\n>> > > change\r\n>> > > > UserInputMonitor to ref counted. WeakPtr won't work since\r\n>>\r\n> UserInputMonitor\r\n>\r\n>> > is\r\n>> > > > destroyed and called back on different threads.\r\n>> > >\r\n>> > > Isn't it invalid for a client to call StartMouseMonitoring() then\r\n>> delete\r\n>> > without\r\n>> > > calling StopMouseMonitoring() ? If we can avoid ref-counting anything\r\n>>\r\n> that'd\r\n>\r\n>> > be\r\n>> > > great.\r\n>> >\r\n>> > That's true. But if StopMouseMonitoring is called right before\r\n>> UserInputMonitor,\r\n>> > the queued async events on the UI thread may still call back to the\r\n>>\r\n> destroyed\r\n>\r\n>> > UserInputMonitor.\r\n>>\r\n>\r\n>  Not if those events were bound to WeakPtrs to the UserInputMonitor. :)\r\n>>\r\n>\r\n> But the WeakPtrs need to be deref'd on the callback thread while\r\n> UserInputMonitor is destroyed on the main thread, which means WeakPtrs are\r\n> invalidated and deref'd on different threads.\r\n\r\n\r\nWhich are the \"callback\" and \"main\" threads wrt this CL? You mean the\r\n|ui_task_runner| and calling threads?\r\n\r\nLooking at UserInputMonitor's implementation, I'd assumed you must punt the\r\nmouse notifications back to the calling thread for dispatch, to avoid a\r\nrace between notifications and calls to RemoveMouseListener(), which case\r\nyou;d be dereferencing the WeakPtr on the caller thread, which would work.\r\n\r\nIt looks like you're instead relying on locking around the observer-list\r\nmodifications, and observer notifications - are you sure that's a good\r\nidea? It means that one badly-behaved observer can indirectly block the UI\r\nthread. :(\r\n\r\n\r\n>\r\n> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 00:21:23.521870","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"On 2013/09/04 00:21:23, Wez wrote:\n> On 3 September 2013 17:12, <mailto:jiayl@chromium.org> wrote:\n> \n> > On 2013/09/04 00:07:51, Wez wrote:\n> >\n> >> On 2013/09/03 23:01:51, jiayl wrote:\n> >> > On 2013/09/03 22:59:32, DaleCurtis wrote:\n> >> > >\n> >> >\n> >>\n> >\n> > https://codereview.chromium.**org/23702008/diff/8001/media/**\n> >\n> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc>\n> >\n> >> > > File media/base/user_input_monitor_**win.cc (right):\n> >> > >\n> >> > >\n> >> >\n> >>\n> >\n> > https://codereview.chromium.**org/23702008/diff/8001/media/**\n> >\n> base/user_input_monitor_win.**cc#newcode101<https://codereview.chromium.org/23702008/diff/8001/media/base/user_input_monitor_win.cc#newcode101>\n> >\n> >> > > media/base/user_input_monitor_**win.cc:101: base::Unretained(this),\n> >>\n> >> > > On 2013/09/03 21:41:28, jiayl wrote:\n> >> > > > On 2013/09/03 20:07:04, Wez wrote:\n> >> > > > > This will use-after-free if the StartMouseMonitoring() is called,\n> >> and\n> >> the\n> >> > > > caller\n> >> > > > > then deletes the UserInputMonitor immediately on the calling\n> >> thread,\n> >> since\n> >> > > the\n> >> > > > > task will still be processed on the UI thread.\n> >> > > >\n> >> > > > You are right. I was assuming the caller should make sure\n> >>\n> > UserInputMonitor\n> >\n> >> > is\n> >> > > > not deleted too early, but that seems not a good assumption. I'm\n> >> going\n> >>\n> > to\n> >\n> >> > > change\n> >> > > > UserInputMonitor to ref counted. WeakPtr won't work since\n> >>\n> > UserInputMonitor\n> >\n> >> > is\n> >> > > > destroyed and called back on different threads.\n> >> > >\n> >> > > Isn't it invalid for a client to call StartMouseMonitoring() then\n> >> delete\n> >> > without\n> >> > > calling StopMouseMonitoring() ? If we can avoid ref-counting anything\n> >>\n> > that'd\n> >\n> >> > be\n> >> > > great.\n> >> >\n> >> > That's true. But if StopMouseMonitoring is called right before\n> >> UserInputMonitor,\n> >> > the queued async events on the UI thread may still call back to the\n> >>\n> > destroyed\n> >\n> >> > UserInputMonitor.\n> >>\n> >\n> >  Not if those events were bound to WeakPtrs to the UserInputMonitor. :)\n> >>\n> >\n> > But the WeakPtrs need to be deref'd on the callback thread while\n> > UserInputMonitor is destroyed on the main thread, which means WeakPtrs are\n> > invalidated and deref'd on different threads.\n> \n> \n> Which are the \"callback\" and \"main\" threads wrt this CL? You mean the\n> |ui_task_runner| and calling threads?\n> \n> Looking at UserInputMonitor's implementation, I'd assumed you must punt the\n> mouse notifications back to the calling thread for dispatch, to avoid a\n> race between notifications and calls to RemoveMouseListener(), which case\n> you;d be dereferencing the WeakPtr on the caller thread, which would work.\n> \n> It looks like you're instead relying on locking around the observer-list\n> modifications, and observer notifications - are you sure that's a good\n> idea? It means that one badly-behaved observer can indirectly block the UI\n> thread. :(\n> \n> \n> >\n> >\n> https://codereview.chromium.**org/23702008/%3Chttps://codereview.chromium.org/23702008/>\n> >\n> \n> To unsubscribe from this group and stop receiving emails from it, send an email\n> to mailto:chromium-reviews+unsubscribe@chromium.org.\n\nBut AddMouseListener/RemoveMouseListener can be called on any thread. Which thread should the callback be dispatched to? Plus the calling thread of Add/RemoveListener is not the same thread that creates/destroys UserInputMonitor, which means there is still a problem in using WeakPtr.","disapproval":false,"date":"2013-09-04 00:38:43.733130","approval":false},{"sender":"sky@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"LGTM","disapproval":false,"date":"2013-09-04 14:25:54.654660","approval":true},{"sender":"sergeyu@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Looks like there are some races - see my comments.\n\nI already suggested in previous CLs to use ObserverListThreadSafe - it will help to avoid the problems Wez pointed at and also guarantees that notifications are delivered on the same thread on which listener is registered. You can use it with a locked listeners counter to detect when to start/stop monitoring.\n\nI also don't like that you are making UserInputMonitor ref-counted. You can avoid it easily by using a \"Core\" object. It can be ref-counted, e.g. as in remoting::LocalInputMonitorLinux, but if you destroy on the thread on which events are received then it won't need to be ref-counted.\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: if (!io_task_runner_->BelongsToCurrentThread()) {\nThere is potential race between StartKeyboardMonitoring() and StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a thread other than the IO thread and then StartKeyboardMonitoring() is called the IO immediately after that then monitoring will be started and then stopped on the IO thread, while it should be stopped first and then started. I think you can avoid it by always posting a task to call StopMonitor().\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114\nmedia/base/user_input_monitor_win.cc:114: if (!ui_task_runner_->BelongsToCurrentThread()) {\nThere is a same race as in Linux version of this code. Just post a task for StopMonitor()?\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207\nmedia/base/user_input_monitor_win.cc:207: ? ui::ET_KEY_RELEASED\nnit: operators should not be wrapped. ? goes on the previous line.\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/media.gyp\nFile media/media.gyp (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884\nmedia/media.gyp:884: 'sources!': [\nindentation","disapproval":false,"date":"2013-09-04 18:40:09.507390","approval":false},{"sender":"jiayl@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"On Wed, Sep 4, 2013 at 11:40 AM, <sergeyu@chromium.org> wrote:\r\n\r\n> Looks like there are some races - see my comments.\r\n>\r\n> I already suggested in previous CLs to use ObserverListThreadSafe - it\r\n> will help\r\n> to avoid the problems Wez pointed at and also guarantees that\r\n> notifications are\r\n> delivered on the same thread on which listener is registered. You can use\r\n> it\r\n> with a locked listeners counter to detect when to start/stop monitoring.\r\n>\r\n> I also don't like that you are making UserInputMonitor ref-counted. You can\r\n> avoid it easily by using a \"Core\" object. It can be ref-counted, e.g. as in\r\n> remoting::**LocalInputMonitorLinux, but if you destroy on the thread on\r\n> which\r\n> events are received then it won't need to be ref-counted.\r\n>\r\n\r\n\r\nOberserListThreadSafe is also implemented through locks (\r\nhttps://code.google.com/p/chromium/codesearch#chromium/src/base/observer_list_threadsafe.h&q=ObserverListThreadSafe&sq=package:chromium&type=cs&l=226),\r\nso will not solve the issue wez pointed out.\r\n\r\nI don't see a way to get rid of the lock; but I can remove the ref-counting\r\nof UserInputMonitor by posting the callback to the thread that\r\ncreates/destroys UserInputMonior, i.e. the browser UI thread, to make\r\nWeakPtr valid to use.\r\n\r\nHow about that?\r\n\r\n>\r\n>\r\nhttps://codereview.chromium.**org/23702008/diff/20001/media/**\r\n> base/user_input_monitor_linux.**cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc>\r\n> File media/base/user_input_monitor_**linux.cc (right):\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n> base/user_input_monitor_linux.**cc#newcode138<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138>\r\n> media/base/user_input_monitor_**linux.cc:138: if\r\n> (!io_task_runner_->**BelongsToCurrentThread()) {\r\n> There is potential race between StartKeyboardMonitoring() and\r\n> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a\r\n> thread other than the IO thread and then StartKeyboardMonitoring() is\r\n> called the IO immediately after that then monitoring will be started and\r\n> then stopped on the IO thread, while it should be stopped first and then\r\n> started. I think you can avoid it by always posting a task to call\r\n> StopMonitor().\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc>\r\n> File media/base/user_input_monitor_**win.cc (right):\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n> base/user_input_monitor_win.**cc#newcode114<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114>\r\n> media/base/user_input_monitor_**win.cc:114: if\r\n> (!ui_task_runner_->**BelongsToCurrentThread()) {\r\n> There is a same race as in Linux version of this code. Just post a task\r\n> for StopMonitor()?\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n> base/user_input_monitor_win.**cc#newcode207<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207>\r\n> media/base/user_input_monitor_**win.cc:207: ? ui::ET_KEY_RELEASED\r\n> nit: operators should not be wrapped. ? goes on the previous line.\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/20001/media/**media.gyp<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp>\r\n> File media/media.gyp (right):\r\n>\r\n> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n> media.gyp#newcode884<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884>\r\n> media/media.gyp:884: 'sources!': [\r\n> indentation\r\n>\r\n> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 18:49:29.460470","approval":false},{"sender":"sergeyu@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"On Wed, Sep 4, 2013 at 11:49 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n\r\n>\r\n> On Wed, Sep 4, 2013 at 11:40 AM, <sergeyu@chromium.org> wrote:\r\n>\r\n>> Looks like there are some races - see my comments.\r\n>>\r\n>> I already suggested in previous CLs to use ObserverListThreadSafe - it\r\n>> will help\r\n>> to avoid the problems Wez pointed at and also guarantees that\r\n>> notifications are\r\n>> delivered on the same thread on which listener is registered. You can use\r\n>> it\r\n>> with a locked listeners counter to detect when to start/stop monitoring.\r\n>>\r\n>> I also don't like that you are making UserInputMonitor ref-counted. You\r\n>> can\r\n>> avoid it easily by using a \"Core\" object. It can be ref-counted, e.g. as\r\n>> in\r\n>> remoting::**LocalInputMonitorLinux, but if you destroy on the thread on\r\n>> which\r\n>> events are received then it won't need to be ref-counted.\r\n>>\r\n>\r\n>\r\n> OberserListThreadSafe is also implemented through locks (\r\n> https://code.google.com/p/chromium/codesearch#chromium/src/base/observer_list_threadsafe.h&q=ObserverListThreadSafe&sq=package:chromium&type=cs&l=226),\r\n> so will not solve the issue wez pointed out.\r\n>\r\n\r\nOberserListThreadSafe holds a lock only to post a task. It always releases\r\nthe lock before calling observers.\r\n\r\n\r\n>\r\n> I don't see a way to get rid of the lock; but I can remove the\r\n> ref-counting of UserInputMonitor by posting the callback to the thread that\r\n> creates/destroys UserInputMonior, i.e. the browser UI thread, to make\r\n> WeakPtr valid to use.\r\n>\r\n> How about that?\r\n>\r\n>>\r\n>>\r\n>  https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>> base/user_input_monitor_linux.**cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc>\r\n>> File media/base/user_input_monitor_**linux.cc (right):\r\n>>\r\n>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>> base/user_input_monitor_linux.**cc#newcode138<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138>\r\n>> media/base/user_input_monitor_**linux.cc:138: if\r\n>> (!io_task_runner_->**BelongsToCurrentThread()) {\r\n>> There is potential race between StartKeyboardMonitoring() and\r\n>> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a\r\n>> thread other than the IO thread and then StartKeyboardMonitoring() is\r\n>> called the IO immediately after that then monitoring will be started and\r\n>> then stopped on the IO thread, while it should be stopped first and then\r\n>> started. I think you can avoid it by always posting a task to call\r\n>> StopMonitor().\r\n>>\r\n>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc>\r\n>> File media/base/user_input_monitor_**win.cc (right):\r\n>>\r\n>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>> base/user_input_monitor_win.**cc#newcode114<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114>\r\n>> media/base/user_input_monitor_**win.cc:114: if\r\n>> (!ui_task_runner_->**BelongsToCurrentThread()) {\r\n>> There is a same race as in Linux version of this code. Just post a task\r\n>> for StopMonitor()?\r\n>>\r\n>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>> base/user_input_monitor_win.**cc#newcode207<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207>\r\n>> media/base/user_input_monitor_**win.cc:207: ? ui::ET_KEY_RELEASED\r\n>> nit: operators should not be wrapped. ? goes on the previous line.\r\n>>\r\n>> https://codereview.chromium.**org/23702008/diff/20001/media/**media.gyp<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp>\r\n>> File media/media.gyp (right):\r\n>>\r\n>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>> media.gyp#newcode884<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884>\r\n>> media/media.gyp:884: 'sources!': [\r\n>> indentation\r\n>>\r\n>> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>>\r\n>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 18:53:50.300800","approval":false},{"sender":"jiayl@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"On Wed, Sep 4, 2013 at 11:53 AM, Sergey Ulanov <sergeyu@chromium.org> wrote:\r\n\r\n>\r\n> On Wed, Sep 4, 2013 at 11:49 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>\r\n>>\r\n>> On Wed, Sep 4, 2013 at 11:40 AM, <sergeyu@chromium.org> wrote:\r\n>>\r\n>>> Looks like there are some races - see my comments.\r\n>>>\r\n>>> I already suggested in previous CLs to use ObserverListThreadSafe - it\r\n>>> will help\r\n>>> to avoid the problems Wez pointed at and also guarantees that\r\n>>> notifications are\r\n>>> delivered on the same thread on which listener is registered. You can\r\n>>> use it\r\n>>> with a locked listeners counter to detect when to start/stop monitoring.\r\n>>>\r\n>>> I also don't like that you are making UserInputMonitor ref-counted. You\r\n>>> can\r\n>>> avoid it easily by using a \"Core\" object. It can be ref-counted, e.g. as\r\n>>> in\r\n>>> remoting::**LocalInputMonitorLinux, but if you destroy on the thread on\r\n>>> which\r\n>>> events are received then it won't need to be ref-counted.\r\n>>>\r\n>>\r\n>>\r\n>> OberserListThreadSafe is also implemented through locks (\r\n>> https://code.google.com/p/chromium/codesearch#chromium/src/base/observer_list_threadsafe.h&q=ObserverListThreadSafe&sq=package:chromium&type=cs&l=226),\r\n>> so will not solve the issue wez pointed out.\r\n>>\r\n>\r\n> OberserListThreadSafe holds a lock only to post a task. It always releases\r\n> the lock before calling observers.\r\n>\r\n>\r\n\r\nAh, I see.  I'll fix that then. :) Thanks!\r\n\r\n>\r\n>> I don't see a way to get rid of the lock; but I can remove the\r\n>> ref-counting of UserInputMonitor by posting the callback to the thread that\r\n>> creates/destroys UserInputMonior, i.e. the browser UI thread, to make\r\n>> WeakPtr valid to use.\r\n>>\r\n>> How about that?\r\n>>\r\n>>>\r\n>>>\r\n>>  https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>> base/user_input_monitor_linux.**cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc>\r\n>>> File media/base/user_input_monitor_**linux.cc (right):\r\n>>>\r\n>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>> base/user_input_monitor_linux.**cc#newcode138<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138>\r\n>>> media/base/user_input_monitor_**linux.cc:138: if\r\n>>> (!io_task_runner_->**BelongsToCurrentThread()) {\r\n>>> There is potential race between StartKeyboardMonitoring() and\r\n>>> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a\r\n>>> thread other than the IO thread and then StartKeyboardMonitoring() is\r\n>>> called the IO immediately after that then monitoring will be started and\r\n>>> then stopped on the IO thread, while it should be stopped first and then\r\n>>> started. I think you can avoid it by always posting a task to call\r\n>>> StopMonitor().\r\n>>>\r\n>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc>\r\n>>> File media/base/user_input_monitor_**win.cc (right):\r\n>>>\r\n>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>> base/user_input_monitor_win.**cc#newcode114<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114>\r\n>>> media/base/user_input_monitor_**win.cc:114: if\r\n>>> (!ui_task_runner_->**BelongsToCurrentThread()) {\r\n>>> There is a same race as in Linux version of this code. Just post a task\r\n>>> for StopMonitor()?\r\n>>>\r\n>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>> base/user_input_monitor_win.**cc#newcode207<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207>\r\n>>> media/base/user_input_monitor_**win.cc:207: ? ui::ET_KEY_RELEASED\r\n>>> nit: operators should not be wrapped. ? goes on the previous line.\r\n>>>\r\n>>> https://codereview.chromium.**org/23702008/diff/20001/media/**media.gyp<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp>\r\n>>> File media/media.gyp (right):\r\n>>>\r\n>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>> media.gyp#newcode884<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884>\r\n>>> media/media.gyp:884: 'sources!': [\r\n>>> indentation\r\n>>>\r\n>>> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>>>\r\n>>\r\n>>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 18:56:51.597850","approval":false},{"sender":"jiayl@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"I'm planning to make this change to remove the assumption that\r\nUserInputMonitor has to outlive the UI/IO browser threads. Please let me\r\nknow what you think.\r\n\r\nI'll have a UserInputMonitorWrapper class to handle the creation and\r\ndestruction of UserInputMonitor:\r\nclass UserInputMonitorWrapper {\r\n public:\r\n  UserInputMonitorWrapper(io_task_runner, ui_task_runner);\r\n  ~UserInputMonitorWrapper();\r\n  UserInputMonitor* user_input_monitor() { return monitor_; }\r\n private:\r\n  UserInputMonitor* monitor_;\r\n}\r\n\r\nThe implementation of UserInputMonitorWrapper will be platform specifc, for\r\nexample on Linux:\r\nUserInputMonitorWrapper::UserInputMonitorWrapper (...) {\r\n  monitor_ = new UserInputMonitorLinux(io_task_runner);\r\n}\r\n// Dispatch to the IO thread to delete |monitor_|.\r\nUserInputMonitorWrapper::~UserInputMonitorWrapper() {\r\n  monitor_->io_task_runner()->PostTask(\r\n    &UserInputMonitorLinux::Shutdown, base::Owned(monitor_));\r\n  monitor_ = NULL;\r\n}\r\n\r\nThen UserInputMonitorLinux can use WeakPtr for posting tasks to the IO\r\nthread since it will be destructed on the IO thread.\r\n\r\nIt doesn't matter if the io_task_runner is not running when the wrapper is\r\ndestructed since base::Owned will make sure |monitor_| is not leaked.\r\n\r\nUserInputMonitorLinux::Shutdown does not need to anything except checking\r\nmonitoring has been stopped.\r\n\r\n\r\n\r\n\r\nOn Wed, Sep 4, 2013 at 11:56 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n\r\n>\r\n>\r\n>\r\n> On Wed, Sep 4, 2013 at 11:53 AM, Sergey Ulanov <sergeyu@chromium.org>wrote:\r\n>\r\n>>\r\n>> On Wed, Sep 4, 2013 at 11:49 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>>\r\n>>>\r\n>>> On Wed, Sep 4, 2013 at 11:40 AM, <sergeyu@chromium.org> wrote:\r\n>>>\r\n>>>> Looks like there are some races - see my comments.\r\n>>>>\r\n>>>> I already suggested in previous CLs to use ObserverListThreadSafe - it\r\n>>>> will help\r\n>>>> to avoid the problems Wez pointed at and also guarantees that\r\n>>>> notifications are\r\n>>>> delivered on the same thread on which listener is registered. You can\r\n>>>> use it\r\n>>>> with a locked listeners counter to detect when to start/stop monitoring.\r\n>>>>\r\n>>>> I also don't like that you are making UserInputMonitor ref-counted. You\r\n>>>> can\r\n>>>> avoid it easily by using a \"Core\" object. It can be ref-counted, e.g.\r\n>>>> as in\r\n>>>> remoting::**LocalInputMonitorLinux, but if you destroy on the thread\r\n>>>> on which\r\n>>>> events are received then it won't need to be ref-counted.\r\n>>>>\r\n>>>\r\n>>>\r\n>>> OberserListThreadSafe is also implemented through locks (\r\n>>> https://code.google.com/p/chromium/codesearch#chromium/src/base/observer_list_threadsafe.h&q=ObserverListThreadSafe&sq=package:chromium&type=cs&l=226),\r\n>>> so will not solve the issue wez pointed out.\r\n>>>\r\n>>\r\n>> OberserListThreadSafe holds a lock only to post a task. It always\r\n>> releases the lock before calling observers.\r\n>>\r\n>>\r\n>\r\n> Ah, I see.  I'll fix that then. :) Thanks!\r\n>\r\n>>\r\n>>> I don't see a way to get rid of the lock; but I can remove the\r\n>>> ref-counting of UserInputMonitor by posting the callback to the thread that\r\n>>> creates/destroys UserInputMonior, i.e. the browser UI thread, to make\r\n>>> WeakPtr valid to use.\r\n>>>\r\n>>> How about that?\r\n>>>\r\n>>>>\r\n>>>>\r\n>>>  https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>> base/user_input_monitor_linux.**cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc>\r\n>>>> File media/base/user_input_monitor_**linux.cc (right):\r\n>>>>\r\n>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>> base/user_input_monitor_linux.**cc#newcode138<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138>\r\n>>>> media/base/user_input_monitor_**linux.cc:138: if\r\n>>>> (!io_task_runner_->**BelongsToCurrentThread()) {\r\n>>>> There is potential race between StartKeyboardMonitoring() and\r\n>>>> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a\r\n>>>> thread other than the IO thread and then StartKeyboardMonitoring() is\r\n>>>> called the IO immediately after that then monitoring will be started and\r\n>>>> then stopped on the IO thread, while it should be stopped first and then\r\n>>>> started. I think you can avoid it by always posting a task to call\r\n>>>> StopMonitor().\r\n>>>>\r\n>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc>\r\n>>>> File media/base/user_input_monitor_**win.cc (right):\r\n>>>>\r\n>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>> base/user_input_monitor_win.**cc#newcode114<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114>\r\n>>>> media/base/user_input_monitor_**win.cc:114: if\r\n>>>> (!ui_task_runner_->**BelongsToCurrentThread()) {\r\n>>>> There is a same race as in Linux version of this code. Just post a task\r\n>>>> for StopMonitor()?\r\n>>>>\r\n>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>> base/user_input_monitor_win.**cc#newcode207<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207>\r\n>>>> media/base/user_input_monitor_**win.cc:207: ? ui::ET_KEY_RELEASED\r\n>>>> nit: operators should not be wrapped. ? goes on the previous line.\r\n>>>>\r\n>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**media.gyp<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp>\r\n>>>> File media/media.gyp (right):\r\n>>>>\r\n>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>> media.gyp#newcode884<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884>\r\n>>>> media/media.gyp:884: 'sources!': [\r\n>>>> indentation\r\n>>>>\r\n>>>> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>>>>\r\n>>>\r\n>>>\r\n>>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 21:23:55.783900","approval":false},{"sender":"sergeyu@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"That's essentially what I and Wez were suggesting, but please consider\r\nadding Core inside of UserInputMonitor instead of a wrapper outside of\r\nit. I.e. in you code below rename the core\r\nUserInputMonitor=>UserInputMonitor::Core and the\r\nwrapper UserInputMonitorWrapper=>UserInputMonitor. Then instead of exposing\r\ncore from the outer class add separate methods that call the core.\r\n\r\n\r\nOn Wed, Sep 4, 2013 at 2:23 PM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n\r\n> I'm planning to make this change to remove the assumption that\r\n> UserInputMonitor has to outlive the UI/IO browser threads. Please let me\r\n> know what you think.\r\n>\r\n> I'll have a UserInputMonitorWrapper class to handle the creation and\r\n> destruction of UserInputMonitor:\r\n> class UserInputMonitorWrapper {\r\n>  public:\r\n>   UserInputMonitorWrapper(io_task_runner, ui_task_runner);\r\n>   ~UserInputMonitorWrapper();\r\n>   UserInputMonitor* user_input_monitor() { return monitor_; }\r\n>  private:\r\n>   UserInputMonitor* monitor_;\r\n> }\r\n>\r\n> The implementation of UserInputMonitorWrapper will be platform specifc,\r\n> for example on Linux:\r\n> UserInputMonitorWrapper::UserInputMonitorWrapper (...) {\r\n>   monitor_ = new UserInputMonitorLinux(io_task_runner);\r\n> }\r\n> // Dispatch to the IO thread to delete |monitor_|.\r\n> UserInputMonitorWrapper::~UserInputMonitorWrapper() {\r\n>   monitor_->io_task_runner()->PostTask(\r\n>     &UserInputMonitorLinux::Shutdown, base::Owned(monitor_));\r\n>   monitor_ = NULL;\r\n> }\r\n>\r\n> Then UserInputMonitorLinux can use WeakPtr for posting tasks to the IO\r\n> thread since it will be destructed on the IO thread.\r\n>\r\n> It doesn't matter if the io_task_runner is not running when the wrapper is\r\n> destructed since base::Owned will make sure |monitor_| is not leaked.\r\n>\r\n\r\nI think you don't really need base::Owned() - just call\r\nTaskRunner::DeleteSoon() when you are ready to delete it.\r\n\r\n\r\n>\r\n> UserInputMonitorLinux::Shutdown does not need to anything except checking\r\n> monitoring has been stopped.\r\n>\r\n>\r\n>\r\n>\r\n> On Wed, Sep 4, 2013 at 11:56 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>\r\n>>\r\n>>\r\n>>\r\n>> On Wed, Sep 4, 2013 at 11:53 AM, Sergey Ulanov <sergeyu@chromium.org>wrote:\r\n>>\r\n>>>\r\n>>> On Wed, Sep 4, 2013 at 11:49 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>>>\r\n>>>>\r\n>>>> On Wed, Sep 4, 2013 at 11:40 AM, <sergeyu@chromium.org> wrote:\r\n>>>>\r\n>>>>> Looks like there are some races - see my comments.\r\n>>>>>\r\n>>>>> I already suggested in previous CLs to use ObserverListThreadSafe - it\r\n>>>>> will help\r\n>>>>> to avoid the problems Wez pointed at and also guarantees that\r\n>>>>> notifications are\r\n>>>>> delivered on the same thread on which listener is registered. You can\r\n>>>>> use it\r\n>>>>> with a locked listeners counter to detect when to start/stop\r\n>>>>> monitoring.\r\n>>>>>\r\n>>>>> I also don't like that you are making UserInputMonitor ref-counted.\r\n>>>>> You can\r\n>>>>> avoid it easily by using a \"Core\" object. It can be ref-counted, e.g.\r\n>>>>> as in\r\n>>>>> remoting::**LocalInputMonitorLinux, but if you destroy on the thread\r\n>>>>> on which\r\n>>>>> events are received then it won't need to be ref-counted.\r\n>>>>>\r\n>>>>\r\n>>>>\r\n>>>> OberserListThreadSafe is also implemented through locks (\r\n>>>> https://code.google.com/p/chromium/codesearch#chromium/src/base/observer_list_threadsafe.h&q=ObserverListThreadSafe&sq=package:chromium&type=cs&l=226),\r\n>>>> so will not solve the issue wez pointed out.\r\n>>>>\r\n>>>\r\n>>> OberserListThreadSafe holds a lock only to post a task. It always\r\n>>> releases the lock before calling observers.\r\n>>>\r\n>>>\r\n>>\r\n>> Ah, I see.  I'll fix that then. :) Thanks!\r\n>>\r\n>>>\r\n>>>> I don't see a way to get rid of the lock; but I can remove the\r\n>>>> ref-counting of UserInputMonitor by posting the callback to the thread that\r\n>>>> creates/destroys UserInputMonior, i.e. the browser UI thread, to make\r\n>>>> WeakPtr valid to use.\r\n>>>>\r\n>>>> How about that?\r\n>>>>\r\n>>>>>\r\n>>>>>\r\n>>>>  https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>> base/user_input_monitor_linux.**cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc>\r\n>>>>> File media/base/user_input_monitor_**linux.cc (right):\r\n>>>>>\r\n>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>> base/user_input_monitor_linux.**cc#newcode138<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138>\r\n>>>>> media/base/user_input_monitor_**linux.cc:138: if\r\n>>>>> (!io_task_runner_->**BelongsToCurrentThread()) {\r\n>>>>> There is potential race between StartKeyboardMonitoring() and\r\n>>>>> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a\r\n>>>>> thread other than the IO thread and then StartKeyboardMonitoring() is\r\n>>>>> called the IO immediately after that then monitoring will be started\r\n>>>>> and\r\n>>>>> then stopped on the IO thread, while it should be stopped first and\r\n>>>>> then\r\n>>>>> started. I think you can avoid it by always posting a task to call\r\n>>>>> StopMonitor().\r\n>>>>>\r\n>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc>\r\n>>>>> File media/base/user_input_monitor_**win.cc (right):\r\n>>>>>\r\n>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>> base/user_input_monitor_win.**cc#newcode114<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114>\r\n>>>>> media/base/user_input_monitor_**win.cc:114: if\r\n>>>>> (!ui_task_runner_->**BelongsToCurrentThread()) {\r\n>>>>> There is a same race as in Linux version of this code. Just post a task\r\n>>>>> for StopMonitor()?\r\n>>>>>\r\n>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>> base/user_input_monitor_win.**cc#newcode207<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207>\r\n>>>>> media/base/user_input_monitor_**win.cc:207: ? ui::ET_KEY_RELEASED\r\n>>>>> nit: operators should not be wrapped. ? goes on the previous line.\r\n>>>>>\r\n>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>> media.gyp<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp>\r\n>>>>> File media/media.gyp (right):\r\n>>>>>\r\n>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>> media.gyp#newcode884<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884>\r\n>>>>> media/media.gyp:884: 'sources!': [\r\n>>>>> indentation\r\n>>>>>\r\n>>>>> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>>>>>\r\n>>>>\r\n>>>>\r\n>>>\r\n>>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 22:42:37.004860","approval":false},{"sender":"jiayl@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"On Wed, Sep 4, 2013 at 3:42 PM, Sergey Ulanov <sergeyu@chromium.org> wrote:\r\n\r\n> That's essentially what I and Wez were suggesting, but please consider\r\n> adding Core inside of UserInputMonitor instead of a wrapper outside of\r\n> it. I.e. in you code below rename the core\r\n> UserInputMonitor=>UserInputMonitor::Core and the\r\n> wrapper UserInputMonitorWrapper=>UserInputMonitor. Then instead of exposing\r\n> core from the outer class add separate methods that call the core.\r\n>\r\n>\r\n> That means the mouse listeners need to be moved into Core so that Core\r\ndoes not need to call back to the outer class. Does that sound good to you?\r\n\r\n\r\n> On Wed, Sep 4, 2013 at 2:23 PM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>\r\n>> I'm planning to make this change to remove the assumption that\r\n>> UserInputMonitor has to outlive the UI/IO browser threads. Please let me\r\n>> know what you think.\r\n>>\r\n>> I'll have a UserInputMonitorWrapper class to handle the creation and\r\n>> destruction of UserInputMonitor:\r\n>> class UserInputMonitorWrapper {\r\n>>  public:\r\n>>   UserInputMonitorWrapper(io_task_runner, ui_task_runner);\r\n>>   ~UserInputMonitorWrapper();\r\n>>   UserInputMonitor* user_input_monitor() { return monitor_; }\r\n>>  private:\r\n>>   UserInputMonitor* monitor_;\r\n>> }\r\n>>\r\n>> The implementation of UserInputMonitorWrapper will be platform specifc,\r\n>> for example on Linux:\r\n>> UserInputMonitorWrapper::UserInputMonitorWrapper (...) {\r\n>>   monitor_ = new UserInputMonitorLinux(io_task_runner);\r\n>> }\r\n>> // Dispatch to the IO thread to delete |monitor_|.\r\n>> UserInputMonitorWrapper::~UserInputMonitorWrapper() {\r\n>>   monitor_->io_task_runner()->PostTask(\r\n>>     &UserInputMonitorLinux::Shutdown, base::Owned(monitor_));\r\n>>   monitor_ = NULL;\r\n>> }\r\n>>\r\n>> Then UserInputMonitorLinux can use WeakPtr for posting tasks to the IO\r\n>> thread since it will be destructed on the IO thread.\r\n>>\r\n>> It doesn't matter if the io_task_runner is not running when the wrapper\r\n>> is destructed since base::Owned will make sure |monitor_| is not leaked.\r\n>>\r\n>\r\n> I think you don't really need base::Owned() - just call\r\n> TaskRunner::DeleteSoon() when you are ready to delete it.\r\n>\r\n>\r\n>>\r\n>> UserInputMonitorLinux::Shutdown does not need to anything except checking\r\n>> monitoring has been stopped.\r\n>>\r\n>>\r\n>>\r\n>>\r\n>> On Wed, Sep 4, 2013 at 11:56 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>>\r\n>>>\r\n>>>\r\n>>>\r\n>>> On Wed, Sep 4, 2013 at 11:53 AM, Sergey Ulanov <sergeyu@chromium.org>wrote:\r\n>>>\r\n>>>>\r\n>>>> On Wed, Sep 4, 2013 at 11:49 AM, Jiayang Liu <jiayl@chromium.org>wrote:\r\n>>>>\r\n>>>>>\r\n>>>>> On Wed, Sep 4, 2013 at 11:40 AM, <sergeyu@chromium.org> wrote:\r\n>>>>>\r\n>>>>>> Looks like there are some races - see my comments.\r\n>>>>>>\r\n>>>>>> I already suggested in previous CLs to use ObserverListThreadSafe -\r\n>>>>>> it will help\r\n>>>>>> to avoid the problems Wez pointed at and also guarantees that\r\n>>>>>> notifications are\r\n>>>>>> delivered on the same thread on which listener is registered. You can\r\n>>>>>> use it\r\n>>>>>> with a locked listeners counter to detect when to start/stop\r\n>>>>>> monitoring.\r\n>>>>>>\r\n>>>>>> I also don't like that you are making UserInputMonitor ref-counted.\r\n>>>>>> You can\r\n>>>>>> avoid it easily by using a \"Core\" object. It can be ref-counted, e.g.\r\n>>>>>> as in\r\n>>>>>> remoting::**LocalInputMonitorLinux, but if you destroy on the thread\r\n>>>>>> on which\r\n>>>>>> events are received then it won't need to be ref-counted.\r\n>>>>>>\r\n>>>>>\r\n>>>>>\r\n>>>>> OberserListThreadSafe is also implemented through locks (\r\n>>>>> https://code.google.com/p/chromium/codesearch#chromium/src/base/observer_list_threadsafe.h&q=ObserverListThreadSafe&sq=package:chromium&type=cs&l=226),\r\n>>>>> so will not solve the issue wez pointed out.\r\n>>>>>\r\n>>>>\r\n>>>> OberserListThreadSafe holds a lock only to post a task. It always\r\n>>>> releases the lock before calling observers.\r\n>>>>\r\n>>>>\r\n>>>\r\n>>> Ah, I see.  I'll fix that then. :) Thanks!\r\n>>>\r\n>>>>\r\n>>>>> I don't see a way to get rid of the lock; but I can remove the\r\n>>>>> ref-counting of UserInputMonitor by posting the callback to the thread that\r\n>>>>> creates/destroys UserInputMonior, i.e. the browser UI thread, to make\r\n>>>>> WeakPtr valid to use.\r\n>>>>>\r\n>>>>> How about that?\r\n>>>>>\r\n>>>>>>\r\n>>>>>>\r\n>>>>>  https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>> base/user_input_monitor_linux.**cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc>\r\n>>>>>> File media/base/user_input_monitor_**linux.cc (right):\r\n>>>>>>\r\n>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>> base/user_input_monitor_linux.**cc#newcode138<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138>\r\n>>>>>> media/base/user_input_monitor_**linux.cc:138: if\r\n>>>>>> (!io_task_runner_->**BelongsToCurrentThread()) {\r\n>>>>>> There is potential race between StartKeyboardMonitoring() and\r\n>>>>>> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a\r\n>>>>>> thread other than the IO thread and then StartKeyboardMonitoring() is\r\n>>>>>> called the IO immediately after that then monitoring will be started\r\n>>>>>> and\r\n>>>>>> then stopped on the IO thread, while it should be stopped first and\r\n>>>>>> then\r\n>>>>>> started. I think you can avoid it by always posting a task to call\r\n>>>>>> StopMonitor().\r\n>>>>>>\r\n>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc>\r\n>>>>>> File media/base/user_input_monitor_**win.cc (right):\r\n>>>>>>\r\n>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>> base/user_input_monitor_win.**cc#newcode114<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114>\r\n>>>>>> media/base/user_input_monitor_**win.cc:114: if\r\n>>>>>> (!ui_task_runner_->**BelongsToCurrentThread()) {\r\n>>>>>> There is a same race as in Linux version of this code. Just post a\r\n>>>>>> task\r\n>>>>>> for StopMonitor()?\r\n>>>>>>\r\n>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>> base/user_input_monitor_win.**cc#newcode207<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207>\r\n>>>>>> media/base/user_input_monitor_**win.cc:207: ? ui::ET_KEY_RELEASED\r\n>>>>>> nit: operators should not be wrapped. ? goes on the previous line.\r\n>>>>>>\r\n>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>> media.gyp<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp>\r\n>>>>>> File media/media.gyp (right):\r\n>>>>>>\r\n>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>> media.gyp#newcode884<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884>\r\n>>>>>> media/media.gyp:884: 'sources!': [\r\n>>>>>> indentation\r\n>>>>>>\r\n>>>>>> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>>>>>>\r\n>>>>>\r\n>>>>>\r\n>>>>\r\n>>>\r\n>>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 22:49:39.781420","approval":false},{"sender":"sergeyu@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"On Wed, Sep 4, 2013 at 3:49 PM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n\r\n>\r\n> On Wed, Sep 4, 2013 at 3:42 PM, Sergey Ulanov <sergeyu@chromium.org>wrote:\r\n>\r\n>> That's essentially what I and Wez were suggesting, but please consider\r\n>> adding Core inside of UserInputMonitor instead of a wrapper outside of\r\n>> it. I.e. in you code below rename the core\r\n>> UserInputMonitor=>UserInputMonitor::Core and the\r\n>> wrapper UserInputMonitorWrapper=>UserInputMonitor. Then instead of exposing\r\n>> core from the outer class add separate methods that call the core.\r\n>>\r\n>>\r\n>> That means the mouse listeners need to be moved into Core so that Core\r\n> does not need to call back to the outer class. Does that sound good to you?\r\n>\r\n\r\nYes. The wrapper will just delegate AddListener() and RemoveListener()\r\ncalls to the core and the core will take care of storing the listeners and\r\ninvoking them when necessary.\r\n\r\n\r\n\r\n\r\n>\r\n>\r\n>> On Wed, Sep 4, 2013 at 2:23 PM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>>\r\n>>> I'm planning to make this change to remove the assumption that\r\n>>> UserInputMonitor has to outlive the UI/IO browser threads. Please let me\r\n>>> know what you think.\r\n>>>\r\n>>> I'll have a UserInputMonitorWrapper class to handle the creation and\r\n>>> destruction of UserInputMonitor:\r\n>>> class UserInputMonitorWrapper {\r\n>>>  public:\r\n>>>   UserInputMonitorWrapper(io_task_runner, ui_task_runner);\r\n>>>   ~UserInputMonitorWrapper();\r\n>>>   UserInputMonitor* user_input_monitor() { return monitor_; }\r\n>>>  private:\r\n>>>   UserInputMonitor* monitor_;\r\n>>> }\r\n>>>\r\n>>> The implementation of UserInputMonitorWrapper will be platform specifc,\r\n>>> for example on Linux:\r\n>>> UserInputMonitorWrapper::UserInputMonitorWrapper (...) {\r\n>>>   monitor_ = new UserInputMonitorLinux(io_task_runner);\r\n>>> }\r\n>>> // Dispatch to the IO thread to delete |monitor_|.\r\n>>> UserInputMonitorWrapper::~UserInputMonitorWrapper() {\r\n>>>   monitor_->io_task_runner()->PostTask(\r\n>>>     &UserInputMonitorLinux::Shutdown, base::Owned(monitor_));\r\n>>>   monitor_ = NULL;\r\n>>> }\r\n>>>\r\n>>> Then UserInputMonitorLinux can use WeakPtr for posting tasks to the IO\r\n>>> thread since it will be destructed on the IO thread.\r\n>>>\r\n>>> It doesn't matter if the io_task_runner is not running when the wrapper\r\n>>> is destructed since base::Owned will make sure |monitor_| is not leaked.\r\n>>>\r\n>>\r\n>> I think you don't really need base::Owned() - just call\r\n>> TaskRunner::DeleteSoon() when you are ready to delete it.\r\n>>\r\n>>\r\n>>>\r\n>>> UserInputMonitorLinux::Shutdown does not need to anything except\r\n>>> checking monitoring has been stopped.\r\n>>>\r\n>>>\r\n>>>\r\n>>>\r\n>>> On Wed, Sep 4, 2013 at 11:56 AM, Jiayang Liu <jiayl@chromium.org> wrote:\r\n>>>\r\n>>>>\r\n>>>>\r\n>>>>\r\n>>>> On Wed, Sep 4, 2013 at 11:53 AM, Sergey Ulanov <sergeyu@chromium.org>wrote:\r\n>>>>\r\n>>>>>\r\n>>>>> On Wed, Sep 4, 2013 at 11:49 AM, Jiayang Liu <jiayl@chromium.org>wrote:\r\n>>>>>\r\n>>>>>>\r\n>>>>>> On Wed, Sep 4, 2013 at 11:40 AM, <sergeyu@chromium.org> wrote:\r\n>>>>>>\r\n>>>>>>> Looks like there are some races - see my comments.\r\n>>>>>>>\r\n>>>>>>> I already suggested in previous CLs to use ObserverListThreadSafe -\r\n>>>>>>> it will help\r\n>>>>>>> to avoid the problems Wez pointed at and also guarantees that\r\n>>>>>>> notifications are\r\n>>>>>>> delivered on the same thread on which listener is registered. You\r\n>>>>>>> can use it\r\n>>>>>>> with a locked listeners counter to detect when to start/stop\r\n>>>>>>> monitoring.\r\n>>>>>>>\r\n>>>>>>> I also don't like that you are making UserInputMonitor ref-counted.\r\n>>>>>>> You can\r\n>>>>>>> avoid it easily by using a \"Core\" object. It can be ref-counted,\r\n>>>>>>> e.g. as in\r\n>>>>>>> remoting::**LocalInputMonitorLinux, but if you destroy on the\r\n>>>>>>> thread on which\r\n>>>>>>> events are received then it won't need to be ref-counted.\r\n>>>>>>>\r\n>>>>>>\r\n>>>>>>\r\n>>>>>> OberserListThreadSafe is also implemented through locks (\r\n>>>>>> https://code.google.com/p/chromium/codesearch#chromium/src/base/observer_list_threadsafe.h&q=ObserverListThreadSafe&sq=package:chromium&type=cs&l=226),\r\n>>>>>> so will not solve the issue wez pointed out.\r\n>>>>>>\r\n>>>>>\r\n>>>>> OberserListThreadSafe holds a lock only to post a task. It always\r\n>>>>> releases the lock before calling observers.\r\n>>>>>\r\n>>>>>\r\n>>>>\r\n>>>> Ah, I see.  I'll fix that then. :) Thanks!\r\n>>>>\r\n>>>>>\r\n>>>>>> I don't see a way to get rid of the lock; but I can remove the\r\n>>>>>> ref-counting of UserInputMonitor by posting the callback to the thread that\r\n>>>>>> creates/destroys UserInputMonior, i.e. the browser UI thread, to make\r\n>>>>>> WeakPtr valid to use.\r\n>>>>>>\r\n>>>>>> How about that?\r\n>>>>>>\r\n>>>>>>>\r\n>>>>>>>\r\n>>>>>>  https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>>> base/user_input_monitor_linux.**cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc>\r\n>>>>>>> File media/base/user_input_monitor_**linux.cc (right):\r\n>>>>>>>\r\n>>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>>> base/user_input_monitor_linux.**cc#newcode138<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138>\r\n>>>>>>> media/base/user_input_monitor_**linux.cc:138: if\r\n>>>>>>> (!io_task_runner_->**BelongsToCurrentThread()) {\r\n>>>>>>> There is potential race between StartKeyboardMonitoring() and\r\n>>>>>>> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a\r\n>>>>>>> thread other than the IO thread and then StartKeyboardMonitoring() is\r\n>>>>>>> called the IO immediately after that then monitoring will be started\r\n>>>>>>> and\r\n>>>>>>> then stopped on the IO thread, while it should be stopped first and\r\n>>>>>>> then\r\n>>>>>>> started. I think you can avoid it by always posting a task to call\r\n>>>>>>> StopMonitor().\r\n>>>>>>>\r\n>>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>>> base/user_input_monitor_win.cc<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc>\r\n>>>>>>> File media/base/user_input_monitor_**win.cc (right):\r\n>>>>>>>\r\n>>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>>> base/user_input_monitor_win.**cc#newcode114<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode114>\r\n>>>>>>> media/base/user_input_monitor_**win.cc:114: if\r\n>>>>>>> (!ui_task_runner_->**BelongsToCurrentThread()) {\r\n>>>>>>> There is a same race as in Linux version of this code. Just post a\r\n>>>>>>> task\r\n>>>>>>> for StopMonitor()?\r\n>>>>>>>\r\n>>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>>> base/user_input_monitor_win.**cc#newcode207<https://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207>\r\n>>>>>>> media/base/user_input_monitor_**win.cc:207: ? ui::ET_KEY_RELEASED\r\n>>>>>>> nit: operators should not be wrapped. ? goes on the previous line.\r\n>>>>>>>\r\n>>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>>> media.gyp<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp>\r\n>>>>>>> File media/media.gyp (right):\r\n>>>>>>>\r\n>>>>>>> https://codereview.chromium.**org/23702008/diff/20001/media/**\r\n>>>>>>> media.gyp#newcode884<https://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884>\r\n>>>>>>> media/media.gyp:884: 'sources!': [\r\n>>>>>>> indentation\r\n>>>>>>>\r\n>>>>>>> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>>>>>>>\r\n>>>>>>\r\n>>>>>>\r\n>>>>>\r\n>>>>\r\n>>>\r\n>>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-04 22:52:56.968550","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"The mouse listener list is moved to the platform specific implementation, which is now separated from UserInputMonitor and always deleted on the monitoring thread (IO on Linux and UI on others). \nPTAL. Thanks!\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: if (!io_task_runner_->BelongsToCurrentThread()) {\nOn 2013/09/04 18:40:09, Sergey Ulanov wrote:\n> There is potential race between StartKeyboardMonitoring() and\n> StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a thread\n> other than the IO thread and then StartKeyboardMonitoring() is called the IO\n> immediately after that then monitoring will be started and then stopped on the\n> IO thread, while it should be stopped first and then started. I think you can\n> avoid it by always posting a task to call StopMonitor().\n\nIf the same caller calls Start and Stop on different threads, there is no way to know what's the intended ordering and I think it's expected to get undefined behavior.\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_win.cc#newcode207\nmedia/base/user_input_monitor_win.cc:207: ? ui::ET_KEY_RELEASED\nOn 2013/09/04 18:40:09, Sergey Ulanov wrote:\n> nit: operators should not be wrapped. ? goes on the previous line.\n\nI don't find the rule on the style guide. But this is auto formatted by git-cl format.\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/media.gyp\nFile media/media.gyp (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/media.gyp#newcode884\nmedia/media.gyp:884: 'sources!': [\nOn 2013/09/04 18:40:09, Sergey Ulanov wrote:\n> indentation\n\nDone.","disapproval":false,"date":"2013-09-05 00:29:37.962740","approval":false},{"sender":"dalecurtis@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Seems you're missing the most recent patch set?","disapproval":false,"date":"2013-09-05 00:36:34.269740","approval":false},{"sender":"jiayl@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"Oops. Uploaded now. Thanks!\r\n\r\n\r\nOn Wed, Sep 4, 2013 at 5:36 PM, <dalecurtis@chromium.org> wrote:\r\n\r\n> Seems you're missing the most recent patch set?\r\n>\r\n> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-05 00:38:16.841940","approval":false},{"sender":"dalecurtis@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Just nits really. I defer to the remoting/ team for the WIndows specific bits.\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_linux.cc#newcode359\nmedia/base/user_input_monitor_linux.cc:359: UserInputMonitorLinux::UserInputMonitorLinux(\nBlank line between each method.\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_unittest.cc\nFile media/base/user_input_monitor_unittest.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_unittest.cc#newcode46\nmedia/base/user_input_monitor_unittest.cc:46: #ifndef DISABLE_USER_INPUT_MONITOR\n!defined()\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_unittest.cc#newcode55\nmedia/base/user_input_monitor_unittest.cc:55: scoped_ptr<UserInputMonitor> monitor = UserInputMonitor::Create(\nJust stack allocate?","disapproval":false,"date":"2013-09-06 21:51:08.130310","approval":false},{"sender":"dalecurtis@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Whoops, lgtm","disapproval":false,"date":"2013-09-06 21:51:37.896460","approval":true},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_linux.cc#newcode359\nmedia/base/user_input_monitor_linux.cc:359: UserInputMonitorLinux::UserInputMonitorLinux(\nOn 2013/09/06 21:51:08, DaleCurtis wrote:\n> Blank line between each method.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_unittest.cc\nFile media/base/user_input_monitor_unittest.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_unittest.cc#newcode46\nmedia/base/user_input_monitor_unittest.cc:46: #ifndef DISABLE_USER_INPUT_MONITOR\nOn 2013/09/06 21:51:08, DaleCurtis wrote:\n> !defined()\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/34001/media/base/user_input_monitor_unittest.cc#newcode55\nmedia/base/user_input_monitor_unittest.cc:55: scoped_ptr<UserInputMonitor> monitor = UserInputMonitor::Create(\nOn 2013/09/06 21:51:08, DaleCurtis wrote:\n> Just stack allocate?\nBut UserInputMonitor::Create returns scoped_ptr.","disapproval":false,"date":"2013-09-06 22:43:29.987910","approval":false},{"sender":"sergeyu@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Thanks for removing ref-counting! There is still a problem with races between StartMonitoring() and StopMonitoring() - it should be easy to fix.\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: if (!io_task_runner_->BelongsToCurrentThread()) {\nOn 2013/09/05 00:29:38, jiayl wrote:\n> On 2013/09/04 18:40:09, Sergey Ulanov wrote:\n> > There is potential race between StartKeyboardMonitoring() and\n> > StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a thread\n> > other than the IO thread and then StartKeyboardMonitoring() is called the IO\n> > immediately after that then monitoring will be started and then stopped on the\n> > IO thread, while it should be stopped first and then started. I think you can\n> > avoid it by always posting a task to call StopMonitor().\n> \n> If the same caller calls Start and Stop on different threads, there is no way to\n> know what's the intended ordering and I think it's expected to get undefined\n> behavior.\n\nIt might not be the same caller.  One object may be calling RemoveMouseListener() which would call StopMonitoring(), while completely different object is calling AddMouseListener() which calls StartMonitoring().\nWhat matters is that the listener gets notification after registering with AddMouseListener(), but due to this race it could happen that monitoring will be stopped when it shouldn't be.\n\nhttps://codereview.chromium.org/23702008/diff/45001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/45001/media/base/user_input_monitor_linux.cc#newcode174\nmedia/base/user_input_monitor_linux.cc:174: if (!io_task_runner_->BelongsToCurrentThread()) {\nThere is still the problem that I pointed before: If some thread calls StartMonitor() and then IO thread calls StopMonitor() immediately after that then StopMonitor() will be executed before StartMonitor() is called on the IO thread. This should be easy to fix. Just add DoStartMonitor() and always post a task from StartMonitor().\n\nStartMonitoring() and StopMonitoring() are always called with the lock held, so there is definite order in which these methods are called. The code that starts/stops monitoring on the IO thread should be always executed in the same order, but that's not guaranteed if you don't always post a task here.","disapproval":false,"date":"2013-09-07 20:19:40.600580","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Fixed the race. PTAL. Thanks!\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: if (!io_task_runner_->BelongsToCurrentThread()) {\nOn 2013/09/07 20:19:41, Sergey Ulanov wrote:\n> On 2013/09/05 00:29:38, jiayl wrote:\n> > On 2013/09/04 18:40:09, Sergey Ulanov wrote:\n> > > There is potential race between StartKeyboardMonitoring() and\n> > > StopKeyboardMonitoring(). If StopKeyboardMonitoring() is called on a thread\n> > > other than the IO thread and then StartKeyboardMonitoring() is called the IO\n> > > immediately after that then monitoring will be started and then stopped on\n> the\n> > > IO thread, while it should be stopped first and then started. I think you\n> can\n> > > avoid it by always posting a task to call StopMonitor().\n> > \n> > If the same caller calls Start and Stop on different threads, there is no way\n> to\n> > know what's the intended ordering and I think it's expected to get undefined\n> > behavior.\n> \n> It might not be the same caller.  One object may be calling\n> RemoveMouseListener() which would call StopMonitoring(), while completely\n> different object is calling AddMouseListener() which calls StartMonitoring().\n> What matters is that the listener gets notification after registering with\n> AddMouseListener(), but due to this race it could happen that monitoring will be\n> stopped when it shouldn't be.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/45001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/45001/media/base/user_input_monitor_linux.cc#newcode174\nmedia/base/user_input_monitor_linux.cc:174: if (!io_task_runner_->BelongsToCurrentThread()) {\nOn 2013/09/07 20:19:41, Sergey Ulanov wrote:\n> There is still the problem that I pointed before: If some thread calls\n> StartMonitor() and then IO thread calls StopMonitor() immediately after that\n> then StopMonitor() will be executed before StartMonitor() is called on the IO\n> thread. This should be easy to fix. Just add DoStartMonitor() and always post a\n> task from StartMonitor().\n> \n> StartMonitoring() and StopMonitoring() are always called with the lock held, so\n> there is definite order in which these methods are called. The code that\n> starts/stops monitoring on the IO thread should be always executed in the same\n> order, but that's not guaranteed if you don't always post a task here.\n\nDone.","disapproval":false,"date":"2013-09-10 16:30:59.914390","approval":false},{"sender":"sergeyu@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"LGTM. Just some minor nits.\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc#newcode40\nmedia/base/user_input_monitor_win.cc:40: // Private interface of UserInputMonitor.\nnit: It's more common to say something like \"UserInputMonitor overrides\". UserInputMonitor is not an interface, so this comment may be confusing.\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc#newcode44\nmedia/base/user_input_monitor_win.cc:44: class Core;\nnit: class declaration should be before the methods.\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc#newcode244\nmedia/base/user_input_monitor_win.cc:244: ? ui::ET_KEY_RELEASED\nnit: Operators normally should not be wrapped, i.e. ? should be on the previous line. Ignore me if you used clang-format to format this code.\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc#newcode298\nmedia/base/user_input_monitor_win.cc:298: UserInputMonitorWin::~UserInputMonitorWin() {\nnit: empty lines between methods please.","disapproval":false,"date":"2013-09-10 18:28:38.938900","approval":true},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc#newcode40\nmedia/base/user_input_monitor_win.cc:40: // Private interface of UserInputMonitor.\nOn 2013/09/10 18:28:39, Sergey Ulanov wrote:\n> nit: It's more common to say something like \"UserInputMonitor overrides\".\n> UserInputMonitor is not an interface, so this comment may be confusing.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc#newcode44\nmedia/base/user_input_monitor_win.cc:44: class Core;\nOn 2013/09/10 18:28:39, Sergey Ulanov wrote:\n> nit: class declaration should be before the methods.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/50001/media/base/user_input_monitor_win.cc#newcode298\nmedia/base/user_input_monitor_win.cc:298: UserInputMonitorWin::~UserInputMonitorWin() {\nOn 2013/09/10 18:28:39, Sergey Ulanov wrote:\n> nit: empty lines between methods please.\n\nDone.","disapproval":false,"date":"2013-09-10 18:34:15.000400","approval":false},{"sender":"wez@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode62\nmedia/base/user_input_monitor_linux.cc:62: class UserInputMonitorLinux::Core : public base::MessagePumpLibevent::Watcher {\nnit: If you rename this UserInputMonitorLinuxCore and define it before UserInputMonitorLinux, above, then you can avoid needing to forward-define it in UIML's private section.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode103\nmedia/base/user_input_monitor_linux.cc:103: Display* display_;\nnit: Suggest |display_control_| and |display_record_| for these, to make it clearer why you need two.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode127\nmedia/base/user_input_monitor_linux.cc:127: DCHECK_EQ(0u, mouse_listeners_count_);\nnit: You could also mouse_listeners_.AssertEmpty() here if you want.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: {\nIf you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main class, and keep a copy of |io_task_runner_| there as well then you can move the lock/increment/post logic back to the outer class.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode140\nmedia/base/user_input_monitor_linux.cc:140: mouse_listeners_count_++;\nWhy not keep this count on the IO thread, and increment/decrement when processing Start/StopMonitor()? Then you wouldn't need the lock.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode171\nmedia/base/user_input_monitor_linux.cc:171: void UserInputMonitorLinux::Core::StartKeyboardMonitoring() {\nIf you move |weak_factory_| into the outer class, and keep a copy of |io_task_runner_| there then you don't need these boilerplate methods - you can Bind() to Start/StopMonitor directly from StartKeyboardMonitoring instead.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode189\nmedia/base/user_input_monitor_linux.cc:189: counter_.Reset();\nYou're resetting the counter every time StartKeyboardMonitoring() is called - doesn't that mean that if you get multiple calls then earlier callers might be confused by the event count being reset when later callers start monitoring?\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_win.cc#newcode52\nmedia/base/user_input_monitor_win.cc:52: class UserInputMonitorWin::Core {\nSee comment on Linux impl\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_win.cc#newcode88\nmedia/base/user_input_monitor_win.cc:88: size_t mouse_listeners_count_;\nSee comments on Linux impl","disapproval":false,"date":"2013-09-10 21:09:00.128750","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"PTAL. Thanks!\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode62\nmedia/base/user_input_monitor_linux.cc:62: class UserInputMonitorLinux::Core : public base::MessagePumpLibevent::Watcher {\nOn 2013/09/10 21:09:00, Wez wrote:\n> nit: If you rename this UserInputMonitorLinuxCore and define it before\n> UserInputMonitorLinux, above, then you can avoid needing to forward-define it in\n> UIML's private section.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode103\nmedia/base/user_input_monitor_linux.cc:103: Display* display_;\nOn 2013/09/10 21:09:00, Wez wrote:\n> nit: Suggest |display_control_| and |display_record_| for these, to make it\n> clearer why you need two.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode127\nmedia/base/user_input_monitor_linux.cc:127: DCHECK_EQ(0u, mouse_listeners_count_);\nOn 2013/09/10 21:09:00, Wez wrote:\n> nit: You could also mouse_listeners_.AssertEmpty() here if you want.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: {\nOn 2013/09/10 21:09:00, Wez wrote:\n> If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> class, and keep a copy of |io_task_runner_| there as well then you can move the\n> lock/increment/post logic back to the outer class.\nlock is removed now; \"post\" cannot be done from the outer class because the listener list must be updated on the calling thread.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode140\nmedia/base/user_input_monitor_linux.cc:140: mouse_listeners_count_++;\nOn 2013/09/10 21:09:00, Wez wrote:\n> Why not keep this count on the IO thread, and increment/decrement when\n> processing Start/StopMonitor()? Then you wouldn't need the lock.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode171\nmedia/base/user_input_monitor_linux.cc:171: void UserInputMonitorLinux::Core::StartKeyboardMonitoring() {\nOn 2013/09/10 21:09:00, Wez wrote:\n> If you move |weak_factory_| into the outer class, and keep a copy of\n> |io_task_runner_| there then you don't need these boilerplate methods - you can\n> Bind() to Start/StopMonitor directly from StartKeyboardMonitoring instead.\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode189\nmedia/base/user_input_monitor_linux.cc:189: counter_.Reset();\nOn 2013/09/10 21:09:00, Wez wrote:\n> You're resetting the counter every time StartKeyboardMonitoring() is called -\n> doesn't that mean that if you get multiple calls then earlier callers might be\n> confused by the event count being reset when later callers start monitoring?\nThe base class makes sure that StartKeyboardMonitoring is only called for the first external caller, so the count is consistent for each caller.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_win.cc#newcode52\nmedia/base/user_input_monitor_win.cc:52: class UserInputMonitorWin::Core {\nOn 2013/09/10 21:09:00, Wez wrote:\n> See comment on Linux impl\n\nDone.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_win.cc#newcode88\nmedia/base/user_input_monitor_win.cc:88: size_t mouse_listeners_count_;\nOn 2013/09/10 21:09:00, Wez wrote:\n> See comments on Linux impl\n\nDone.","disapproval":false,"date":"2013-09-10 23:14:18.683850","approval":false},{"sender":"wez@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: {\nOn 2013/09/10 23:14:19, jiayl wrote:\n> On 2013/09/10 21:09:00, Wez wrote:\n> > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> > class, and keep a copy of |io_task_runner_| there as well then you can move\n> the\n> > lock/increment/post logic back to the outer class.\n> lock is removed now; \"post\" cannot be done from the outer class because the\n> listener list must be updated on the calling thread.\n\nSorry, I don't understand that logic.  Calling PostTask() in UserInputMonitor::AddMouseListener() immediately after core_->AddMouseListener() is equivalent to calling it here, surely?\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode189\nmedia/base/user_input_monitor_linux.cc:189: counter_.Reset();\nOn 2013/09/10 23:14:19, jiayl wrote:\n> On 2013/09/10 21:09:00, Wez wrote:\n> > You're resetting the counter every time StartKeyboardMonitoring() is called -\n> > doesn't that mean that if you get multiple calls then earlier callers might be\n> > confused by the event count being reset when later callers start monitoring?\n> The base class makes sure that StartKeyboardMonitoring is only called for the\n> first external caller, so the count is consistent for each caller. \n\nWhy not do the same for the mouse? i.e:\n\nAddMouseListener(listener) // adds the Observer\nLock\nmouse_listener_count_++\nif (mouse_listener_count == 1)\n  StartMonitor(MOUSE_TYPE);\nUnlock\n\nSo long as the counter increment/decrement & Start/Stop occur with the locked held this won't be racey.\n\nhttps://codereview.chromium.org/23702008/diff/65001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/65001/media/base/user_input_monitor_linux.cc#newcode58\nmedia/base/user_input_monitor_linux.cc:58: return weak_factory_.GetWeakPtr();\nYou can avoid this ugly WeakPtr getter by keeping the |weak_factory_| in UserInputMonitor and posting the OnMouseListenerAdded/Removed() tasks from its Add/RemoveMouseListener() methods.\n\nYou just have to remember to |weak_factory_.Invalidate()| in ~UserInputMonitor() before you call DeleteSoon() on the core.","disapproval":false,"date":"2013-09-11 08:03:42.336310","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: {\nOn 2013/09/11 08:03:42, Wez wrote:\n> On 2013/09/10 23:14:19, jiayl wrote:\n> > On 2013/09/10 21:09:00, Wez wrote:\n> > > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> > > class, and keep a copy of |io_task_runner_| there as well then you can move\n> > the\n> > > lock/increment/post logic back to the outer class.\n> > lock is removed now; \"post\" cannot be done from the outer class because the\n> > listener list must be updated on the calling thread.\n> \n> Sorry, I don't understand that logic.  Calling PostTask() in\n> UserInputMonitor::AddMouseListener() immediately after core_->AddMouseListener()\n> is equivalent to calling it here, surely?\nCore::AddMouseListener updates the listener list in the calling thread, not in the posted task. If we don't update the listener list in the calling thread, we may call into destroyed listener since the caller may destroy the listener immediately after calling RemoveListener.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode189\nmedia/base/user_input_monitor_linux.cc:189: counter_.Reset();\nOn 2013/09/11 08:03:42, Wez wrote:\n> On 2013/09/10 23:14:19, jiayl wrote:\n> > On 2013/09/10 21:09:00, Wez wrote:\n> > > You're resetting the counter every time StartKeyboardMonitoring() is called\n> -\n> > > doesn't that mean that if you get multiple calls then earlier callers might\n> be\n> > > confused by the event count being reset when later callers start monitoring?\n> > The base class makes sure that StartKeyboardMonitoring is only called for the\n> > first external caller, so the count is consistent for each caller. \n> \n> Why not do the same for the mouse? i.e:\n> \n> AddMouseListener(listener) // adds the Observer\n> Lock\n> mouse_listener_count_++\n> if (mouse_listener_count == 1)\n>   StartMonitor(MOUSE_TYPE);\n> Unlock\n> \n> So long as the counter increment/decrement & Start/Stop occur with the locked\n> held this won't be racey.\n\nWhat's the benefit? I see two shortcomings instead: 1. the listener count and the listener list will be scattered in two classes thus harder to maintain; 2. it reintroduces the lock that was removed in this patch.\n\nhttps://codereview.chromium.org/23702008/diff/65001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/65001/media/base/user_input_monitor_linux.cc#newcode58\nmedia/base/user_input_monitor_linux.cc:58: return weak_factory_.GetWeakPtr();\nOn 2013/09/11 08:03:42, Wez wrote:\n> You can avoid this ugly WeakPtr getter by keeping the |weak_factory_| in\n> UserInputMonitor and posting the OnMouseListenerAdded/Removed() tasks from its\n> Add/RemoveMouseListener() methods.\n> \n> You just have to remember to |weak_factory_.Invalidate()| in ~UserInputMonitor()\n> before you call DeleteSoon() on the core.\nTo reiterate why PostTask to IO thread from UserInputMonitor will not work:\n1. the listener list has to live in Core so that Core does not need to callback to UserInputMonitor. Calling back to UserInputMonitor is problematic because WeakPtr does not work across threads (i.e. UserInputMonitor will be deref'd on IO thread but invalidated on UI thread) and we don't want to add ref counting for UserInputMonitor.\n2. Because of #1, Core is responsible to update the listener list. It has to happen on the calling thread, since the caller may destroy the listener immediately after calling RemoveListener. So we cannot PostTask to IO thread from UserInputMonitor.","disapproval":false,"date":"2013-09-11 16:57:10.001020","approval":false},{"sender":"sergeyu@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Wez, I think it's better if we don't call X Window or Windows APIs with any lock. In the latest patch set they are always called without lock, but on the same thread.\n\nIf we call X Window with the lock held then we will also need to hold it when processing events, which would make it doing it correctly harder.","disapproval":false,"date":"2013-09-11 19:25:03.985320","approval":false},{"sender":"wez@chromium.org","recipients":["reply@chromiumcodereview-hr.appspotmail.com"],"text":"What I suggested was e.g. for AddMouseListener(MouseListener):\r\n\r\n  1.  Add MouseListener to thread-safe ObserverList.\r\n  2.  Take lock.\r\n  3.  If mouse listener count is zero then call platform-specific\r\nStartMonitor(MOUSE_EVENT), which re-posts StartMonitor(MOUSE_EVENT) to the\r\nmonitor thread.\r\n  4.  Increment mouse listener count.\r\n  5.  Release lock.\r\n\r\nAnd similarly for Remove*Listener().  OS calls will be processed on the\r\nmonitor thread, w/out the lock held.\r\n\r\n\r\nOn 11 September 2013 21:25, <sergeyu@chromium.org> wrote:\r\n\r\n> Wez, I think it's better if we don't call X Window or Windows APIs with any\r\n> lock. In the latest patch set they are always called without lock, but on\r\n> the\r\n> same thread.\r\n>\r\n> If we call X Window with the lock held then we will also need to hold it\r\n> when\r\n> processing events, which would make it doing it correctly harder.\r\n>\r\n> https://codereview.chromium.**org/23702008/<https://codereview.chromium.org/23702008/>\r\n>\r\n\r\nTo unsubscribe from this group and stop receiving emails from it, send an email to chromium-reviews+unsubscribe@chromium.org.\r\n","disapproval":false,"date":"2013-09-12 11:36:18.543020","approval":false},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Moved the common logic of adding/removing mouse listeners into the base class to avoid duplication. The observer list is now created by the base class and shared with Core so that callbacks do not through the base class.\nPTAL.\nThanks!","disapproval":false,"date":"2013-09-12 19:19:23.167140","approval":false},{"sender":"wez@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"LGTM but please see SupportsWeakPtr comments.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: {\nOn 2013/09/10 23:14:19, jiayl wrote:\n> On 2013/09/10 21:09:00, Wez wrote:\n> > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> > class, and keep a copy of |io_task_runner_| there as well then you can move\n> the\n> > lock/increment/post logic back to the outer class.\n> lock is removed now; \"post\" cannot be done from the outer class because the\n> listener list must be updated on the calling thread.\n\nTrue, you would need to add the observer from the outer class as well , before posting StartMonitor() to the Core.\n\nhttps://codereview.chromium.org/23702008/diff/3001/media/base/user_input_monitor_linux.cc#newcode138\nmedia/base/user_input_monitor_linux.cc:138: {\nOn 2013/09/11 16:57:10, jiayl wrote:\n> On 2013/09/11 08:03:42, Wez wrote:\n> > On 2013/09/10 23:14:19, jiayl wrote:\n> > > On 2013/09/10 21:09:00, Wez wrote:\n> > > > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the\n> main\n> > > > class, and keep a copy of |io_task_runner_| there as well then you can\n> move\n> > > the\n> > > > lock/increment/post logic back to the outer class.\n> > > lock is removed now; \"post\" cannot be done from the outer class because the\n> > > listener list must be updated on the calling thread.\n> > \n> > Sorry, I don't understand that logic.  Calling PostTask() in\n> > UserInputMonitor::AddMouseListener() immediately after\n> core_->AddMouseListener()\n> > is equivalent to calling it here, surely?\n> Core::AddMouseListener updates the listener list in the calling thread, not in\n> the posted task. If we don't update the listener list in the calling thread, we\n> may call into destroyed listener since the caller may destroy the listener\n> immediately after calling RemoveListener.\n\nYes, see above re updating the listener list from the outer class.\n\nhttps://codereview.chromium.org/23702008/diff/65001/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/65001/media/base/user_input_monitor_linux.cc#newcode58\nmedia/base/user_input_monitor_linux.cc:58: return weak_factory_.GetWeakPtr();\nOn 2013/09/11 16:57:10, jiayl wrote:\n> On 2013/09/11 08:03:42, Wez wrote:\n> > You can avoid this ugly WeakPtr getter by keeping the |weak_factory_| in\n> > UserInputMonitor and posting the OnMouseListenerAdded/Removed() tasks from its\n> > Add/RemoveMouseListener() methods.\n> > \n> > You just have to remember to |weak_factory_.Invalidate()| in\n> ~UserInputMonitor()\n> > before you call DeleteSoon() on the core.\n> To reiterate why PostTask to IO thread from UserInputMonitor will not work:\n> 1. the listener list has to live in Core so that Core does not need to callback\n> to UserInputMonitor. Calling back to UserInputMonitor is problematic because\n> WeakPtr does not work across threads (i.e. UserInputMonitor will be deref'd on\n> IO thread but invalidated on UI thread) and we don't want to add ref counting\n> for UserInputMonitor.\n> 2. Because of #1, Core is responsible to update the listener list. It has to\n> happen on the calling thread, since the caller may destroy the listener\n> immediately after calling RemoveListener. So we cannot PostTask to IO thread\n> from UserInputMonitor.\n\nYou could add the listener from UserInputMonitor, though, before posting the task.\n\nIt'd mean providing a scoped_refptr<> mouse_listeners() getter for UserInputMonitor to use, but since Core is an internal implementation detail, that seems reasonable, and it saves the boilerplate Add/RemoveMouseListener() and GetWeakPtr() calls on Core.\n\nYou'd need to re-instate the Lock around the mouse counter updates for that to work, but since that's how keyboard is handled, that doesn't seem unreasonable.\n\nhttps://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor.h\nFile media/base/user_input_monitor.h (right):\n\nhttps://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor.h#newcode81\nmedia/base/user_input_monitor.h:81: size_t mouse_listeners_count_;\nnit: Name these two counters consistently, e.g. mouse_monitor_count_, keyboard_monitor_count_\n\nhttps://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor_linux.cc#newcode41\nmedia/base/user_input_monitor_linux.cc:41: public base::SupportsWeakPtr<UserInputMonitorLinuxCore> {\nYou have to be careful using SupportsWeakPtr - WeakPtrs it dispenses are only invalidated when the base-class dtor runs, which only happens after the derived class and its members have been destroyed.\n\nI think it's cleaner here to have UserInputMonitorLinux create a WeakPtrFactory wrapping the Core, and to explicitly Invalidate() that before posting the deletion task for the Core.\n\nhttps://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor_win.cc\nFile media/base/user_input_monitor_win.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor_win.cc#newcode30\nmedia/base/user_input_monitor_win.cc:30: : public base::SupportsWeakPtr<UserInputMonitorWinCore> {\nSee comment on Linux impl re SupportsWeakPtr","disapproval":false,"date":"2013-09-13 10:01:26.593980","approval":true},{"sender":"jiayl@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"https://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor_linux.cc\nFile media/base/user_input_monitor_linux.cc (right):\n\nhttps://codereview.chromium.org/23702008/diff/20002/media/base/user_input_monitor_linux.cc#newcode41\nmedia/base/user_input_monitor_linux.cc:41: public base::SupportsWeakPtr<UserInputMonitorLinuxCore> {\nOn 2013/09/13 10:01:27, Wez wrote:\n> You have to be careful using SupportsWeakPtr - WeakPtrs it dispenses are only\n> invalidated when the base-class dtor runs, which only happens after the derived\n> class and its members have been destroyed.\n> \n> I think it's cleaner here to have UserInputMonitorLinux create a WeakPtrFactory\n> wrapping the Core, and to explicitly Invalidate() that before posting the\n> deletion task for the Core.\n\nI don't think WeakPtrFactory in UserInputMonitorLinux will work, because we need to invalidate it on the monitoring thread, thus PostTask from the dtor of UserInputMonitorLinux. But the reference to WeakPtrFactory will be immediately invalid because UserInputMonitorLinux is destroyed.\n\nSupportsWeakPtr should not a problem in this use case. The WeakPtr's are only used on the monitoring thread. It's dereferenced either before or after the Core is fully destructed on the monitoring thread, not in the middle. If DeleteSoon fails and the Core is deleted on the browser main thread, that means the monitoring thread does not exist anymore so it doesn't matter.","disapproval":false,"date":"2013-09-13 16:23:32.964430","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/jiayl@chromium.org/23702008/20002","disapproval":false,"date":"2013-09-13 16:31:02.380320","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/jiayl@chromium.org/23702008/82001","disapproval":false,"date":"2013-09-13 16:49:16.642780","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Retried try job too often on linux_chromeos for step(s) media_unittests\nhttp://build.chromium.org/p/tryserver.chromium/buildstatus?builder=linux_chromeos&number=154230","disapproval":false,"date":"2013-09-13 17:46:40.910050","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/jiayl@chromium.org/23702008/103001","disapproval":false,"date":"2013-09-13 17:52:48.817040","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Change committed as 223223","disapproval":false,"date":"2013-09-14 05:16:36.604680","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/jiayl@chromium.org/23702008/12001","disapproval":false,"date":"2013-09-14 16:56:19.171400","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/jiayl@chromium.org/23702008/119001","disapproval":false,"date":"2013-09-14 17:10:28.525170","approval":false},{"sender":"commit-bot@chromium.org","recipients":["jiayl@chromium.org","sergeyu@chromium.org","dalecurtis@chromium.org","wez@chromium.org","sky@chromium.org","chromium-reviews@chromium.org","feature-media-reviews@chromium.org","kjellander@chromium.org","niklase@chromium.org"],"text":"Change committed as 223260","disapproval":false,"date":"2013-09-14 21:28:12.246400","approval":false}],"owner_email":"jiayl@chromium.org","private":false,"base_url":"https://chromium.googlesource.com/chromium/src.git@master","owner":"jiayl","subject":"Adds the UserInputMonitor implementation for Windows.","created":"2013-08-28 23:00:09.508300","patchsets":[1,7001,8001,20001,34001,45001,50001,3001,65001,20002,82001,103001,12001,119001],"modified":"2013-09-14 21:28:13.116060","closed":true,"commit":false,"issue":23702008}