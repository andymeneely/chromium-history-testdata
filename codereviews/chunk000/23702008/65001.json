{"files":{"media/base/user_input_monitor_mac.cc":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":8,"num_removed":8,"messages":[],"id":49005,"is_binary":false},"media/base/user_input_monitor_linux.cc":{"status":"M","num_chunks":11,"no_base_file":false,"property_changes":"","num_added":158,"num_removed":91,"messages":[{"author":"Wez","author_email":"wez@chromium.org","text":"You can avoid this ugly WeakPtr getter by keeping the |weak_factory_| in UserInputMonitor and posting the OnMouseListenerAdded/Removed() tasks from its Add/RemoveMouseListener() methods.\n\nYou just have to remember to |weak_factory_.Invalidate()| in ~UserInputMonitor() before you call DeleteSoon() on the core.","draft":false,"lineno":58,"date":"2013-09-11 08:03:42.854270","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/11 08:03:42, Wez wrote:\n> You can avoid this ugly WeakPtr getter by keeping the |weak_factory_| in\n> UserInputMonitor and posting the OnMouseListenerAdded/Removed() tasks from its\n> Add/RemoveMouseListener() methods.\n> \n> You just have to remember to |weak_factory_.Invalidate()| in ~UserInputMonitor()\n> before you call DeleteSoon() on the core.\nTo reiterate why PostTask to IO thread from UserInputMonitor will not work:\n1. the listener list has to live in Core so that Core does not need to callback to UserInputMonitor. Calling back to UserInputMonitor is problematic because WeakPtr does not work across threads (i.e. UserInputMonitor will be deref'd on IO thread but invalidated on UI thread) and we don't want to add ref counting for UserInputMonitor.\n2. Because of #1, Core is responsible to update the listener list. It has to happen on the calling thread, since the caller may destroy the listener immediately after calling RemoveListener. So we cannot PostTask to IO thread from UserInputMonitor.\n\n","draft":false,"lineno":58,"date":"2013-09-11 16:57:10.508400","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"On 2013/09/11 16:57:10, jiayl wrote:\n> On 2013/09/11 08:03:42, Wez wrote:\n> > You can avoid this ugly WeakPtr getter by keeping the |weak_factory_| in\n> > UserInputMonitor and posting the OnMouseListenerAdded/Removed() tasks from its\n> > Add/RemoveMouseListener() methods.\n> > \n> > You just have to remember to |weak_factory_.Invalidate()| in\n> ~UserInputMonitor()\n> > before you call DeleteSoon() on the core.\n> To reiterate why PostTask to IO thread from UserInputMonitor will not work:\n> 1. the listener list has to live in Core so that Core does not need to callback\n> to UserInputMonitor. Calling back to UserInputMonitor is problematic because\n> WeakPtr does not work across threads (i.e. UserInputMonitor will be deref'd on\n> IO thread but invalidated on UI thread) and we don't want to add ref counting\n> for UserInputMonitor.\n> 2. Because of #1, Core is responsible to update the listener list. It has to\n> happen on the calling thread, since the caller may destroy the listener\n> immediately after calling RemoveListener. So we cannot PostTask to IO thread\n> from UserInputMonitor.\n\nYou could add the listener from UserInputMonitor, though, before posting the task.\n\nIt'd mean providing a scoped_refptr<> mouse_listeners() getter for UserInputMonitor to use, but since Core is an internal implementation detail, that seems reasonable, and it saves the boilerplate Add/RemoveMouseListener() and GetWeakPtr() calls on Core.\n\nYou'd need to re-instate the Lock around the mouse counter updates for that to work, but since that's how keyboard is handled, that doesn't seem unreasonable.","draft":false,"lineno":58,"date":"2013-09-13 10:01:27.433100","left":false}],"id":49004,"is_binary":false},"media/base/user_input_monitor.h":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":5,"num_removed":17,"messages":[],"id":49003,"is_binary":false},"media/base/user_input_monitor_unittest.cc":{"status":"A","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":72,"num_removed":0,"messages":[],"id":49006,"is_binary":false},"media/media.gyp":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":7,"num_removed":2,"messages":[],"id":49008,"is_binary":false},"media/base/user_input_monitor.cc":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":3,"num_removed":32,"messages":[],"id":49002,"is_binary":false},"media/base/user_input_monitor_win.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":321,"num_removed":3,"messages":[],"id":49007,"is_binary":false},"media/base/keyboard_event_counter.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":49001,"is_binary":false}},"owner_email":"jiayl@chromium.org","owner":"jiayl","message":" ","try_job_results":[],"created":"2013-09-10 23:10:55.537890","url":null,"num_comments":3,"modified":"2013-09-13 10:01:27.479050","patchset":65001,"issue":23702008}