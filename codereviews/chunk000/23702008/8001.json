{"files":{"media/media.gyp":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":7,"num_removed":2,"messages":[],"id":9004,"is_binary":false},"media/base/user_input_monitor_win.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":268,"num_removed":3,"messages":[{"author":"Wez","author_email":"wez@chromium.org","text":"nit: Suggest comment \"UserInputMonitor public interface\"","draft":false,"lineno":31,"date":"2013-09-03 20:07:04.568040","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"nit: |target_events| -> |event_mask| to make it clearer that this should be a combination of EventBitMask values? Or add a comment to explain the method's usage.","draft":false,"lineno":38,"date":"2013-09-03 20:07:04.568410","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"nit: Suggest comment \"UserInputMonitor private interface\" to introduce this block.","draft":false,"lineno":40,"date":"2013-09-03 20:07:04.568720","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"If you make this return std::vector<RAWINPUTDEVICE> then you don't end up returning a bare pointer, and you fold NummberOfRawInputDevices() into GetRawInputDevices.\n\n(If you're worried about the vector copying overhead it could return a scoped_ptr<std::vector<...> >)","draft":false,"lineno":59,"date":"2013-09-03 20:07:04.568980","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"If all the methods above are called only on the UI message loop, and all these members are called only on the UI thread, why do you need these comments?","draft":false,"lineno":65,"date":"2013-09-03 20:07:04.569160","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"This will use-after-free if the StartMouseMonitoring() is called, and the caller then deletes the UserInputMonitor immediately on the calling thread, since the task will still be processed on the UI thread.\n","draft":false,"lineno":101,"date":"2013-09-03 20:07:04.569340","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"This path will never be hit unless the caller is also on the UI thread. Better to have the PostTask, above, re-post StartMouseMonitoring().","draft":false,"lineno":105,"date":"2013-09-03 20:07:04.569520","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"nit: I prefer pre-condition DCHECKs to be followed by a blank line before the rest of the method logic, for ease of readability.","draft":false,"lineno":142,"date":"2013-09-03 20:07:04.569740","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"Why re-create the window every time a new event is requested? Can't you just create the window if |events_monitored_| was empty, and call RegisterRawInputDevices() to start it receiving events?\n\nYou're also never un-registering for notifications to the old window.","draft":false,"lineno":151,"date":"2013-09-03 20:07:04.569960","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"Clarify that |window_| may be NULL if we failed to monitor events.\n","draft":false,"lineno":165,"date":"2013-09-03 20:07:04.570180","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"Which error? Why not trap & at least LOG_SYSERR(WARNING) it?","draft":false,"lineno":169,"date":"2013-09-03 20:07:04.570380","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"nit: Verify that |result| is not greater than zero here, or some other -ve value than -1?","draft":false,"lineno":183,"date":"2013-09-03 20:07:04.570580","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"nit: See above re verifying |result|","draft":false,"lineno":194,"date":"2013-09-03 20:07:04.570880","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"Have you checked the semantics if e.g. two separate calls are made to RegisterRawInputDevices() that direct the same type of input to different windows, to know how this will interact w/ other users of the API in Chrome?","draft":false,"lineno":230,"date":"2013-09-03 20:07:04.571170","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> This will use-after-free if the StartMouseMonitoring() is called, and the caller\n> then deletes the UserInputMonitor immediately on the calling thread, since the\n> task will still be processed on the UI thread.\n\nYou are right. I was assuming the caller should make sure UserInputMonitor is not deleted too early, but that seems not a good assumption. I'm going to change UserInputMonitor to ref counted. WeakPtr won't work since UserInputMonitor is destroyed and called back on different threads.","draft":false,"lineno":101,"date":"2013-09-03 21:41:28.668460","left":false},{"author":"DaleCurtis","author_email":"dalecurtis@chromium.org","text":"On 2013/09/03 21:41:28, jiayl wrote:\n> On 2013/09/03 20:07:04, Wez wrote:\n> > This will use-after-free if the StartMouseMonitoring() is called, and the\n> caller\n> > then deletes the UserInputMonitor immediately on the calling thread, since the\n> > task will still be processed on the UI thread.\n> \n> You are right. I was assuming the caller should make sure UserInputMonitor is\n> not deleted too early, but that seems not a good assumption. I'm going to change\n> UserInputMonitor to ref counted. WeakPtr won't work since UserInputMonitor is\n> destroyed and called back on different threads.\n\nIsn't it invalid for a client to call StartMouseMonitoring() then delete without calling StopMouseMonitoring() ? If we can avoid ref-counting anything that'd be great.","draft":false,"lineno":101,"date":"2013-09-03 22:59:32.828250","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> nit: Suggest comment \"UserInputMonitor public interface\"\n\nDone.","draft":false,"lineno":31,"date":"2013-09-03 23:44:12.921260","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> nit: |target_events| -> |event_mask| to make it clearer that this should be a\n> combination of EventBitMask values? Or add a comment to explain the method's\n> usage.\n\nDone.","draft":false,"lineno":38,"date":"2013-09-03 23:44:12.921560","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> block.\n\nDone.","draft":false,"lineno":40,"date":"2013-09-03 23:44:12.921890","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> nit: Suggest comment \"UserInputMonitor private interface\" to introduce this\n> block.\n\nDone.","draft":false,"lineno":40,"date":"2013-09-03 23:44:12.922200","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> If you make this return std::vector<RAWINPUTDEVICE> then you don't end up\n> returning a bare pointer, and you fold NummberOfRawInputDevices() into\n> GetRawInputDevices.\n> \n> (If you're worried about the vector copying overhead it could return a\n> scoped_ptr<std::vector<...> >)\n\nDone.","draft":false,"lineno":59,"date":"2013-09-03 23:44:12.922480","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> If all the methods above are called only on the UI message loop, and all these\n> members are called only on the UI thread, why do you need these comments?\n\nDone.","draft":false,"lineno":65,"date":"2013-09-03 23:44:12.922740","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> This will use-after-free if the StartMouseMonitoring() is called, and the caller\n> then deletes the UserInputMonitor immediately on the calling thread, since the\n> task will still be processed on the UI thread.\n\nDone.","draft":false,"lineno":101,"date":"2013-09-03 23:44:12.923050","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> This path will never be hit unless the caller is also on the UI thread. Better\n> to have the PostTask, above, re-post StartMouseMonitoring().\n\nDone.","draft":false,"lineno":105,"date":"2013-09-03 23:44:12.923310","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> nit: I prefer pre-condition DCHECKs to be followed by a blank line before the\n> rest of the method logic, for ease of readability.\n\nDone.","draft":false,"lineno":142,"date":"2013-09-03 23:44:12.923580","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> Why re-create the window every time a new event is requested? Can't you just\n> create the window if |events_monitored_| was empty, and call\n> RegisterRawInputDevices() to start it receiving events?\n> \n> You're also never un-registering for notifications to the old window.\n\nDone.","draft":false,"lineno":151,"date":"2013-09-03 23:44:12.923870","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> Clarify that |window_| may be NULL if we failed to monitor events.\n\nDone.","draft":false,"lineno":165,"date":"2013-09-03 23:44:12.924130","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> Which error? Why not trap & at least LOG_SYSERR(WARNING) it?\n\nDone.","draft":false,"lineno":169,"date":"2013-09-03 23:44:12.924390","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> nit: Verify that |result| is not greater than zero here, or some other -ve value\n> than -1?\n\nDone.","draft":false,"lineno":183,"date":"2013-09-03 23:44:12.924650","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> nit: See above re verifying |result|\n\nDone.","draft":false,"lineno":194,"date":"2013-09-03 23:44:12.924930","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/03 20:07:04, Wez wrote:\n> Have you checked the semantics if e.g. two separate calls are made to\n> RegisterRawInputDevices() that direct the same type of input to different\n> windows, to know how this will interact w/ other users of the API in Chrome?\nHmm...I verified that only one window will receive the event if multiple ones are registered. Chrome has no other callers though. \n","draft":false,"lineno":230,"date":"2013-09-03 23:44:12.925210","left":false}],"id":9003,"is_binary":false},"media/base/user_input_monitor_unittest.cc":{"status":"A","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":116,"num_removed":0,"messages":[],"id":9002,"is_binary":false},"media/base/keyboard_event_counter.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":9001,"is_binary":false}},"owner_email":"jiayl@chromium.org","owner":"jiayl","message":" ","try_job_results":[],"created":"2013-08-29 21:05:19.811250","url":null,"num_comments":31,"modified":"2013-09-03 23:44:13.004240","patchset":8001,"issue":23702008}