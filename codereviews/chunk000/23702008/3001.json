{"files":{"media/base/user_input_monitor_mac.cc":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":8,"num_removed":8,"messages":[],"id":57005,"is_binary":false},"media/base/user_input_monitor_linux.cc":{"status":"M","num_chunks":10,"no_base_file":false,"property_changes":"","num_added":129,"num_removed":66,"messages":[{"author":"Wez","author_email":"wez@chromium.org","text":"nit: If you rename this UserInputMonitorLinuxCore and define it before UserInputMonitorLinux, above, then you can avoid needing to forward-define it in UIML's private section.","draft":false,"lineno":62,"date":"2013-09-10 21:09:00.693520","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"nit: Suggest |display_control_| and |display_record_| for these, to make it clearer why you need two.","draft":false,"lineno":103,"date":"2013-09-10 21:09:00.693710","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"nit: You could also mouse_listeners_.AssertEmpty() here if you want.","draft":false,"lineno":127,"date":"2013-09-10 21:09:00.693900","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main class, and keep a copy of |io_task_runner_| there as well then you can move the lock/increment/post logic back to the outer class.","draft":false,"lineno":138,"date":"2013-09-10 21:09:00.694080","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"Why not keep this count on the IO thread, and increment/decrement when processing Start/StopMonitor()? Then you wouldn't need the lock.","draft":false,"lineno":140,"date":"2013-09-10 21:09:00.694320","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"If you move |weak_factory_| into the outer class, and keep a copy of |io_task_runner_| there then you don't need these boilerplate methods - you can Bind() to Start/StopMonitor directly from StartKeyboardMonitoring instead.","draft":false,"lineno":171,"date":"2013-09-10 21:09:00.694500","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"You're resetting the counter every time StartKeyboardMonitoring() is called - doesn't that mean that if you get multiple calls then earlier callers might be confused by the event count being reset when later callers start monitoring?","draft":false,"lineno":189,"date":"2013-09-10 21:09:00.694680","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> nit: If you rename this UserInputMonitorLinuxCore and define it before\n> UserInputMonitorLinux, above, then you can avoid needing to forward-define it in\n> UIML's private section.\n\nDone.","draft":false,"lineno":62,"date":"2013-09-10 23:14:19.447800","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> nit: Suggest |display_control_| and |display_record_| for these, to make it\n> clearer why you need two.\n\nDone.","draft":false,"lineno":103,"date":"2013-09-10 23:14:19.448210","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> nit: You could also mouse_listeners_.AssertEmpty() here if you want.\n\nDone.","draft":false,"lineno":127,"date":"2013-09-10 23:14:19.448630","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> class, and keep a copy of |io_task_runner_| there as well then you can move the\n> lock/increment/post logic back to the outer class.\nlock is removed now; \"post\" cannot be done from the outer class because the listener list must be updated on the calling thread.\n","draft":false,"lineno":138,"date":"2013-09-10 23:14:19.449070","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> Why not keep this count on the IO thread, and increment/decrement when\n> processing Start/StopMonitor()? Then you wouldn't need the lock.\n\nDone.","draft":false,"lineno":140,"date":"2013-09-10 23:14:19.449460","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> If you move |weak_factory_| into the outer class, and keep a copy of\n> |io_task_runner_| there then you don't need these boilerplate methods - you can\n> Bind() to Start/StopMonitor directly from StartKeyboardMonitoring instead.\n\nDone.","draft":false,"lineno":171,"date":"2013-09-10 23:14:19.449920","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> You're resetting the counter every time StartKeyboardMonitoring() is called -\n> doesn't that mean that if you get multiple calls then earlier callers might be\n> confused by the event count being reset when later callers start monitoring?\nThe base class makes sure that StartKeyboardMonitoring is only called for the first external caller, so the count is consistent for each caller. \n","draft":false,"lineno":189,"date":"2013-09-10 23:14:19.450330","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"On 2013/09/10 23:14:19, jiayl wrote:\n> On 2013/09/10 21:09:00, Wez wrote:\n> > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> > class, and keep a copy of |io_task_runner_| there as well then you can move\n> the\n> > lock/increment/post logic back to the outer class.\n> lock is removed now; \"post\" cannot be done from the outer class because the\n> listener list must be updated on the calling thread.\n\nSorry, I don't understand that logic.  Calling PostTask() in UserInputMonitor::AddMouseListener() immediately after core_->AddMouseListener() is equivalent to calling it here, surely?","draft":false,"lineno":138,"date":"2013-09-11 08:03:42.768650","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"On 2013/09/10 23:14:19, jiayl wrote:\n> On 2013/09/10 21:09:00, Wez wrote:\n> > You're resetting the counter every time StartKeyboardMonitoring() is called -\n> > doesn't that mean that if you get multiple calls then earlier callers might be\n> > confused by the event count being reset when later callers start monitoring?\n> The base class makes sure that StartKeyboardMonitoring is only called for the\n> first external caller, so the count is consistent for each caller. \n\nWhy not do the same for the mouse? i.e:\n\nAddMouseListener(listener) // adds the Observer\nLock\nmouse_listener_count_++\nif (mouse_listener_count == 1)\n  StartMonitor(MOUSE_TYPE);\nUnlock\n\nSo long as the counter increment/decrement & Start/Stop occur with the locked held this won't be racey.","draft":false,"lineno":189,"date":"2013-09-11 08:03:42.768870","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/11 08:03:42, Wez wrote:\n> On 2013/09/10 23:14:19, jiayl wrote:\n> > On 2013/09/10 21:09:00, Wez wrote:\n> > > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> > > class, and keep a copy of |io_task_runner_| there as well then you can move\n> > the\n> > > lock/increment/post logic back to the outer class.\n> > lock is removed now; \"post\" cannot be done from the outer class because the\n> > listener list must be updated on the calling thread.\n> \n> Sorry, I don't understand that logic.  Calling PostTask() in\n> UserInputMonitor::AddMouseListener() immediately after core_->AddMouseListener()\n> is equivalent to calling it here, surely?\nCore::AddMouseListener updates the listener list in the calling thread, not in the posted task. If we don't update the listener list in the calling thread, we may call into destroyed listener since the caller may destroy the listener immediately after calling RemoveListener.\n","draft":false,"lineno":138,"date":"2013-09-11 16:57:10.418390","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/11 08:03:42, Wez wrote:\n> On 2013/09/10 23:14:19, jiayl wrote:\n> > On 2013/09/10 21:09:00, Wez wrote:\n> > > You're resetting the counter every time StartKeyboardMonitoring() is called\n> -\n> > > doesn't that mean that if you get multiple calls then earlier callers might\n> be\n> > > confused by the event count being reset when later callers start monitoring?\n> > The base class makes sure that StartKeyboardMonitoring is only called for the\n> > first external caller, so the count is consistent for each caller. \n> \n> Why not do the same for the mouse? i.e:\n> \n> AddMouseListener(listener) // adds the Observer\n> Lock\n> mouse_listener_count_++\n> if (mouse_listener_count == 1)\n>   StartMonitor(MOUSE_TYPE);\n> Unlock\n> \n> So long as the counter increment/decrement & Start/Stop occur with the locked\n> held this won't be racey.\n\nWhat's the benefit? I see two shortcomings instead: 1. the listener count and the listener list will be scattered in two classes thus harder to maintain; 2. it reintroduces the lock that was removed in this patch.","draft":false,"lineno":189,"date":"2013-09-11 16:57:10.418620","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"On 2013/09/10 23:14:19, jiayl wrote:\n> On 2013/09/10 21:09:00, Wez wrote:\n> > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the main\n> > class, and keep a copy of |io_task_runner_| there as well then you can move\n> the\n> > lock/increment/post logic back to the outer class.\n> lock is removed now; \"post\" cannot be done from the outer class because the\n> listener list must be updated on the calling thread.\n\nTrue, you would need to add the observer from the outer class as well , before posting StartMonitor() to the Core.","draft":false,"lineno":138,"date":"2013-09-13 10:01:27.133510","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"On 2013/09/11 16:57:10, jiayl wrote:\n> On 2013/09/11 08:03:42, Wez wrote:\n> > On 2013/09/10 23:14:19, jiayl wrote:\n> > > On 2013/09/10 21:09:00, Wez wrote:\n> > > > If you move |lock_|, |mouse_listeners_count_|, |weak_factory_| into the\n> main\n> > > > class, and keep a copy of |io_task_runner_| there as well then you can\n> move\n> > > the\n> > > > lock/increment/post logic back to the outer class.\n> > > lock is removed now; \"post\" cannot be done from the outer class because the\n> > > listener list must be updated on the calling thread.\n> > \n> > Sorry, I don't understand that logic.  Calling PostTask() in\n> > UserInputMonitor::AddMouseListener() immediately after\n> core_->AddMouseListener()\n> > is equivalent to calling it here, surely?\n> Core::AddMouseListener updates the listener list in the calling thread, not in\n> the posted task. If we don't update the listener list in the calling thread, we\n> may call into destroyed listener since the caller may destroy the listener\n> immediately after calling RemoveListener.\n\nYes, see above re updating the listener list from the outer class.","draft":false,"lineno":138,"date":"2013-09-13 10:01:27.133700","left":false}],"id":57004,"is_binary":false},"media/base/user_input_monitor.h":{"status":"M","num_chunks":4,"no_base_file":false,"property_changes":"","num_added":5,"num_removed":17,"messages":[],"id":57003,"is_binary":false},"media/base/user_input_monitor_unittest.cc":{"status":"A","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":72,"num_removed":0,"messages":[],"id":57006,"is_binary":false},"media/media.gyp":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":7,"num_removed":2,"messages":[],"id":57008,"is_binary":false},"media/base/user_input_monitor.cc":{"status":"M","num_chunks":3,"no_base_file":false,"property_changes":"","num_added":3,"num_removed":32,"messages":[],"id":57002,"is_binary":false},"media/base/user_input_monitor_win.cc":{"status":"M","num_chunks":1,"no_base_file":false,"property_changes":"","num_added":319,"num_removed":3,"messages":[{"author":"Wez","author_email":"wez@chromium.org","text":"See comment on Linux impl","draft":false,"lineno":52,"date":"2013-09-10 21:09:00.694860","left":false},{"author":"Wez","author_email":"wez@chromium.org","text":"See comments on Linux impl","draft":false,"lineno":88,"date":"2013-09-10 21:09:00.695070","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> See comment on Linux impl\n\nDone.","draft":false,"lineno":52,"date":"2013-09-10 23:14:19.450740","left":false},{"author":"jiayl","author_email":"jiayl@chromium.org","text":"On 2013/09/10 21:09:00, Wez wrote:\n> See comments on Linux impl\n\nDone.","draft":false,"lineno":88,"date":"2013-09-10 23:14:19.451110","left":false}],"id":57007,"is_binary":false},"media/base/keyboard_event_counter.h":{"status":"M","num_chunks":2,"no_base_file":false,"property_changes":"","num_added":2,"num_removed":1,"messages":[],"id":57001,"is_binary":false}},"owner_email":"jiayl@chromium.org","owner":"jiayl","message":" ","try_job_results":[],"created":"2013-09-10 18:33:20.805700","url":null,"num_comments":24,"modified":"2013-09-13 10:01:27.249970","patchset":3001,"issue":23702008}