{"description":"Merge cc initialization paths\n\nCode path between first initialization and recreate on context\nlost are merged. Do this by changing the first initialization\nbehavior to match recreate. Now both are kicked off by the\nscheduler and blocks the main thread on the impl thread.\n\nThe scheduler is started in output surface lost state and\nimmediately schedules recreation. This means the first\ninitialization in thread mode is no longer synchronous.\n\nBUG=233664, 230197\nThis has been tried many many times.\nNOTRY=true\n\nReverted twice due to breaking WebGLInfobarTest:\nCommitted in r196480. Reverted in r196509.\nCommitted in r196708. Reverted in r196790.\nFix for WebGLInfobarTest landed in r197235.\n\nWebViewTest.Shim became flaky on chromeos but was already\nflaky without this. Disabled it in r197497.\n\nCommitted: https://src.chromium.org/viewvc/chrome?view=rev&revision=197550","cc":["chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"reviewers":["jamesr@chromium.org","danakj@chromium.org"],"messages":[{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Hey James,\n\nThis is the initial still incomplete patch to move cc::Renderer::Initialize inside onTimerTick so that it's called inside draw functor for android webview. Accomplished by adding a state to OutputSurfaceState and an initialize renderer action called inside vsync.\n\nRegarding perf regression, I was thinking instead of waiting for the next tick, we can add something like TimeSource::ForceTick and just shortcut it for DelayBasedTimeSource.\n\nDoes this look like something acceptable?","disapproval":false,"date":"2013-03-25 23:12:02.468320","approval":false},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Holding the main thread blocked until the first vsync is going to be too slow, if that's what you are trying to implement.  I think a better direction would be to make renderer initialization asynchronous.","disapproval":false,"date":"2013-03-25 23:16:46.515520","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"James, could you point me some perf tests that would affected by changing code here? A link to a set of tests on a perf bot would be good.","disapproval":false,"date":"2013-03-27 19:36:28.030510","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Hey James, could you take a look at the description of this CL and see if the direction I'm going down is ok? (I guess on Monday)\n\nNow on start up, main thread is no longer blocked until the first vsync, but I can't really make sure webkit does not start calling methods on LTH before it's ready. Nothing goes wrong in practice on desktop linux though.\n\nRecreateOutputSurface is still synchronous and has to wait for the next vsync, because it seemed too hard to make that async.\n\nDo you feel it's worthwhile to add a setting for this behavior given only webview has this requirement that can potentially have perf impact on all platforms.","disapproval":false,"date":"2013-03-30 01:46:20.621180","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/03/30 01:46:20, boliu wrote:\n> Hey James, could you take a look at the description of this CL and see if the\n> direction I'm going down is ok? (I guess on Monday)\n> \n> Now on start up, main thread is no longer blocked until the first vsync, but I\n> can't really make sure webkit does not start calling methods on LTH before it's\n> ready. Nothing goes wrong in practice on desktop linux though.\n> \n> RecreateOutputSurface is still synchronous and has to wait for the next vsync,\n> because it seemed too hard to make that async.\n> \n> Do you feel it's worthwhile to add a setting for this behavior given only\n> webview has this requirement that can potentially have perf impact on all\n> platforms.\n\nping! ^^^","disapproval":false,"date":"2013-04-01 23:43:04.398600","approval":false},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Is there something specific you want me to look at?  This looks incomplete, but I think that's expected.  Here are a few questions:\n\nIt doesn't look like the case where the initialization fails on the first try is handled here, is it?\n\nI don't think we want to have separate paths for creation and recreation, but I suspect you're still working on unifying those, right?\n\nIn this new initialization path the capabilities are not set after the initial blocking init happens.  Is that OK?  Is anything likely to query the capabilities early and if so is there any mechanism to prevent that?","disapproval":false,"date":"2013-04-02 22:42:08.049070","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/02 22:42:08, jamesr wrote:\n> Is there something specific you want me to look at?\n\nJust the general direction this patch is going. So mainly scheduler, scheduler_state_machine, and how it interacts with thread_proxy.\n\n> This looks incomplete, but\n> I think that's expected.  Here are a few questions:\n\nWow, great questions. I'm running into them as I was working through crashing/failing tests. (Great tests btw)\n\n> \n> It doesn't look like the case where the initialization fails on the first try is\n> handled here, is it?\n\nIt would call into LayerTreeHost::OnRendererInitialized(false). It's still incomplete. So far it's called if Renderer::Initialize fails, but not for OutputSurface::BindToClient. Also it should trigger output lost path in scheduler.\n\n> \n> I don't think we want to have separate paths for creation and recreation, but I\n> suspect you're still working on unifying those, right?\n\nCurrently they are the same in schduler/state_machine, but diverges in between LTH and Proxy, since recreate is sync.\n\nLooking at the code again, I'm now slightly confused about what triggers a recreate.\n1) call LayerTreeHost::InitializeRendererIfNeeded when a method on webkit thread needs the output surface, ie CompositeAndReadback. Blocks until everything recreated. But that only works in ThreadProxy if:\n2) Check output surface lost already detected in ThreadProxy::CheckOutputSurfaceStatusOnImplThread, which kicks off a chain of recreate attempts.\n\nSo I'm guessing 1) is used in single thread mode and 2) threaded mode? 1) blocks in ThreadProxy which I thought was weird because it ignores the recreate attempts started by the scheduler (or am I reading the code wrong?).\n\nI think the paths can be more unified if in threaded mode, 1) only checks but not block.\n\n> \n> In this new initialization path the capabilities are not set after the initial\n> blocking init happens.  Is that OK?  Is anything likely to query the\n> capabilities early and if so is there any mechanism to prevent that?\n\nYes it is a problem, at least in tests. I'm thinking of blocking at the places where the capabilities are needed, but the code in my head feels horrible.\n\nReplace \"DCHECK(has_renderer_capabilities)\" with\nif (!has_renderer_capabilities)\n  renderer_initialized_.Wait()\n\nThen when renderer is first initialized on impl thread:\nrenderer_initialized_.Signal()\nMainThread->PostTask(RendererInitalized) // Will cancell/noop if already initialized\n\nFeels super hacky, but I can't think of anything else. WDYT?\n\nAnd finally LayerTreeHostClient::DidInitializeRenderer is going away. Tests should work as is without it.","disapproval":false,"date":"2013-04-02 23:57:15.519020","approval":false},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/02 23:57:15, boliu wrote:\n> On 2013/04/02 22:42:08, jamesr wrote:\n> > Is there something specific you want me to look at?\n> \n> Just the general direction this patch is going. So mainly scheduler,\n> scheduler_state_machine, and how it interacts with thread_proxy.\n> \n> > This looks incomplete, but\n> > I think that's expected.  Here are a few questions:\n> \n> Wow, great questions. I'm running into them as I was working through\n> crashing/failing tests. (Great tests btw)\n> \n> > \n> > It doesn't look like the case where the initialization fails on the first try\n> is\n> > handled here, is it?\n> \n> It would call into LayerTreeHost::OnRendererInitialized(false). It's still\n> incomplete. So far it's called if Renderer::Initialize fails, but not for\n> OutputSurface::BindToClient. Also it should trigger output lost path in\n> scheduler.\n\nIt should be OK to treat a deferred context initialization failure in the same way as a lost context, but they aren't idential today.  I suspect you'll hit this in a number of tests, etc, but I'm not aware of any concrete thing that will definitely break if we change this.  Just be aware that it's different.\n\n> \n> > \n> > I don't think we want to have separate paths for creation and recreation, but\n> I\n> > suspect you're still working on unifying those, right?\n> \n> Currently they are the same in schduler/state_machine, but diverges in between\n> LTH and Proxy, since recreate is sync.\n> \n> Looking at the code again, I'm now slightly confused about what triggers a\n> recreate.\n> 1) call LayerTreeHost::InitializeRendererIfNeeded when a method on webkit thread\n> needs the output surface, ie CompositeAndReadback. Blocks until everything\n> recreated. But that only works in ThreadProxy if:\n> 2) Check output surface lost already detected in\n> ThreadProxy::CheckOutputSurfaceStatusOnImplThread, which kicks off a chain of\n> recreate attempts.\n> \n> So I'm guessing 1) is used in single thread mode and 2) threaded mode? 1) blocks\n> in ThreadProxy which I thought was weird because it ignores the recreate\n> attempts started by the scheduler (or am I reading the code wrong?).\n> \n> I think the paths can be more unified if in threaded mode, 1) only checks but\n> not block.\n\nYou're correct that the single-thread and threaded paths are not entirely the same.  We normally just let the compositor thread detect a lost context and trigger the ThreadProxy recreation logic, but in the case where we need a synchronous response (i.e. CompositeAndReadback) the webkit thread blocks until the context is created.  It's not ignoring the scheduler so much as blocking until the scheduler makes it past a certain point.  I don't think CompositeAndReadback() can ever be called for webview, so I think we'll just have to live with the fact that it needs to run even if we don't have a vsync tick.  It's a special case.\n\nIgnoring for a moment the CompositeAndReadback case, I think your understanding is correct.  The ThreadProxy checks for lost contexts and, if necessary, triggers the recreation logic.\n\n> \n> > \n> > In this new initialization path the capabilities are not set after the initial\n> > blocking init happens.  Is that OK?  Is anything likely to query the\n> > capabilities early and if so is there any mechanism to prevent that?\n> \n> Yes it is a problem, at least in tests. I'm thinking of blocking at the places\n> where the capabilities are needed, but the code in my head feels horrible.\n\nI *think* it's the case that only tests depend on renderer_capabilities being up to date before we call ThreadProxy::BeginFrame, and if so we should simply rework the tests.  We shouldn't add blocking logic in production code unless we have a concrete and understood need for it.  However, I'm not sure of what production code might need access to the capabilities.  Have you found any?   If you do, we'll have to look at them case-by-case to figure out what the requirement is.\n\n> \n> Replace \"DCHECK(has_renderer_capabilities)\" with\n> if (!has_renderer_capabilities)\n>   renderer_initialized_.Wait()\n> \n> Then when renderer is first initialized on impl thread:\n> renderer_initialized_.Signal()\n> MainThread->PostTask(RendererInitalized) // Will cancell/noop if already\n> initialized\n> \n> Feels super hacky, but I can't think of anything else. WDYT?\n> \n> And finally LayerTreeHostClient::DidInitializeRenderer is going away. Tests\n> should work as is without it.","disapproval":false,"date":"2013-04-03 00:17:01.642170","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Question about retrying recreate logic. What is it trying to accomplish? The retry logic only applies in recreate case; if the first initialization fails, then we fallback to software immediately. And then there's this scary looking comment:\n\n// Tolerate a certain number of recreation failures to work around races\n// in the output-surface-lost machinery.\n\nIn threaded mode, if recreate depends on vsync, then 5 failures would take 5 x 16 = 80ms. That's a lot of lost frames...","disapproval":false,"date":"2013-04-03 19:20:49.502850","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Hey James, could you take a look at layer_tree_host, single_thread_proxy, and thread_proxy.\n\nI tried to merge the initial create and recreate paths. The initial create and recreate logic diverge conditioned on has_renderer_capabilities_ variables.\n\nStill need to bring back synchronous recreate for ThreadProxy::CompositeAndReadback.\n\nThreadProxy::BeginFrame should not need to synchronous recreate since it's triggered by the scheduler, right?\n\nAlso the question below:\n\nOn 2013/04/03 19:20:49, boliu wrote:\n> Question about retrying recreate logic. What is it trying to accomplish? The\n> retry logic only applies in recreate case; if the first initialization fails,\n> then we fallback to software immediately. And then there's this scary looking\n> comment:\n> \n> // Tolerate a certain number of recreation failures to work around races\n> // in the output-surface-lost machinery.\n> \n> In threaded mode, if recreate depends on vsync, then 5 failures would take 5 x\n> 16 = 80ms. That's a lot of lost frames...","disapproval":false,"date":"2013-04-04 00:16:36.470240","approval":false},{"sender":"boliu@google.com","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Status update: Implementation probably correct since last few failing tests were due to some assumptions no longer hold. Only one failing test left. Code is a bit of a mess still.\n\nThis is growing to be a massive and complex patch...","disapproval":false,"date":"2013-04-09 02:10:59.026340","approval":false},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"I'm not sure I understand why the logic for initially creating the renderer is different from the logic when recreating.  Could you explain what's different?\n\nhttps://codereview.chromium.org/12544032/diff/32001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/32001/cc/scheduler/scheduler_state_machine.cc#newcode185\ncc/scheduler/scheduler_state_machine.cc:185: return ACTION_INITIALIZE_RENDERER;\nwhy is INITIALIZE a distinct state from RECREATION?","disapproval":false,"date":"2013-04-09 21:26:19.782900","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/09 21:26:19, jamesr wrote:\n> I'm not sure I understand why the logic for initially creating the renderer is\n> different from the logic when recreating.  Could you explain what's different?\n> \n\nThe difference should all inside thread_proxy/LTH, examples:\nrenderer capabilities are set on first init only\noffscreen context is only checked/recreated on recreate\n\nFor, LTHI, Scheduler, and SchedulerStateMachine, they *should* be exactly the same. This is not the case yet since there's Scheduler::DidCreateOutputSurface and DidRecreateOutputSurface, but these two calls should be merged.\n\nAnd a couple more things:\nUnfortunately, there is one more recreate path, the synchronous version for CompositeAndReadback. I have not tried to see if this version works yet since there are no existing tests explicitly testing CompositeAndReadback. So need to add some tests there.\n\nAlso please give me a chance to clean things up before you look at things too closely. I think that mostly involves using better function names and adding comments to make things easier to understand. I expect there will still be 3 distinct paths though, even with common code sharing.\n\nhttps://codereview.chromium.org/12544032/diff/32001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/32001/cc/scheduler/scheduler_state_machine.cc#newcode185\ncc/scheduler/scheduler_state_machine.cc:185: return ACTION_INITIALIZE_RENDERER;\nOn 2013/04/09 21:26:19, jamesr wrote:\n> why is INITIALIZE a distinct state from RECREATION?\n\nOUTPUT_SURFACE_RECREATING leads to ACTION_BEGIN_OUTPUT_SURFACE_RECREATION which kicks off the whole recreate sequence in thread_proxy that involves 3 steps:\n\n1) CreateOutputSurface on main thread\n2) LTHI::SetOutputSurface on impl thread\n3) LTHI::InitializeRenderer on impl thread\n\nStep 2 success will transition the state from RECREATING to PENDING_RENDERER, which will call back with ACTION_INITIALIZE_RENDERER (ie Step 3) inside vsync here.\n\nFor reference, 2) and 3) were a single step (LTHI::InitializeRenderer) before this patch.","disapproval":false,"date":"2013-04-09 21:53:07.756810","approval":false},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/09 21:53:07, boliu wrote:\n> On 2013/04/09 21:26:19, jamesr wrote:\n> > I'm not sure I understand why the logic for initially creating the renderer is\n> > different from the logic when recreating.  Could you explain what's different?\n> > \n> \n> The difference should all inside thread_proxy/LTH, examples:\n> renderer capabilities are set on first init only\n> offscreen context is only checked/recreated on recreate\n\nHmm - if that's true, then it's a bug.  If the capabilities are different after a context loss + recreation then we need to reflect that everywhere.  The capabilities are tied to the OutputSurface.\n\n> \n> For, LTHI, Scheduler, and SchedulerStateMachine, they *should* be exactly the\n> same. This is not the case yet since there's Scheduler::DidCreateOutputSurface\n> and DidRecreateOutputSurface, but these two calls should be merged.\n\nOK.  Do you plan to merge those in this patch or elsewhere?\n\n> \n> And a couple more things:\n> Unfortunately, there is one more recreate path, the synchronous version for\n> CompositeAndReadback. I have not tried to see if this version works yet since\n> there are no existing tests explicitly testing CompositeAndReadback. So need to\n> add some tests there.\n\nYes, that one's weird.\n\n> \n> Also please give me a chance to clean things up before you look at things too\n> closely. I think that mostly involves using better function names and adding\n> comments to make things easier to understand. I expect there will still be 3\n> distinct paths though, even with common code sharing.\n> \n\nOK.  Why do you think there will be 3 distinct paths?  What parts of them are different?\n\n\n> https://codereview.chromium.org/12544032/diff/32001/cc/scheduler/scheduler_state_machine.cc\n> File cc/scheduler/scheduler_state_machine.cc (right):\n> \n> https://codereview.chromium.org/12544032/diff/32001/cc/scheduler/scheduler_state_machine.cc#newcode185\n> cc/scheduler/scheduler_state_machine.cc:185: return ACTION_INITIALIZE_RENDERER;\n> On 2013/04/09 21:26:19, jamesr wrote:\n> > why is INITIALIZE a distinct state from RECREATION?\n> \n> OUTPUT_SURFACE_RECREATING leads to ACTION_BEGIN_OUTPUT_SURFACE_RECREATION which\n> kicks off the whole recreate sequence in thread_proxy that involves 3 steps:\n> \n> 1) CreateOutputSurface on main thread\n> 2) LTHI::SetOutputSurface on impl thread\n> 3) LTHI::InitializeRenderer on impl thread\n> \n> Step 2 success will transition the state from RECREATING to PENDING_RENDERER,\n> which will call back with ACTION_INITIALIZE_RENDERER (ie Step 3) inside vsync\n> here.\n> \n> For reference, 2) and 3) were a single step (LTHI::InitializeRenderer) before\n> this patch.","disapproval":false,"date":"2013-04-09 21:54:59.103350","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/09 21:54:59, jamesr wrote:\n> On 2013/04/09 21:53:07, boliu wrote:\n> > The difference should all inside thread_proxy/LTH, examples:\n> > renderer capabilities are set on first init only\n> > offscreen context is only checked/recreated on recreate\n> \n> Hmm - if that's true, then it's a bug.  If the capabilities are different after\n> a context loss + recreation then we need to reflect that everywhere.  The\n> capabilities are tied to the OutputSurface.\n> \n\nI might be overstating it: tt's updated in thread_proxy, but there are bits not updated in LHI. If you look at existing code, some LTH settings are only set in LTH::InitializeRenderer, which is only called if renderer_initialized_ is false, which once set to true, is never set to false again. Is this a problem?\n\n> > \n> > For, LTHI, Scheduler, and SchedulerStateMachine, they *should* be exactly the\n> > same. This is not the case yet since there's Scheduler::DidCreateOutputSurface\n> > and DidRecreateOutputSurface, but these two calls should be merged.\n> \n> OK.  Do you plan to merge those in this patch or elsewhere?\n\nThis patch, I added DidCreateOutputSurface and now realize there's no difference.\n\n> > \n> > Also please give me a chance to clean things up before you look at things too\n> > closely. I think that mostly involves using better function names and adding\n> > comments to make things easier to understand. I expect there will still be 3\n> > distinct paths though, even with common code sharing.\n> > \n> \n> OK.  Why do you think there will be 3 distinct paths?  What parts of them are\n> different?\n> \n\nI'd have to actually try to merge them again and see what the differences in logic are. The two in my head I've stated above.\n\nBut a big part is because some paths are synchronous are not, so some might expect direct return value and some might expect a callback instead etc. So again these 3 steps:\n1) CreateOutputSurface on main thread\n2) LTHI::SetOutputSurface on impl thread\n3) LTHI::InitializeRenderer on impl thread\n\nIn first init, 1) is sync, 2 and 3 are async.\nIn regular recreate (after this patch), all three steps are async. Also this path has retry on failure logic.\nIn sync recreate, all 3 are sync.","disapproval":false,"date":"2013-04-09 22:08:48.736620","approval":false},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/09 22:08:48, boliu wrote:\n> On 2013/04/09 21:54:59, jamesr wrote:\n> > On 2013/04/09 21:53:07, boliu wrote:\n> > > The difference should all inside thread_proxy/LTH, examples:\n> > > renderer capabilities are set on first init only\n> > > offscreen context is only checked/recreated on recreate\n> > \n> > Hmm - if that's true, then it's a bug.  If the capabilities are different\n> after\n> > a context loss + recreation then we need to reflect that everywhere.  The\n> > capabilities are tied to the OutputSurface.\n> > \n> \n> I might be overstating it: tt's updated in thread_proxy, but there are bits not\n> updated in LHI. If you look at existing code, some LTH settings are only set in\n> LTH::InitializeRenderer, which is only called if renderer_initialized_ is false,\n> which once set to true, is never set to false again. Is this a problem?\n\nYes - I think those are incorrect.  Any settings we get from the OutputSurface have to be updated whenever we get a new OutputSurface.\n\n> > > \n> > > Also please give me a chance to clean things up before you look at things\n> too\n> > > closely. I think that mostly involves using better function names and adding\n> > > comments to make things easier to understand. I expect there will still be 3\n> > > distinct paths though, even with common code sharing.\n> > > \n> > \n> > OK.  Why do you think there will be 3 distinct paths?  What parts of them are\n> > different?\n> > \n> \n> I'd have to actually try to merge them again and see what the differences in\n> logic are. The two in my head I've stated above.\n> \n> But a big part is because some paths are synchronous are not, so some might\n> expect direct return value and some might expect a callback instead etc. So\n> again these 3 steps:\n> 1) CreateOutputSurface on main thread\n> 2) LTHI::SetOutputSurface on impl thread\n> 3) LTHI::InitializeRenderer on impl thread\n> \n> In first init, 1) is sync, 2 and 3 are async.\n> In regular recreate (after this patch), all three steps are async. Also this\n> path has retry on failure logic.\n> In sync recreate, all 3 are sync.\n\nI don't think there is necessarily any reason why first init has to be sync.  If it wasn't, would there still be different paths for anything other than CompositeAndReadback() ?","disapproval":false,"date":"2013-04-09 22:29:50.827680","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/09 22:29:50, jamesr wrote:\n> Yes - I think those are incorrect.  Any settings we get from the OutputSurface\n> have to be updated whenever we get a new OutputSurface.\n> \n\nSo I really don't want to bloat this patch anymore and really want to land this asap to unblock other people. Can I fix it after this lands? (Or possibly before if this gets reverted for perf or other reasons...)\n\n> I don't think there is necessarily any reason why first init has to be sync.  If\n> it wasn't, would there still be different paths for anything other than\n> CompositeAndReadback() ?\n\nThe one difference is first init fails immediately, regular recreate has retry logic, but that's logic in LTH only, not thread_proxy. Can't think of anything else right now, so should be possible to merged them.\n\nI'll try merging, although not looking forward to fixing tests that assume OutputSurface is created on init :/","disapproval":false,"date":"2013-04-09 22:47:18.842500","approval":false},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/09 22:47:18, boliu wrote:\n> On 2013/04/09 22:29:50, jamesr wrote:\n> > Yes - I think those are incorrect.  Any settings we get from the OutputSurface\n> > have to be updated whenever we get a new OutputSurface.\n> > \n> \n> So I really don't want to bloat this patch anymore and really want to land this\n> asap to unblock other people. Can I fix it after this lands? (Or possibly before\n> if this gets reverted for perf or other reasons...)\n\nI think it's more important to make sure that this patch works correctly.  As you're probably well aware now this is a difficult area and we need to make sure we're proceeding carefully.\n\n> \n> > I don't think there is necessarily any reason why first init has to be sync. \n> If\n> > it wasn't, would there still be different paths for anything other than\n> > CompositeAndReadback() ?\n> \n> The one difference is first init fails immediately, regular recreate has retry\n> logic, but that's logic in LTH only, not thread_proxy. Can't think of anything\n> else right now, so should be possible to merged them.\n> \n> I'll try merging, although not looking forward to fixing tests that assume\n> OutputSurface is created on init :/","disapproval":false,"date":"2013-04-09 22:54:31.614720","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"Is there any way to stage this change into a few smaller patches? If it's possible, that would help a lot in grokking and ensuring things are done correctly.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/scheduler/scheduler.cc\nFile cc/scheduler/scheduler.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/scheduler/scheduler.cc#newcode117\ncc/scheduler/scheduler.cc:117: }\nWhy doesn't this ProcessScheduledActions?\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/scheduler/scheduler_state_machine.cc#newcode426\ncc/scheduler/scheduler_state_machine.cc:426: output_surface_state_ == OUTPUT_SURFACE_PENDING_RENDERER)\nIf the renderer isn't recreated, but the output surface is lost, I think it's wrong to drop the lost event here. We should reset to output surface lost and go from there. Initializing a renderer with a lost output surface isn't helpful, which I think this is going to try to do?\n\nMaybe the renderer init will fail in this case and we'll get back to the lost state, but it's a bit more indirect, and makes HasOutputSurface() lie, is there any reason for that?\n\n(Sounds like a test would be good for this case if there isn't one)\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/scheduler/scheduler_unittest.cc\nFile cc/scheduler/scheduler_unittest.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/scheduler/scheduler_unittest.cc#newcode586\ncc/scheduler/scheduler_unittest.cc:586: scheduler->DidInitializeRenderer(true);\nSeems like you don't need this init renderer?\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/fake_proxy.cc\nFile cc/test/fake_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/fake_proxy.cc#newcode20\ncc/test/fake_proxy.cc:20: DCHECK(host_);\nnit: no need to dcheck a pointer youre about to deref on the next line.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/fake_proxy.h\nFile cc/test/fake_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/fake_proxy.h#newcode20\ncc/test/fake_proxy.h:20: void SetHost(LayerTreeHost* host);\nnit: set_layer_tree_host(). this can be an inline method in the header, it's a simple setter.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/fake_proxy.h#newcode50\ncc/test/fake_proxy.h:50: LayerTreeHost* host_;\nnit: layer_tree_host_\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.cc\nFile cc/test/layer_tree_test.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.cc#newcode93\ncc/test/layer_tree_test.cc:93: test_hooks_->DidSetOutputSurface(this);\ninstead of only calling this on true, can you call this always, but pass the result to the method. See PrepareToDrawOnThread() and SwapBuffersOnThread() as examples of this.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.cc#newcode441\ncc/test/layer_tree_test.cc:441: FakeOutputSurface* fake_output_surface =\nThis isn't great, there's no guarantee that a test doesn't override CreateOutputSurface and create something that isn't a FakeOutputSurface.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.cc#newcode449\ncc/test/layer_tree_test.cc:449: base::Unretained(this),\nunretained pointers seems like it's going to potentially cause flake. what if the test shuts down before this task is handled?\n\nwhy do you post-task for this anyways? you're already on the impl thread here.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.cc#newcode456\ncc/test/layer_tree_test.cc:456: fake_output_surface->DidVSync(frame_time_);\nwho sets frame_time_?\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.h\nFile cc/test/layer_tree_test.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.h#newcode36\ncc/test/layer_tree_test.h:36: virtual void DidSetOutputSurface(LayerTreeHostImpl* host_impl) {}\nnit: DidSetOutputSurfaceOnThread\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode163\ncc/trees/layer_tree_host.cc:163: if (has_renderer_capabilities_) {\nI'm having trouble groking this function.\n\n1. If you have a renderer already, then you check if the output surface was created and retry if not?\n\n2. If you don't have a renderer, and you didn't create an output surface, then it gives up?\n\nWhy is any of the recreate-output-surface part of this function dependent on if you have initialized the renderer? As soon as the output surface is lost, the renderer should be considered lost too, including its capabilities.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode170\ncc/trees/layer_tree_host.cc:170: client_->WillRetryRecreateOutputSurface();\nThis should happen before we recreate, not after. In the case DidRecreate succeeds above, this wouldn't even happen?\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode188\ncc/trees/layer_tree_host.cc:188: } else {\nnit: no else needed, the if() block returned.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode234\ncc/trees/layer_tree_host.cc:234: if (has_renderer_capabilities_)\ni'm not sure i see the benefit of renaming this variable. has its meaning changed? initialized should be == having capabilities.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode519\ncc/trees/layer_tree_host.cc:519: bool LayerTreeHost::IsOutputSurfaceLost() const {\nThis is kind of a lie. If output surface is not lost but the renderer isn't ready, then this returns true.\n\nI'd rather name this something more precise like IsRendererInitialized() (well, that'd be the opposite, but you get the idea).\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode521\ncc/trees/layer_tree_host.cc:521: return output_surface_lost_ || !has_renderer_capabilities_;\nIs it possible that output_surface_lost_ = true, but has_renderer_caps_ = true? That would seem like a bug.\n\nI would think this function would be more like the following to enforce that, if it's true:\n\nDCHECK(!output_surface_lost_ || !has_renderer_capabilities_);\nreturn has_renderer_capabilities_;\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode721\ncc/trees/layer_tree_host.cc:721: if (output_surface_lost_ || !has_renderer_capabilities_) {\nReuse the IsOutputSurfaceLost() function here?\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode722\ncc/trees/layer_tree_host.cc:722: RecreateOutputSurface();\nWhy does not having a renderer cause us to recreate the output surface?\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode724\ncc/trees/layer_tree_host.cc:724: return !output_surface_lost_ && has_renderer_capabilities_;\ncan reuse IsOutputSurfaceLost here as well.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.cc\nFile cc/trees/layer_tree_host_impl.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.cc#newcode1296\ncc/trees/layer_tree_host_impl.cc:1296: bool LayerTreeHostImpl::InitializeRendererForTest(\nThis calls other public functions. Are you planning to remove this function and just make these calls directly in the tests?\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.h\nFile cc/trees/layer_tree_host_impl.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.h#newcode206\ncc/trees/layer_tree_host_impl.h:206: bool InitializeRendererForTest(\nnit: *ForTesting(\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_unittest.cc\nFile cc/trees/layer_tree_host_unittest.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_unittest.cc#newcode1570\ncc/trees/layer_tree_host_unittest.cc:1570: class LayerTreeHostWithProxy : public LayerTreeHost { public:\ntypo here","disapproval":false,"date":"2013-04-10 16:40:14.404750","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"On 2013/04/10 16:40:14, danakj wrote:\n> Is there any way to stage this change into a few smaller patches? If it's\n> possible, that would help a lot in grokking and ensuring things are done\n> correctly.\n\nThanks for reviewing. Unfortuantely this patch really isn't ready for close review yet. I know it's close to impossible to understand right now (I can't keep all the details in my head). Should get better after the different paths are merged and after I come up with better names for things.\n\nI'm not sure yet about splitting into smaller patches. A few things came up that are really independent changes to the original code, but I don't know how easy it is to untangle those changes.\n\nLeft some inline replies.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/fake_proxy.cc\nFile cc/test/fake_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/fake_proxy.cc#newcode20\ncc/test/fake_proxy.cc:20: DCHECK(host_);\nOn 2013/04/10 16:40:14, danakj wrote:\n> nit: no need to dcheck a pointer youre about to deref on the next line.\n\nBenefit is this makes the crash explicit. Without DCHECK, the crash would be somewhere inside OnCreateAttemped\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.cc\nFile cc/test/layer_tree_test.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/test/layer_tree_test.cc#newcode456\ncc/test/layer_tree_test.cc:456: fake_output_surface->DidVSync(frame_time_);\nOn 2013/04/10 16:40:14, danakj wrote:\n> who sets frame_time_?\n\nNo one! This was a the case with the vsync test and I just moved the code here. Haven't bothered to check what it's used for yet...\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode170\ncc/trees/layer_tree_host.cc:170: client_->WillRetryRecreateOutputSurface();\nOn 2013/04/10 16:40:14, danakj wrote:\n> This should happen before we recreate, not after. In the case DidRecreate\n> succeeds above, this wouldn't even happen?\n\nThis is the exact same behavior as LayerTreeHost::RecreateOutputSurface before this patch. And I don't think it's wrong, it's *retrying* a recreate after it fails, so if recreate suceeds the first time, it should not be called.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode234\ncc/trees/layer_tree_host.cc:234: if (has_renderer_capabilities_)\nOn 2013/04/10 16:40:14, danakj wrote:\n> i'm not sure i see the benefit of renaming this variable. has its meaning\n> changed? initialized should be == having capabilities.\n\nAgree it's a bad name.\n\nThe has_renderer_cap vars are used to distinguish the first creating output surface/initializing renderer, vs something lost and recreating. But as the latest discussion with James, there are code where there should be no distinction like update settings_ above. This also makes has_cap a bad name since capabilities should be updated on recreate.\n\nJust rename to something like is_first_init.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode521\ncc/trees/layer_tree_host.cc:521: return output_surface_lost_ || !has_renderer_capabilities_;\nOn 2013/04/10 16:40:14, danakj wrote:\n> Is it possible that output_surface_lost_ = true, but has_renderer_caps_ = true?\n> That would seem like a bug.\n\nYes. See above comment, has_renderer_caps should really be renamed to something like has_first_initialized_renderer. Basically once has_first_initialized_renderer is set to true, it's never set to false again.\n\nNote I think that this var might no longer be needed here, but will still be needed in thread_proxy.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.cc\nFile cc/trees/layer_tree_host_impl.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.cc#newcode1296\ncc/trees/layer_tree_host_impl.cc:1296: bool LayerTreeHostImpl::InitializeRendererForTest(\nOn 2013/04/10 16:40:14, danakj wrote:\n> This calls other public functions. Are you planning to remove this function and\n> just make these calls directly in the tests?\n\nA lot of tests calls this. I don't think it's better replace each callsite with the body of this function due to the DRY principle. But would be better to move this somewhere compiled for tests only, but still available to all tests, any suggestions?","disapproval":false,"date":"2013-04-10 17:36:35.953080","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org"],"text":"https://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host.cc#newcode170\ncc/trees/layer_tree_host.cc:170: client_->WillRetryRecreateOutputSurface();\nOn 2013/04/10 17:36:36, boliu wrote:\n> On 2013/04/10 16:40:14, danakj wrote:\n> > This should happen before we recreate, not after. In the case DidRecreate\n> > succeeds above, this wouldn't even happen?\n> \n> This is the exact same behavior as LayerTreeHost::RecreateOutputSurface before\n> this patch. And I don't think it's wrong, it's *retrying* a recreate after it\n> fails, so if recreate suceeds the first time, it should not be called.\n\nAh, okay, quite right. I guess it's just my general confusion about how this function is used at the moment.\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.cc\nFile cc/trees/layer_tree_host_impl.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/43001/cc/trees/layer_tree_host_impl.cc#newcode1296\ncc/trees/layer_tree_host_impl.cc:1296: bool LayerTreeHostImpl::InitializeRendererForTest(\nOn 2013/04/10 17:36:36, boliu wrote:\n> On 2013/04/10 16:40:14, danakj wrote:\n> > This calls other public functions. Are you planning to remove this function\n> and\n> > just make these calls directly in the tests?\n> \n> A lot of tests calls this. I don't think it's better replace each callsite with\n> the body of this function due to the DRY principle. But would be better to move\n> this somewhere compiled for tests only, but still available to all tests, any\n> suggestions?\n\nI think most of the calls are in the LayerTreeHostImpl tests? I'd suggest putting a CreateLayerTreeHostImpl(scoped_ptr<OutputSurface>) function in the LTHI test base class. Then have tests call that instead of calling LTHI::Create();LTHI::InitializeRendererForTesting();\n\nMost other tests could just make the real calls, I think. If there's a bunch of duplication in another test file, you could follow a similar pattern. Seem reasonable?","disapproval":false,"date":"2013-04-10 17:51:00.280280","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Cleaned up thread_proxy, merging/simplifying functions etc. Have not renamed anything though. But it's finally somewhat sane to read and follow now.\n\nHave not changed anything else or address any comments from previous review yet, so don't look at other files yet.","disapproval":false,"date":"2013-04-11 19:29:26.430360","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"https://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode994\ncc/trees/thread_proxy.cc:994: if (was_first_create && has_renderer_capabilities_on_impl_thread_)\naccessing an impl variable on the main thread without a lock = no.\n\nbut you just passed this value in with the bind, so you shouldn't need it right? in fact, this condition would never be true since was_first_create = !has_renderer_caps_on_impl_thread\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode995\ncc/trees/thread_proxy.cc:995: return;\nwhy would this function even be called then in this scenario? should this be a dcheck/notreached?\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1000\ncc/trees/thread_proxy.cc:1000: Proxy::MainThread()->PostTask(output_surface_recreation_callback_.callback());\nI'm not clear why this is a PostTask to the main thread when we're already on the main thread. James, what's the logic here in the old code?\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1004\ncc/trees/thread_proxy.cc:1004: bool initialize_renderer_ignoring_vsync) {\nI think an enum here instead of a bool woudl help readability a bunch\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1015\ncc/trees/thread_proxy.cc:1015: if (!success) goto done;\nHeh, please do this without gotos. :)\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1094\ncc/trees/thread_proxy.cc:1094: void ThreadProxy::InitializeOutputSurfaceOnImplThread(\nthis should be ::RecreateOutputSurface... I guess\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1108\ncc/trees/thread_proxy.cc:1108: return;\nShould this tell the caller that it didn't do anything? This is going to return success = true, implicitly, but it's not obvious IMO. This could be more clear.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1122\ncc/trees/thread_proxy.cc:1122: } else if (offscreen_context_provider) {\nseems like this should be an early out\n\nif !success\n  bind/verify contexts\n  signal\n  return\n\nthen youll have much less if (success) checks here.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1127\ncc/trees/thread_proxy.cc:1127: if (*success && initialize_renderer_ignoring_vsync) {\nrahter than \"ignoring_vsync\" in here, what about something like \"initialize_renderer_immediately\"? or \"synchronously\".. or something.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1128\ncc/trees/thread_proxy.cc:1128: *success = DoInitializeRendererOnImplThread();\nHow does the offscreen context provider get to the init renderer function in this case?\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1129\ncc/trees/thread_proxy.cc:1129: if (*success && capabilities) {\nare the caps NULL sometimes? I dont see that.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1167\ncc/trees/thread_proxy.cc:1167: offscreen_context_provider_passed_->VerifyContexts();\nsame comment about an early-out condition. you could do this right after trying to initialize and return there.","disapproval":false,"date":"2013-04-12 00:38:35.079280","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"There's a lot of naming stuff to clean up and the code feels a bit haphazard with so many nested ifs. I think some time spent making that more clear would be well invested.\n\nOverall I think I see where the class is going and it seems reasonable.","disapproval":false,"date":"2013-04-12 00:39:31.904300","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Addressed some comments but still horrible names everywhere.\n\nRan through the default set of trybots on PS13. Seems to have a bunch of failures on aura/chromeos bots which is a little worrying since most are show gl related errors. Not sure if this is normal level of flakiness or if this patch made things worse..\n\nLayout test failures do not seem to be real, even if they are related to compositing. I can't reproduce them locally.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode994\ncc/trees/thread_proxy.cc:994: if (was_first_create && has_renderer_capabilities_on_impl_thread_)\nOn 2013/04/12 00:38:35, danakj wrote:\n> accessing an impl variable on the main thread without a lock = no.\n> \n> but you just passed this value in with the bind, so you shouldn't need it right?\n> in fact, this condition would never be true since was_first_create =\n> !has_renderer_caps_on_impl_thread\n\nchanged to main thread copy\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode995\ncc/trees/thread_proxy.cc:995: return;\nOn 2013/04/12 00:38:35, danakj wrote:\n> why would this function even be called then in this scenario? should this be a\n> dcheck/notreached?\n\nThis is the two paths, synchronous RecreateOutputSurfaceAndInitializeRenderer and the async one here, interacting in bad ways.\n\nSo the async path is kicked off when first initialized, then if RecreateOutputSurfaceAndInitializeRenderer is called immediately after and wins the race, can actually fall into this case.\n\nLayerTreeHostTestDeviceScaleFactorScalesViewportAndLayers.RunMultiThread is the first test that does this, and without this early return, it just hangs.\n\nI would like to understand why the test hangs without this, but I presume it's probably a test problem.\n\nI would also like add more tests specifically testing how these two recreate paths interact\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1000\ncc/trees/thread_proxy.cc:1000: Proxy::MainThread()->PostTask(output_surface_recreation_callback_.callback());\nOn 2013/04/12 00:38:35, danakj wrote:\n> I'm not clear why this is a PostTask to the main thread when we're already on\n> the main thread. James, what's the logic here in the old code?\n\nThis is for the *retrying* recreate if it fails. output_surface_recreation_callback_ is posted again if LTH::OnCreateAttemped returns retry, and cancelled if succeeds.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1094\ncc/trees/thread_proxy.cc:1094: void ThreadProxy::InitializeOutputSurfaceOnImplThread(\nOn 2013/04/12 00:38:35, danakj wrote:\n> this should be ::RecreateOutputSurface... I guess\n\nused for both initial create and recreate, so hard to come up with sensible names...\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1108\ncc/trees/thread_proxy.cc:1108: return;\nOn 2013/04/12 00:38:35, danakj wrote:\n> Should this tell the caller that it didn't do anything? This is going to return\n> success = true, implicitly, but it's not obvious IMO. This could be more clear.\n\nGoing to make default to false at callsite and explicitly set to true here.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1122\ncc/trees/thread_proxy.cc:1122: } else if (offscreen_context_provider) {\nOn 2013/04/12 00:38:35, danakj wrote:\n> seems like this should be an early out\n> \n> if !success\n>   bind/verify contexts\n>   signal\n>   return\n> \n> then youll have much less if (success) checks here.\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1128\ncc/trees/thread_proxy.cc:1128: *success = DoInitializeRendererOnImplThread();\nOn 2013/04/12 00:38:35, danakj wrote:\n> How does the offscreen context provider get to the init renderer function in\n> this case?\n\nBug! Make setting offscreen_context_provider_passed_ unconditioned\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1129\ncc/trees/thread_proxy.cc:1129: if (*success && capabilities) {\nOn 2013/04/12 00:38:35, danakj wrote:\n> are the caps NULL sometimes? I dont see that.\n\nin older version..\n\nRemoved this check and add DCHECK at beginning of function for success and capabilities\n\nhttps://codereview.chromium.org/12544032/diff/64001/cc/trees/thread_proxy.cc#newcode1167\ncc/trees/thread_proxy.cc:1167: offscreen_context_provider_passed_->VerifyContexts();\nOn 2013/04/12 00:38:35, danakj wrote:\n> same comment about an early-out condition. you could do this right after trying\n> to initialize and return there.\n\nRemoved the !has_renderer_capabilities_on_impl_thread_ above as James was saying we should be updating these capabilities on every recreate.\n\nThen merge the into a single if/else if","disapproval":false,"date":"2013-04-12 02:10:20.955420","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Ready for a closer look for merging code paths.","disapproval":false,"date":"2013-04-22 16:00:13.050920","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Hey, this is pretty cool! I left a whole bunch of comments for you. I think we can get rid of a couple variables/functions to help simplify the state we need in our heads.\n\nThe terminology is becoming awkward. Previously we had \"Create output surface\" and \"Initialize renderer\". Now we have \"CreateAndInitializeOutputSurface\" but it doesn't *really* mean anything to init the output surface. It's a renderer we're initializing. I nitted a few places with names to make it consistent with the overall patch, but I'm not totally sold on the \"InitializeOutputSurface\" part of the namings. I'm not sure what to suggest right now tho other than CreateOutputSurfaceAndInitializeRenderer which is long.. but more correct. And then you'd have things like Scheduler::HasInitializedRenderer() instead of HasOutputSurface(). WDYT?\n\nCan you add some tests for the new code paths? Specifically:\n1. If the context is lost twice during the first initialization, that the compositor still comes up and can produce frames after (but not before).\n2. If the context is lost many times during the first initialization, the compositor fails and reports DidCreateOutputSurface(false) to its client.\n\nI think that would more or less get them.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc#newcode184\ncc/scheduler/scheduler_state_machine.cc:184: if (output_surface_state_ == OUTPUT_SURFACE_LOST && can_begin_frame_)\nWe should follow up with a rename for this variable, and the whole SetSurfaceReady() thing, I think. This is \"embedder ready\" or \"lth client ready\" really.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc#newcode197\ncc/scheduler/scheduler_state_machine.cc:197: ((visible_ && can_begin_frame_) || needs_forced_commit_))\nDo you need can_begin_frame_ here? How about checking OUTPUT_SURFACE_ACTIVE instead? Since now, O_S_LOST doesn't imply that we report BEGIN_O_S_CREATION anymore.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc#newcode429\ncc/scheduler/scheduler_state_machine.cc:429: if (had_output_surface_)\nThis variable gets set true here, then stays true forever. So, we're SetNeedsCommit() when we create the first output surface, but not when we recreate after a loss? Why is that? We used to SetNeedsCommit() after a loss.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.h\nFile cc/scheduler/scheduler_state_machine.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.h#newcode142\ncc/scheduler/scheduler_state_machine.h:142: void DidCreateOutputSurface();\nnit: DidCreateAndInitializeOutputSurface?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.h#newcode143\ncc/scheduler/scheduler_state_machine.h:143: bool HasOutputSurface() const;\nnit: HasInitializedOutputSurface?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc\nFile cc/scheduler/scheduler_state_machine_unittest.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode387\ncc/scheduler/scheduler_state_machine_unittest.cc:387: state.DidCreateOutputSurface();\nShould you just do this CanBeginFrame/CreateOutputSurface dance once at the start of the test? The surface isn't being lost in this test.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode413\ncc/scheduler/scheduler_state_machine_unittest.cc:413: state.SetCanBeginFrame(true);\nDo you need to do it again here?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode458\ncc/scheduler/scheduler_state_machine_unittest.cc:458: state.SetCanBeginFrame(true);\nSame question here and on the next test below.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode724\ncc/scheduler/scheduler_state_machine_unittest.cc:724: state.UpdateState(state.NextAction());\nCan you add a unit test that verifies NextAction() is what we expect it to be before calling UpdateState() like this? And that NextAction() changes appropriately then after DidCreateOS()?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode729\ncc/scheduler/scheduler_state_machine_unittest.cc:729: state.DidLoseOutputSurface();\nCan you verify what NextAction() is before calling DidLoseOS()? So we can see it changes to BEGIN_O_S_CREATION afterward.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode756\ncc/scheduler/scheduler_state_machine_unittest.cc:756: state.DidLoseOutputSurface();\nSame here please verify NextAction()\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/test/fake_proxy.h\nFile cc/test/fake_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/test/fake_proxy.h#newcode20\ncc/test/fake_proxy.h:20: void SetHost(LayerTreeHost* host);\nnit: SetLayerTreeHost\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/test/fake_proxy.h#newcode50\ncc/test/fake_proxy.h:50: LayerTreeHost* host_;\nnit: layer_tree_host_\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode86\ncc/trees/layer_tree_host.cc:86: had_output_surface_(false),\nI'd like this variable to go away, and I think it's possible. I've commented at each site what I think could replace it.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode87\ncc/trees/layer_tree_host.cc:87: output_surface_lost_(false),\nShould this start true now? Then HasOutputSurface() can just check this variable.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode126\ncc/trees/layer_tree_host.cc:126: return true;\nIf this is always true, then the method should not return a bool, and LTH::Create() should never return NULL.\n\nThat might be a rather large change of it's own, touching embedders etc, so probably makes sense as a followup patch.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode158\ncc/trees/layer_tree_host.cc:158: client_->DidRecreateOutputSurface(true);\nIt would make unit testing better if this was called always, but I realize that might mess with the current embedder implementations. Did you try it?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode175\ncc/trees/layer_tree_host.cc:175: if (!had_output_surface_) {\nHow about if (!contents_texture_manager) {} ?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode194\ncc/trees/layer_tree_host.cc:194: } else {\nNo need for else when the if block returned.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode196\ncc/trees/layer_tree_host.cc:196: client_->WillRetryRecreateOutputSurface();\nRename this WillRetryCreateOutputSurface() and call this always here. It will help you unit test failure recovery during the first initialization.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode202\ncc/trees/layer_tree_host.cc:202: if (!had_output_surface_ || num_failed_recreate_attempts_ > 5) {\nWhat is the advantage of unifying this code if we don't allow it to retry the same way? I don't think we want the !had_output_surface_ here.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode221\ncc/trees/layer_tree_host.cc:221: if (had_output_surface_)\nhow about just if (contents_texture_manager_)\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode503\ncc/trees/layer_tree_host.cc:503: if (had_output_surface_) {\nif (!output_surface_lost_) ?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode525\ncc/trees/layer_tree_host.cc:525: if (!had_output_surface_)\nI think this if can just go away. The LTHI will early out as appropriate.\n\n(And it would be nice to minimize our dependence on had_output_surface_ so we can see what is really depending on it)\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.h\nFile cc/trees/layer_tree_host.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.h#newcode125\ncc/trees/layer_tree_host.h:125: CreateResult OnCreateAttempted(bool success);\nOnCreateAndInitializeOutputSurfaceAttempted()\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host_unittest_context.cc#newcode984\ncc/trees/layer_tree_host_unittest_context.cc:984: context3d_->set_have_extension_io_surface(true);\nnit: how about output_surface->Context3d()->set_have...\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc\nFile cc/trees/single_thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode103\ncc/trees/single_thread_proxy.cc:103: void SingleThreadProxy::CreateAndInitializeOutputSurface() {\nWhy doesn't this call DidStartOutputSurfaceCreation() like the thread proxy? Should we test that?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode130\ncc/trees/single_thread_proxy.cc:130: layer_tree_host_->DeleteContentsTexturesOnImplThread(\nI don't think this needs to be inside the if(had_renderer_caps) block. LTH does the right thing. And this implicitly ties the proxy \"had_renderer_capabilities\" to state in the LTH which I dislike. Can we just call this always when we get this far? Maybe do this just before InitializeRenderer()?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode147\ncc/trees/single_thread_proxy.cc:147: if (had_renderer_capabilities) {\nI think this if() isn't serving much purpose, can we remove it and just call set_offscreen_c_p() always here? We'll always have one thanks to the early-out above if we're supposed to have one. And setting it to NULL when we don't is fine.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode151\ncc/trees/single_thread_proxy.cc:151: } else if (had_renderer_capabilities && offscreen_context_provider) {\nelse if(offscreen_context_provider) is enough.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode182\ncc/trees/thread_proxy.cc:182: void ThreadProxy::DoCreateAndInitializeContext() {\ns/Context/OutputSurface/\n\nThis \"Context\" reference is a hold-over from before we had output surfaces.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode191\ncc/trees/thread_proxy.cc:191: scoped_refptr<ContextProvider> offscreen_context_provider;\nMove this below the early out if it's not used\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode230\ncc/trees/thread_proxy.cc:230: void ThreadProxy::OnContextInitializeAttempted(\ns/Context/OutputSurface/\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode243\ncc/trees/thread_proxy.cc:243: if (LayerTreeHost::CreateFailedButTryAgain == result) {\nstyle nit: please do if (variable == ConstantValue) throughout this CL. (also saw this in SchedulerStateMachine)\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode251\ncc/trees/thread_proxy.cc:251: const RendererCapabilities& ThreadProxy::GetRendererCapabilities() const {\nCan you add a DCHECK(IsMainThread()) in here?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode288\ncc/trees/thread_proxy.cc:288: CheckOutputSurfaceStatusOnImplThread();\nDon't change this. We want the DidLose stuff to happen outside the callback from the GraphicsContext3d.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode335\ncc/trees/thread_proxy.cc:335: DCHECK(vsync_client_);\nWhy? It seems like passing NULL is valid according to the line below, to disable VsyncNotification\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode561\ncc/trees/thread_proxy.cc:561: if (had_output_surface_initialized_)\ncan this be if(layer_tree_host_impl_->renderer())?\n\nThis variable is a main thread variable. using it here without locks is not great.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode671\ncc/trees/thread_proxy.cc:671: if (!layer_tree_host_->HasOutputSurface()) {\nHow can this be false? In the readback case, we called InitRendererIfNeeded(). In the non-readback case, we don't schedule begin frame while the surface is lost.\n\nCan this if block just go away? Feel free to dcheck !output_surface_lost_ in LTH::UpdateLayers() if you want..\n\nIf this can go away, I think the LTH::HasOutputSurface() method can go away as well (once LTH::had_output_surface_ goes too).\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode1100\ncc/trees/thread_proxy.cc:1100: void ThreadProxy::InitializeContextOnImplThread(\ns/Context/OutputSurface/\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.h\nFile cc/trees/thread_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.h#newcode197\ncc/trees/thread_proxy.h:197: bool had_output_surface_initialized_;\nhas_renderer_capabilities_on_main_thread?","disapproval":false,"date":"2013-04-22 18:03:41.449500","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Addressed all somments except no new tests yet. Going to first check if this broke linux_chromeos even more.\n\nI think we can call renderer in LTHI, and output surface everywhere else.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc#newcode184\ncc/scheduler/scheduler_state_machine.cc:184: if (output_surface_state_ == OUTPUT_SURFACE_LOST && can_begin_frame_)\nOn 2013/04/22 18:03:41, danakj wrote:\n> We should follow up with a rename for this variable, and the whole\n> SetSurfaceReady() thing, I think. This is \"embedder ready\" or \"lth client ready\"\n> really.\n\nRenamed this from Scheduler down to SetCanStart. Also removed the param, since nothing calls it with false.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc#newcode197\ncc/scheduler/scheduler_state_machine.cc:197: ((visible_ && can_begin_frame_) || needs_forced_commit_))\nOn 2013/04/22 18:03:41, danakj wrote:\n> Do you need can_begin_frame_ here? How about checking OUTPUT_SURFACE_ACTIVE\n> instead? Since now, O_S_LOST doesn't imply that we report BEGIN_O_S_CREATION\n> anymore.\n\nBoth done.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc#newcode429\ncc/scheduler/scheduler_state_machine.cc:429: if (had_output_surface_)\nOn 2013/04/22 18:03:41, danakj wrote:\n> This variable gets set true here, then stays true forever. So, we're\n> SetNeedsCommit() when we create the first output surface, but not when we\n> ecreate after a loss?\n\nWait, it should be the exact opposite. We are not setting need commit on first output surface create, but do set it on all recreates after.\n\n> Why is that?\n\nThis is to match old behavior, where first init used to be outside of scheduler creation and did not SetNeedsCommit.\n\nAlso note that LTH::DidStartOutputSurfaceCreation (name in current PS), it also calls SetNeedsCommit. These are duplicates but I'm guessing single_thread_proxy needs the LTH call. But there are also implications for deleting this line too, so I'm not sure if anything should be done about this.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.h\nFile cc/scheduler/scheduler_state_machine.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.h#newcode142\ncc/scheduler/scheduler_state_machine.h:142: void DidCreateOutputSurface();\nOn 2013/04/22 18:03:41, danakj wrote:\n> nit: DidCreateAndInitializeOutputSurface?\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.h#newcode143\ncc/scheduler/scheduler_state_machine.h:143: bool HasOutputSurface() const;\nOn 2013/04/22 18:03:41, danakj wrote:\n> nit: HasInitializedOutputSurface?\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc\nFile cc/scheduler/scheduler_state_machine_unittest.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode387\ncc/scheduler/scheduler_state_machine_unittest.cc:387: state.DidCreateOutputSurface();\nOn 2013/04/22 18:03:41, danakj wrote:\n> Should you just do this CanBeginFrame/CreateOutputSurface dance once at the\n> start of the test? The surface isn't being lost in this test.\n\nA new state machine is created in each loop. I don't think I can move this any earlier.\n\nAre you proposing re-using the same object in each loop?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode724\ncc/scheduler/scheduler_state_machine_unittest.cc:724: state.UpdateState(state.NextAction());\nOn 2013/04/22 18:03:41, danakj wrote:\n> Can you add a unit test that verifies NextAction() is what we expect it to be\n> before calling UpdateState() like this? And that NextAction() changes\n> appropriately then after DidCreateOS()?\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode729\ncc/scheduler/scheduler_state_machine_unittest.cc:729: state.DidLoseOutputSurface();\nOn 2013/04/22 18:03:41, danakj wrote:\n> Can you verify what NextAction() is before calling DidLoseOS()? So we can see it\n> changes to BEGIN_O_S_CREATION afterward.\n\nVerify it's not BEGIN_O_S_CREATION\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode756\ncc/scheduler/scheduler_state_machine_unittest.cc:756: state.DidLoseOutputSurface();\nOn 2013/04/22 18:03:41, danakj wrote:\n> Same here please verify NextAction()\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/test/fake_proxy.h\nFile cc/test/fake_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/test/fake_proxy.h#newcode20\ncc/test/fake_proxy.h:20: void SetHost(LayerTreeHost* host);\nOn 2013/04/22 18:03:41, danakj wrote:\n> nit: SetLayerTreeHost\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/test/fake_proxy.h#newcode50\ncc/test/fake_proxy.h:50: LayerTreeHost* host_;\nOn 2013/04/22 18:03:41, danakj wrote:\n> nit: layer_tree_host_\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode86\ncc/trees/layer_tree_host.cc:86: had_output_surface_(false),\nOn 2013/04/22 18:03:41, danakj wrote:\n> I'd like this variable to go away, and I think it's possible. I've commented at\n> each site what I think could replace it.\n\nDone. Had to fix some tests but had_output_surface_ is no more.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode87\ncc/trees/layer_tree_host.cc:87: output_surface_lost_(false),\nOn 2013/04/22 18:03:41, danakj wrote:\n> Should this start true now? Then HasOutputSurface() can just check this\n> variable.\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode126\ncc/trees/layer_tree_host.cc:126: return true;\nOn 2013/04/22 18:03:41, danakj wrote:\n> If this is always true, then the method should not return a bool, and\n> LTH::Create() should never return NULL.\n> \n> That might be a rather large change of it's own, touching embedders etc, so\n> probably makes sense as a followup patch.\n\nLeft a TODO\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode158\ncc/trees/layer_tree_host.cc:158: client_->DidRecreateOutputSurface(true);\nOn 2013/04/22 18:03:41, danakj wrote:\n> It would make unit testing better if this was called always, but I realize that\n> might mess with the current embedder implementations. Did you try it?\n\nAndroid and ui compositors are no-ops, render widget only calls out to webkit if it failed so safe from embedder persective.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode175\ncc/trees/layer_tree_host.cc:175: if (!had_output_surface_) {\nOn 2013/04/22 18:03:41, danakj wrote:\n> How about if (!contents_texture_manager) {} ?\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode194\ncc/trees/layer_tree_host.cc:194: } else {\nOn 2013/04/22 18:03:41, danakj wrote:\n> No need for else when the if block returned.\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode196\ncc/trees/layer_tree_host.cc:196: client_->WillRetryRecreateOutputSurface();\nOn 2013/04/22 18:03:41, danakj wrote:\n> Rename this WillRetryCreateOutputSurface() and call this always here. It will\n> help you unit test failure recovery during the first initialization.\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode202\ncc/trees/layer_tree_host.cc:202: if (!had_output_surface_ || num_failed_recreate_attempts_ > 5) {\nOn 2013/04/22 18:03:41, danakj wrote:\n> What is the advantage of unifying this code if we don't allow it to retry the\n> same way? I don't think we want the !had_output_surface_ here.\n\nDone. My original thought was don't introduce additional behavior changes, but this patch already is a mix bag of changes.\n\nThis change might break more linux_chromeos tests. I was told that it is intentional to have the renderer compositor fail on linux_chromeos. This will delay the failure message by 5 retries.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode221\ncc/trees/layer_tree_host.cc:221: if (had_output_surface_)\nOn 2013/04/22 18:03:41, danakj wrote:\n> how about just if (contents_texture_manager_)\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode503\ncc/trees/layer_tree_host.cc:503: if (had_output_surface_) {\nOn 2013/04/22 18:03:41, danakj wrote:\n> if (!output_surface_lost_) ?\n\nThis depends on output_surface_lost_ defaulting to true. Done\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.cc#newcode525\ncc/trees/layer_tree_host.cc:525: if (!had_output_surface_)\nOn 2013/04/22 18:03:41, danakj wrote:\n> I think this if can just go away. The LTHI will early out as appropriate.\n> \n> (And it would be nice to minimize our dependence on had_output_surface_ so we\n> can see what is really depending on it)\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.h\nFile cc/trees/layer_tree_host.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host.h#newcode125\ncc/trees/layer_tree_host.h:125: CreateResult OnCreateAttempted(bool success);\nOn 2013/04/22 18:03:41, danakj wrote:\n> OnCreateAndInitializeOutputSurfaceAttempted()\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/layer_tree_host_unittest_context.cc#newcode984\ncc/trees/layer_tree_host_unittest_context.cc:984: context3d_->set_have_extension_io_surface(true);\nOn 2013/04/22 18:03:41, danakj wrote:\n> nit: how about output_surface->Context3d()->set_have...\n\nThese are methods on the test context, so need to do a cast. I think not changing this is safer.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc\nFile cc/trees/single_thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode103\ncc/trees/single_thread_proxy.cc:103: void SingleThreadProxy::CreateAndInitializeOutputSurface() {\nOn 2013/04/22 18:03:41, danakj wrote:\n> Why doesn't this call DidStartOutputSurfaceCreation() like the thread proxy?\n> Should we test that?\n\nI think it's because single thread proxy recreates output surface as a result of SetNeedsCommit, so there is no need to call SetNeedsCommit again. Also there is no retry on failure logic.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode130\ncc/trees/single_thread_proxy.cc:130: layer_tree_host_->DeleteContentsTexturesOnImplThread(\nOn 2013/04/22 18:03:41, danakj wrote:\n> I don't think this needs to be inside the if(had_renderer_caps) block. LTH does\n> the right thing. And this implicitly ties the proxy \"had_renderer_capabilities\"\n> to state in the LTH which I dislike. Can we just call this always when we get\n> this far? Maybe do this just before InitializeRenderer()?\n\nDone.\n\nAlso removed the had_renderer_capabilities check above since it's redundant as well.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode147\ncc/trees/single_thread_proxy.cc:147: if (had_renderer_capabilities) {\nOn 2013/04/22 18:03:41, danakj wrote:\n> I think this if() isn't serving much purpose, can we remove it and just call\n> set_offscreen_c_p() always here? We'll always have one thanks to the early-out\n> above if we're supposed to have one. And setting it to NULL when we don't is\n> fine.\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode151\ncc/trees/single_thread_proxy.cc:151: } else if (had_renderer_capabilities && offscreen_context_provider) {\nOn 2013/04/22 18:03:41, danakj wrote:\n> else if(offscreen_context_provider) is enough.\n\nDone.\n\nWith all the clean up in this function, it looks a lot like ThreadProxy::InitializeContextOnImplThread (name in this PS). Is it a good idea to try to move this into the common superclass?\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode182\ncc/trees/thread_proxy.cc:182: void ThreadProxy::DoCreateAndInitializeContext() {\nOn 2013/04/22 18:03:41, danakj wrote:\n> s/Context/OutputSurface/\n> \n> This \"Context\" reference is a hold-over from before we had output surfaces.\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode191\ncc/trees/thread_proxy.cc:191: scoped_refptr<ContextProvider> offscreen_context_provider;\nOn 2013/04/22 18:03:41, danakj wrote:\n> Move this below the early out if it's not used\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode230\ncc/trees/thread_proxy.cc:230: void ThreadProxy::OnContextInitializeAttempted(\nOn 2013/04/22 18:03:41, danakj wrote:\n> s/Context/OutputSurface/\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode243\ncc/trees/thread_proxy.cc:243: if (LayerTreeHost::CreateFailedButTryAgain == result) {\nOn 2013/04/22 18:03:41, danakj wrote:\n> style nit: please do if (variable == ConstantValue) throughout this CL. (also\n> saw this in SchedulerStateMachine)\n\nDone.\n\nFor reference, my habit of doing ConstValue == var comes from safety of not being able to mistakely miss an equal sign and make it an assignment.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode251\ncc/trees/thread_proxy.cc:251: const RendererCapabilities& ThreadProxy::GetRendererCapabilities() const {\nOn 2013/04/22 18:03:41, danakj wrote:\n> Can you add a DCHECK(IsMainThread()) in here?\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode288\ncc/trees/thread_proxy.cc:288: CheckOutputSurfaceStatusOnImplThread();\nOn 2013/04/22 18:03:41, danakj wrote:\n> Don't change this. We want the DidLose stuff to happen outside the callback from\n> the GraphicsContext3d.\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode335\ncc/trees/thread_proxy.cc:335: DCHECK(vsync_client_);\nOn 2013/04/22 18:03:41, danakj wrote:\n> Why? It seems like passing NULL is valid according to the line below, to disable\n> VsyncNotification\n\nMy bad, this was for debugging weeks ago. Removed.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode561\ncc/trees/thread_proxy.cc:561: if (had_output_surface_initialized_)\nOn 2013/04/22 18:03:41, danakj wrote:\n> can this be if(layer_tree_host_impl_->renderer())?\n> \n> This variable is a main thread variable. using it here without locks is not\n> great.\n\nMoved the if check into main thread function above, then change this to renderer().\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode671\ncc/trees/thread_proxy.cc:671: if (!layer_tree_host_->HasOutputSurface()) {\nOn 2013/04/22 18:03:41, danakj wrote:\n> How can this be false? In the readback case, we called InitRendererIfNeeded().\n> In the non-readback case, we don't schedule begin frame while the surface is\n> lost.\n> \n> Can this if block just go away? Feel free to dcheck !output_surface_lost_ in\n> LTH::UpdateLayers() if you want..\n> \n> If this can go away, I think the LTH::HasOutputSurface() method can go away as\n> well (once LTH::had_output_surface_ goes too).\n\nAll true. Done done done.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.cc#newcode1100\ncc/trees/thread_proxy.cc:1100: void ThreadProxy::InitializeContextOnImplThread(\nOn 2013/04/22 18:03:41, danakj wrote:\n> s/Context/OutputSurface/\n\nDone.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.h\nFile cc/trees/thread_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/thread_proxy.h#newcode197\ncc/trees/thread_proxy.h:197: bool had_output_surface_initialized_;\nOn 2013/04/22 18:03:41, danakj wrote:\n> has_renderer_capabilities_on_main_thread?\n\nJames suggested that has_cap makes no sense after output surface is lost.","disapproval":false,"date":"2013-04-22 23:32:05.455060","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"On 2013/04/22 18:03:41, danakj wrote:\n> Can you add some tests for the new code paths? Specifically:\n> 1. If the context is lost twice during the first initialization, that the\n> compositor still comes up and can produce frames after (but not before).\n\nThis is LayerTreeHostContextTestFailsFirstInitialization, rewritten from LayerTreeHostContextTestFailsImmediately that was expecting immediate failure before.\n\n> 2. If the context is lost many times during the first initialization, the\n> compositor fails and reports DidCreateOutputSurface(false) to its client.\n\nCovered by LayerTreeHostContextTestRetriesFirstInitializationAndSucceeds\n\nAlso added LayerTreeHostContextTestRetryWorksWithForcedInit that mixes InitializeOutputSurfaceIfNeeded during a recreate. A bit pathological but not impossible given the LTHClient api.","disapproval":false,"date":"2013-04-23 01:46:35.639150","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Looking good, LTH is a lot cleaner now. I think there's a bit we can do in the proxies still, but I like this direction a lot.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine.cc#newcode429\ncc/scheduler/scheduler_state_machine.cc:429: if (had_output_surface_)\nOn 2013/04/22 23:32:05, boliu wrote:\n> On 2013/04/22 18:03:41, danakj wrote:\n> > This variable gets set true here, then stays true forever. So, we're\n> > SetNeedsCommit() when we create the first output surface, but not when we\n> > ecreate after a loss?\n> \n> Wait, it should be the exact opposite. We are not setting need commit on first\n> output surface create, but do set it on all recreates after.\n\nOh, I misread that!\n\n> > Why is that?\n> \n> This is to match old behavior, where first init used to be outside of scheduler\n> creation and did not SetNeedsCommit.\n> \n> Also note that LTH::DidStartOutputSurfaceCreation (name in current PS), it also\n> calls SetNeedsCommit. These are duplicates but I'm guessing single_thread_proxy\n> needs the LTH call. But there are also implications for deleting this line too,\n> so I'm not sure if anything should be done about this.\n\nYa, DidStartOutputSurfaceCreation causes a commit in order to make sure the single thread proxy does its recreation since the embedder doesn't keep track of anything really beyond \"needs composite\".\n\nI guess the point here is that you are not allowed to begin frame until you've created/init one output surface+renderer. So there's nothing that needs to be re-committed after its created for the first time.\n\nI think once we get impl-side painting on all the time, maybe the main thread won't have to do any work when the renderer/surface changes, and we can just remove this SetNeedsCommit().\n\nI'm sad to see another bool in this already-too-many-bools class. But I also am not sure how to remove it without adding a useless SetNeedsCommit() during startup.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc\nFile cc/scheduler/scheduler_state_machine_unittest.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/scheduler/scheduler_state_machine_unittest.cc#newcode387\ncc/scheduler/scheduler_state_machine_unittest.cc:387: state.DidCreateOutputSurface();\nOn 2013/04/22 23:32:05, boliu wrote:\n> On 2013/04/22 18:03:41, danakj wrote:\n> > Should you just do this CanBeginFrame/CreateOutputSurface dance once at the\n> > start of the test? The surface isn't being lost in this test.\n> \n> A new state machine is created in each loop. I don't think I can move this any\n> earlier.\n> \n> Are you proposing re-using the same object in each loop?\n\nOh, I didn't notice that :) Never mind my comment here.\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc\nFile cc/trees/single_thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/105001/cc/trees/single_thread_proxy.cc#newcode151\ncc/trees/single_thread_proxy.cc:151: } else if (had_renderer_capabilities && offscreen_context_provider) {\nOn 2013/04/22 23:32:05, boliu wrote:\n> On 2013/04/22 18:03:41, danakj wrote:\n> > else if(offscreen_context_provider) is enough.\n> \n> Done.\n> \n> With all the clean up in this function, it looks a lot like\n> ThreadProxy::InitializeContextOnImplThread (name in this PS). Is it a good idea\n> to try to move this into the common superclass?\n\nI wanna say no, this class is going to just be deleted at some point, and there may be subtle differences, and debug scoping things.\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/scheduler/scheduler_state_machine.cc#newcode431\ncc/scheduler/scheduler_state_machine.cc:431: had_output_surface_ = true;\nnit: did_create_and_initialize_first_output_surface_\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/scheduler/scheduler_state_machine.h\nFile cc/scheduler/scheduler_state_machine.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/scheduler/scheduler_state_machine.h#newcode125\ncc/scheduler/scheduler_state_machine.h:125: // Indicates whether we can successfully begin a frame at this time.\nThis comment needs updating\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc#newcode162\ncc/trees/layer_tree_host.cc:162: client_->DidRecreateOutputSurface(true);\nnit: let's move this down just before the return, same as the failure path, so we do all our work before telling the client.\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc#newcode189\ncc/trees/layer_tree_host.cc:189: settings_.default_tile_size = gfx::Size(\nfyi these two settings will be no longer be changed by the renderer caps on tot.\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc#newcode205\ncc/trees/layer_tree_host.cc:205: if (++num_failed_recreate_attempts_ >= 5) {\none statement per line. do the ++ on a separate line as before please.\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc#newcode212\ncc/trees/layer_tree_host.cc:212: // FIXME: The single thread does not self-schedule output surface\nShould we move this to the single thread proxy now to do when we return TryAgain?\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc#newcode506\ncc/trees/layer_tree_host.cc:506: if (!output_surface_lost_) {\nif (output_surface_lost_) return; will avoid nesting.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/scheduler/scheduler.h\nFile cc/scheduler/scheduler.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/scheduler/scheduler.h#newcode94\ncc/scheduler/scheduler.h:94: void DidCreateAndInitializeOutputSurface();\nSince this is impl, should these be mentioning the Renderer in their names?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode61\ncc/trees/layer_tree_host_unittest_context.cc:61: times_to_expect_failure_(0),\nnit: times_to_expect_create_failed\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode62\ncc/trees/layer_tree_host_unittest_context.cc:62: times_failed_(0),\nnit: times_create_failed\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode157\ncc/trees/layer_tree_host_unittest_context.cc:157: if (!frame->has_no_damage)\nHm, can we just always EXPECT_TRUE here? I'm now fuzzy why this was expecting false when there's no damage. Was the old check failing?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode204\ncc/trees/layer_tree_host_unittest_context.cc:204: void ExpectRecreateToRetry() {\nExpectCreateToFail()?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode244\ncc/trees/layer_tree_host_unittest_context.cc:244: // This is called on first create as well.\nThis will be clear when the function is renamed, I think you don't need the comment here.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode248\ncc/trees/layer_tree_host_unittest_context.cc:248: if (first_initialized_) {\nno {} needed for these\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode649\ncc/trees/layer_tree_host_unittest_context.cc:649: first_initialized_(false) {\nYou could init this in BeginTest() and avoid the constructor if you want (it adds so many lines of boilerplate - just the pattern I've started following), or leave it as is if you prefer.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode1010\ncc/trees/layer_tree_host_unittest_context.cc:1010: context3d_->set_have_extension_io_surface(true);\nHow about setting the set_have_extension_io_surface etc in LTHContextTest::CreateOutputSurface() when it makes the TestWGC3D if some variable context_should_support_io_surface_ in the base class is true? Then have this class set that variable. This function could go away.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode1135\ncc/trees/layer_tree_host_unittest_context.cc:1135: class LayerTreeHostContextTestFailsFirstInitialization\nCan you add a DidCommitAndDrawFrame() method in this test that will EXPECT_FALSE(true), ie fail the test, if it's called?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode1149\ncc/trees/layer_tree_host_unittest_context.cc:1149: virtual scoped_ptr<TestWebGraphicsContext3D> CreateContext3d() OVERRIDE {\nRemove this function, set times_to_lose_on_create_ = 1000 in BeginTest() and you should have the same thing, I think, without having to tweak times_to_expect_failure_ in DidRecreateOS().\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode1185\ncc/trees/layer_tree_host_unittest_context.cc:1185: times_to_expect_failure_ = 2;\nYou should get this for free, the times_to_fail_initialize_ path will set this expectation.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode1202\ncc/trees/layer_tree_host_unittest_context.cc:1202: layer_tree_host()->InitializeOutputSurfaceIfNeeded();\nThis isn't really supposed to be public API for LTH. Can you do the same thing by calling CompositeAndReadback instead? (Won't need SetNeedsRedraw either)\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/proxy.h\nFile cc/trees/proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/proxy.h#newcode62\ncc/trees/proxy.h:62: // Attempts to recreate the context and layer renderer synchronously after a\nHah \"layer renderer\" this is an old comment. Just \"renderer\", it's cleaner.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/proxy.h#newcode63\ncc/trees/proxy.h:63: // context lost. Calls LayerTreeHost::OnCreateAttemped with the result.\n\"after the output surface is lost\"\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/proxy.h#newcode63\ncc/trees/proxy.h:63: // context lost. Calls LayerTreeHost::OnCreateAttemped with the result.\n\"OnCreateAttempted()\" needs to be updated\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc\nFile cc/trees/single_thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode28\ncc/trees/single_thread_proxy.cc:28: output_surface_lost_(false),\ndefault this to true\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode30\ncc/trees/single_thread_proxy.cc:30: had_output_surface_initialized_(false),\nThis variable is problematic for the future, the same way as it was in LTH. It creating assumptions that \"once we initialize the renderer one way, things will stay that way for the future, across context loss etc. We want to move away from that world. I think we can remove this variable as well, and commented at its use sites.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode156\ncc/trees/single_thread_proxy.cc:156: DCHECK(had_output_surface_initialized_);\nCan you dcheck !output_surface_lost_ instead? We care more about \"we have valid caps right now\" than \"we got caps once so we're good forever now\"\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode157\ncc/trees/single_thread_proxy.cc:157: // Note: this gets called during the commit by the \"impl\" thread.\nHmmmm.. is this true? We added an assert IsMainThread() here in the ThreadProxy. I think this is a lie, I can't see the callsite. Can you remove this note and add an assert here as well?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode351\ncc/trees/single_thread_proxy.cc:351: if (had_output_surface_initialized_)\nif (!output_surface_lost_) ?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode440\ncc/trees/single_thread_proxy.cc:440: layer_tree_host_->DidStartOutputSurfaceCreation();\nI'm not sure about this rename.. really we want to tell the host it was lost here. Maybe we can mimic the behaviour of the thread proxy better here? SetNeedsCommit() directly here instead of doing it in DidStartOSCreation(), and call DidStartOSCreation() from CreateAndInitOutputSurface instead?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc#newcode255\ncc/trees/thread_proxy.cc:255: DCHECK(had_output_surface_initialized_);\ni'd like this to be an explicit variable the says if the renderer caps are valid (ie the context is lost/renderer isn't initialized yet) for the main thread to use. for the same reasons as stated in the single thread proxy. IOW when the surface is lost, this variable should become false.\n\nYou mentioned something james had said so maybe we're disagreeing about this? I'm not sure, can you elaborate?\n\nI just feel that dchecking \"we initialized the renderer once\" is far less useful than \"we have an initialized renderer and these are the caps for it\" because in the future, the caps may change when we re-init the renderer.\n\nThe lost context code never actually goes to the main thread however, where it could reset this variable. Since this is just a dcheck, maybe it would make sense to #ifndef NDEBUG make a hop to the impl thread and verify that scheduler->HasInitializedOutputSurface() is true? Then this variable can go away.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc#newcode554\ncc/trees/thread_proxy.cc:554: if (had_output_surface_initialized_) {\nif (!___) return;\n\nSame comment here about this variable, it should be true when we have a valid context/surface/renderer on the impl thread that we can use. Not true forever once we've initialized a renderer once.\n\nIn this case it's just going to hop to the impl thread, so maybe this is not needed. The impl thread can just DoNoOp() on a lost context and nothing bad will happen. So I'd vote to just remove this check.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc#newcode845\ncc/trees/thread_proxy.cc:845: void ThreadProxy::ScheduledActionBeginContextCreation() {\ns/Context/OutputSurface/\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.h\nFile cc/trees/thread_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.h#newcode133\ncc/trees/thread_proxy.h:133: \ndrop the newline, make it clear this is part of the main thread block of functions\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.h#newcode134\ncc/trees/thread_proxy.h:134: // |capabilities| is set only on INIT_SUCCESSFUL_AND_COMPLETE.\nwhat is INIT_SUCCESSFUL_AND_COMPLETE?","disapproval":false,"date":"2013-04-23 18:22:39.671550","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"https://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc#newcode255\ncc/trees/thread_proxy.cc:255: DCHECK(had_output_surface_initialized_);\nOn 2013/04/23 18:22:40, danakj wrote:\n> i'd like this to be an explicit variable the says if the renderer caps are valid\n> (ie the context is lost/renderer isn't initialized yet) for the main thread to\n> use. for the same reasons as stated in the single thread proxy. IOW when the\n> surface is lost, this variable should become false.\n> \n> You mentioned something james had said so maybe we're disagreeing about this?\n> I'm not sure, can you elaborate?\n> \n> I just feel that dchecking \"we initialized the renderer once\" is far less useful\n> than \"we have an initialized renderer and these are the caps for it\" because in\n> the future, the caps may change when we re-init the renderer.\n> \n> The lost context code never actually goes to the main thread however, where it\n> could reset this variable. Since this is just a dcheck, maybe it would make\n> sense to #ifndef NDEBUG make a hop to the impl thread and verify that\n> scheduler->HasInitializedOutputSurface() is true? Then this variable can go\n> away.\n\nI spoke with james a bit about this, cuz I was not really sure I was a fan of the thread hop suggestion. He agreed that the thread hop, or signalling back to the main thread immediately on context loss, just for a dcheck are not really great.\n\nSo, let's have this variable that we're DCHECKing here be false to start with, true when we create a surface/renderer successfully, and false when we start the recreation process again (ie when CreateAndInitOutputSurface happens). It'll give us some coverage at least and can't be racy.","disapproval":false,"date":"2013-04-23 18:34:00.430120","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"If I didn't have a reply, interpret as \"Done\". Now the reply is actually short enough to read.\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc#newcode189\ncc/trees/layer_tree_host.cc:189: settings_.default_tile_size = gfx::Size(\nOn 2013/04/23 18:22:40, danakj wrote:\n> fyi these two settings will be no longer be changed by the renderer caps on tot.\n\nRebased and removed this.\n\nhttps://codereview.chromium.org/12544032/diff/129001/cc/trees/layer_tree_host.cc#newcode212\ncc/trees/layer_tree_host.cc:212: // FIXME: The single thread does not self-schedule output surface\nOn 2013/04/23 18:22:40, danakj wrote:\n> Should we move this to the single thread proxy now to do when we return\n> TryAgain?\n\nDone.\n\nAdded SingleThreadProxy::OnOutputSurfaceInitializeAttempted to dedup code. Also not calling SetNeedsCommit directly (not LTH one) so no longer cancelling prepaint_callback_. I think this is ok.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/scheduler/scheduler.h\nFile cc/scheduler/scheduler.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/scheduler/scheduler.h#newcode94\ncc/scheduler/scheduler.h:94: void DidCreateAndInitializeOutputSurface();\nOn 2013/04/23 18:22:40, danakj wrote:\n> Since this is impl, should these be mentioning the Renderer in their names?\n\nErr...do I have to? How about let's make the rule to only mention renderer in LTHI methods. There is GetRendererCap but that's kind of an exception...\n\nDidn't do anything for this.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode157\ncc/trees/layer_tree_host_unittest_context.cc:157: if (!frame->has_no_damage)\nOn 2013/04/23 18:22:40, danakj wrote:\n> Hm, can we just always EXPECT_TRUE here? I'm now fuzzy why this was expecting\n> false when there's no damage. Was the old check failing?\n\nHaving unconditional EXPECT_TRUE(result) is ok.\n\nOld check was failing in LayerTreeHostContextTestRetryWorksWithForcedInit where there is an extra SetNeedsCommit for single_thread_proxy that ended up having no damage.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode649\ncc/trees/layer_tree_host_unittest_context.cc:649: first_initialized_(false) {\nOn 2013/04/23 18:22:40, danakj wrote:\n> You could init this in BeginTest() and avoid the constructor if you want (it\n> adds so many lines of boilerplate - just the pattern I've started following), or\n> leave it as is if you prefer.\n\nNo boilerplate sounds better to me.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode1149\ncc/trees/layer_tree_host_unittest_context.cc:1149: virtual scoped_ptr<TestWebGraphicsContext3D> CreateContext3d() OVERRIDE {\nOn 2013/04/23 18:22:40, danakj wrote:\n> Remove this function, set times_to_lose_on_create_ = 1000 in BeginTest() and you\n> should have the same thing, I think, without having to tweak\n> times_to_expect_failure_ in DidRecreateOS().\n\ntimes_to_lose_on_create_ works.\n\nExpectCreateToFail checks committed_at_least_once_ before incrementing, which is wrong. Removing the check breaks LayerTreeHostContextTestOffscreenContextFails, so move the tweak there since failing to create first offscreen context is *not* an error. Remove tweak here.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/layer_tree_host_unittest_context.cc#newcode1202\ncc/trees/layer_tree_host_unittest_context.cc:1202: layer_tree_host()->InitializeOutputSurfaceIfNeeded();\nOn 2013/04/23 18:22:40, danakj wrote:\n> This isn't really supposed to be public API for LTH. Can you do the same thing\n> by calling CompositeAndReadback instead? (Won't need SetNeedsRedraw either)\n\nHad to include SkBitmap to call CompositeAndReadback. Please check my usage as it's my first time using skia classes.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc\nFile cc/trees/single_thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode30\ncc/trees/single_thread_proxy.cc:30: had_output_surface_initialized_(false),\nOn 2013/04/23 18:22:40, danakj wrote:\n> This variable is problematic for the future, the same way as it was in LTH. It\n> creating assumptions that \"once we initialize the renderer one way, things will\n> stay that way for the future, across context loss etc. We want to move away from\n> that world. I think we can remove this variable as well, and commented at its\n> use sites.\n\nUsing copy in LTH. See my reply in thread_proxy.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/single_thread_proxy.cc#newcode440\ncc/trees/single_thread_proxy.cc:440: layer_tree_host_->DidStartOutputSurfaceCreation();\nOn 2013/04/23 18:22:40, danakj wrote:\n> I'm not sure about this rename.. really we want to tell the host it was lost\n> here. Maybe we can mimic the behaviour of the thread proxy better here?\n> SetNeedsCommit() directly here instead of doing it in DidStartOSCreation(), and\n> call DidStartOSCreation() from CreateAndInitOutputSurface instead?\n\nMoving this to CreateAndInitOutputSurface will break retry on failure logic since DidStartOSCreation resets the retry counter. At least this behavior is similar to ThreadProxy, that DidStartOSCreation is only called only on context lost *after* successful initialzation, not on each retry.\n\nI think renaming this back to DidLoseOutputSurface is probably the easier solution.\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.cc#newcode255\ncc/trees/thread_proxy.cc:255: DCHECK(had_output_surface_initialized_);\nSo now both single_thread_proxy and this effectively have a copy of LTH::output_surface_lost_. Going to add LTH::output_surface_lost() instead, just for DCHECKing in the proxies.\n\nThis more tightly couples LTH and the proxies, but I think it's worth it, thoughts?\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.h\nFile cc/trees/thread_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/133002/cc/trees/thread_proxy.h#newcode134\ncc/trees/thread_proxy.h:134: // |capabilities| is set only on INIT_SUCCESSFUL_AND_COMPLETE.\nOn 2013/04/23 18:22:40, danakj wrote:\n> what is INIT_SUCCESSFUL_AND_COMPLETE?\n\nShould be |success| is true.","disapproval":false,"date":"2013-04-24 01:28:52.564760","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"I love it :) There's one if() in thread proxy which I think is always false right now? A few nits left, but I'm super happy about this.\n\nJames, want to have a look?\n\nLGTM once that if() question is sorted out.\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/scheduler/scheduler_state_machine.cc\nFile cc/scheduler/scheduler_state_machine.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/scheduler/scheduler_state_machine.cc#newcode429\ncc/scheduler/scheduler_state_machine.cc:429: if (did_create_and_initialize_first_output_surface_)\nCan you stick a TODO in here so we can remember to come back to this one day: \"See if we can remove this when impl-side painting is always on. Does anything on the main thread need to update after recreate?\"\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/layer_tree_host_unittest_context.cc#newcode1134\ncc/trees/layer_tree_host_unittest_context.cc:1134: LayerTreeHostContextTestFailsFirstInitialization()\nnit: useless constructor/destructor can go away (shouldnt be there in the first place)\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/layer_tree_host_unittest_context.cc#newcode1164\ncc/trees/layer_tree_host_unittest_context.cc:1164: LayerTreeHostContextTestRetriesFirstInitializationAndSucceeds()\nconstructor can go away\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/layer_tree_host_unittest_context.cc#newcode1185\ncc/trees/layer_tree_host_unittest_context.cc:1185: LayerTreeHostContextTestRetryWorksWithForcedInit()\nand this one\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/layer_tree_host_unittest_context.cc#newcode1202\ncc/trees/layer_tree_host_unittest_context.cc:1202: layer_tree_host()->CompositeAndReadback(bitmap.getPixels(), rect);\nYou can just do this and avoid all the SkBitmap stuff, taken from lth_unittest.cc:\n\nchar pixels[4];\nlayer_tree_host()->CompositeAndReadback(&pixels, gfx::Rect(1, 1));\n\n\nIf you want to use the bitmap you did it right but:\n- omit the 4th argument to setConfig()\n- call bitmap.lockPixels() and unlockPixels() before/after the CompositeAndReadback().\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode184\ncc/trees/thread_proxy.cc:184: DCHECK(layer_tree_host_);\nNot sure why this dcheck, the lth is part of the constructor here. If anything do this in the constructor.\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode209\ncc/trees/thread_proxy.cc:209: // Make a blocking call to RecreateOutputSurfaceOnImplThread. The results of\nfix the name in this comment\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode210\ncc/trees/thread_proxy.cc:210: // that call are pushed into the recreate_succeeded and capabilities local\ns/recreate_succeeded/success/\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode1109\ncc/trees/thread_proxy.cc:1109: if (scheduler_on_impl_thread_->HasInitializedOutputSurface()) {\nWill this if() eever be true currently?\n\nIf we ever succeed, we reset the callback, which causes DoCreateAndInitOS() to not be called again. I feel like this is a remnant of the async patch, or is it needed for something else?\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.h\nFile cc/trees/thread_proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.h#newcode203\ncc/trees/thread_proxy.h:203: \nnit: extraneous whitespace","disapproval":false,"date":"2013-04-24 15:38:42.282050","approval":true},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"https://codereview.chromium.org/12544032/diff/151001/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/layer_tree_host_unittest_context.cc#newcode1202\ncc/trees/layer_tree_host_unittest_context.cc:1202: layer_tree_host()->CompositeAndReadback(bitmap.getPixels(), rect);\nOn 2013/04/24 15:38:42, danakj wrote:\n> char pixels[4];\n> layer_tree_host()->CompositeAndReadback(&pixels, gfx::Rect(1, 1));\n\nThis sounds way better. Also added EXPECT_FALSE to CompositeAndReadback since recreate is supposed to fail here\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode184\ncc/trees/thread_proxy.cc:184: DCHECK(layer_tree_host_);\nOn 2013/04/24 15:38:42, danakj wrote:\n> Not sure why this dcheck, the lth is part of the constructor here. If anything\n> do this in the constructor.\n\nThis is DCHECK-ing that Stop has not been called. After Stop, scheduler no longer exists, which means this can only be called from CompositeAndReadback, which already has a DCHECK for LTH. So yep, moving to constructor.\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode1109\ncc/trees/thread_proxy.cc:1109: if (scheduler_on_impl_thread_->HasInitializedOutputSurface()) {\nOn 2013/04/24 15:38:42, danakj wrote:\n> Will this if() eever be true currently?\n> \n> If we ever succeed, we reset the callback, which causes DoCreateAndInitOS() to\n> not be called again. I feel like this is a remnant of the async patch, or is it\n> needed for something else?\n\nYes this is needed to prevent re-initializing everything when the output surface is already active (ie DCHECK in scheduler DidCreateAndInitializeOutputSurface)\n\nThis is failing in LayerTreeHostTestDeviceScaleFactorScalesViewportAndLayers (and possibly other tests) which calls LTH::InitializeOutputSurfaceIfNeeded immediately after SetSurfaceReady in the same call stack. The flow goes like this:\n\n* SetSurfaceReady leads to scheduler posting a task to main thread to CreateAndInitializeOutputSurface\n* While this task is waiting in the queue, LTH::InitializeOutputSurfaceIfNeeded is called, successfully initializes output surface, advances scheduler to OUTPUT_SRUFACE_ACTIVE, and cancels the task.\n* CreateAndInitializeOutputSurface finally runs, resets the task, tell LTH that output surface is lost (even though it is not), and the proceeds to create again, and trips into this.\n\nIdealy we would be able to tell in CreateAndInitializeOutputSurface that between when it was scheduled and run, the output surface is recreated so there is no need to run again. So...make this a cancelable task and to be cancelled here if succeeds? I don't know if it can be used across threads like that?\n\n(Didn't do anything in this patch set)","disapproval":false,"date":"2013-04-24 17:48:19.947740","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"https://codereview.chromium.org/12544032/diff/158001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/158001/cc/trees/thread_proxy.cc#newcode247\ncc/trees/thread_proxy.cc:247: output_surface_creation_callback_.Cancel();\nShould we Cancel() if CreateFailedAndGiveUp too?\n\nI'm thinking about the bug for https://codereview.chromium.org/14238011/ what if we get the ordering like:\n\n- Lose context\n- DoCreateAndInit fails -> retry x1\n- DoCreateAndInit fails -> retry x2\n- DoCreateAndInit fails -> retry x3\n- DoCreateAndInit fails -> retry x4\n- DoCreateAndInit is post-tasked here.\n- CompositeAndReadback comes here, tries to init fails. That's the 5th failure, we DidRecreateOS(false) to the embedder.\n- DoCreateAndInit wakes up and runs, and succeeds.\n\nNow the compositor and the embedder disagree on things.","disapproval":false,"date":"2013-04-24 20:43:01.249140","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"https://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode1109\ncc/trees/thread_proxy.cc:1109: if (scheduler_on_impl_thread_->HasInitializedOutputSurface()) {\nOn 2013/04/24 17:48:20, boliu wrote:\n> On 2013/04/24 15:38:42, danakj wrote:\n> > Will this if() eever be true currently?\n> > \n> > If we ever succeed, we reset the callback, which causes DoCreateAndInitOS() to\n> > not be called again. I feel like this is a remnant of the async patch, or is\n> it\n> > needed for something else?\n> \n> Yes this is needed to prevent re-initializing everything when the output surface\n> is already active (ie DCHECK in scheduler DidCreateAndInitializeOutputSurface)\n> \n> This is failing in LayerTreeHostTestDeviceScaleFactorScalesViewportAndLayers\n> (and possibly other tests) which calls LTH::InitializeOutputSurfaceIfNeeded\n> immediately after SetSurfaceReady in the same call stack. The flow goes like\n> this:\n> \n> * SetSurfaceReady leads to scheduler posting a task to main thread to\n> CreateAndInitializeOutputSurface\n> * While this task is waiting in the queue, LTH::InitializeOutputSurfaceIfNeeded\n> is called, successfully initializes output surface, advances scheduler to\n> OUTPUT_SRUFACE_ACTIVE, and cancels the task.\n> * CreateAndInitializeOutputSurface finally runs, resets the task, tell LTH that\n> output surface is lost (even though it is not), and the proceeds to create\n> again, and trips into this.\n\nHm, that sounds awkward. Does that leave the LTH with output_surface_lost_ = true in the end? This is also just bad test behaviour..\n\nIf I remove this from the test you cite:\n\n-    ASSERT_TRUE(layer_tree_host()->InitializeRendererIfNeeded());\n-    ResourceUpdateQueue queue;\n-    layer_tree_host()->UpdateLayers(&queue, std::numeric_limits<size_t>::max());\n\nThe test passes fine still, and I don't see why that is there at all! It's super weird to call UpdateLayers() directly from a LTH test.\n\nWe should fix the tests that hit this path I think rather than coding support for it into the proxy, if possible. Can you take a look at the other tests, or post a list of them? I can help out if you like.\n\n> Idealy we would be able to tell in CreateAndInitializeOutputSurface that between\n> when it was scheduled and run, the output surface is recreated so there is no\n> need to run again. So...make this a cancelable task and to be cancelled here if\n> succeeds? I don't know if it can be used across threads like that?\n> \n> (Didn't do anything in this patch set)","disapproval":false,"date":"2013-04-24 21:01:00.382210","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Question: Now we retry 5 times before stopping. What if the error is in CreateOutputSurface failing to create the WGC3D. In this case, we will try to create a new GPU process 5 times.\n\nWe are hitting this pathological case on linux_chromeos try bot, were gl initialization fails. Now we are telling render widget/host accelerated compositing is enabled while waiting for 5 failures. This is causing some flakiness on integration tests on the bot due to this addional churn.\n\nAlso in this case, render widget never used to send accelerated compositing enabled message to the host, which is also causing some linux_chromeos tests to fail (crbug.com/234042)\n\nI know these are really test issues, they are blocking this from landing. Should we re-evaluate if we should be retrying on this case?\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode1109\ncc/trees/thread_proxy.cc:1109: if (scheduler_on_impl_thread_->HasInitializedOutputSurface()) {\nOn 2013/04/24 21:01:00, danakj wrote:\n> Hm, that sounds awkward. Does that leave the LTH with output_surface_lost_ =\n> true in the end?\n\nNope, we are setting *success = true here.\n\n> This is also just bad test behaviour..\n> \n> If I remove this from the test you cite:\n> \n> -    ASSERT_TRUE(layer_tree_host()->InitializeRendererIfNeeded());\n> -    ResourceUpdateQueue queue;\n> -    layer_tree_host()->UpdateLayers(&queue,\n> std::numeric_limits<size_t>::max());\n> \n> The test passes fine still, and I don't see why that is there at all! It's super\n> weird to call UpdateLayers() directly from a LTH test.\n> \n> We should fix the tests that hit this path I think rather than coding support\n> for it into the proxy, if possible. Can you take a look at the other tests, or\n> post a list of them? I can help out if you like.\n\nSo how does the embedder know when is it safe to call CompositeAndReadback? Is this case impossible in practice?\n\nHere's the rest of the list and how I fixed them:\n\n* LayerTreeHostTestCompositeAndReadbackCleanup - Move test to DidRecreateOutputSurface hook so CompositeAndReadback is not force initializing output surface.\n* LayerTreeHostTestCapturePicture - Remove InitializeOutputIfNeeded call, nothing broke\n* ScrollbarLayerTestMaxTextureSize - Remove InitializeOutputIfNeeded call, nothing broke\n\nhttps://codereview.chromium.org/12544032/diff/158001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/158001/cc/trees/thread_proxy.cc#newcode247\ncc/trees/thread_proxy.cc:247: output_surface_creation_callback_.Cancel();\nOn 2013/04/24 20:43:01, danakj wrote:\n> Should we Cancel() if CreateFailedAndGiveUp too?\n> \n> I'm thinking about the bug for https://codereview.chromium.org/14238011/ what if\n> we get the ordering like:\n> \n> - Lose context\n> - DoCreateAndInit fails -> retry x1\n> - DoCreateAndInit fails -> retry x2\n> - DoCreateAndInit fails -> retry x3\n> - DoCreateAndInit fails -> retry x4\n> - DoCreateAndInit is post-tasked here.\n> - CompositeAndReadback comes here, tries to init fails. That's the 5th failure,\n> we DidRecreateOS(false) to the embedder.\n> - DoCreateAndInit wakes up and runs, and succeeds.\n> \n> Now the compositor and the embedder disagree on things.\n\nDone.\n\nMaybe we should do something more drastic like stopping thread_proxy? I'm not sure...","disapproval":false,"date":"2013-04-24 22:01:00.446860","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"On 2013/04/24 22:01:00, boliu wrote:\n> Question: Now we retry 5 times before stopping. What if the error is in\n> CreateOutputSurface failing to create the WGC3D. In this case, we will try to\n> create a new GPU process 5 times.\n> \n> We are hitting this pathological case on linux_chromeos try bot, were gl\n> initialization fails. Now we are telling render widget/host accelerated\n> compositing is enabled while waiting for 5 failures. This is causing some\n> flakiness on integration tests on the bot due to this addional churn.\n> \n> Also in this case, render widget never used to send accelerated compositing\n> enabled message to the host, which is also causing some linux_chromeos tests to\n> fail (crbug.com/234042)\n> \n> I know these are really test issues, they are blocking this from landing. Should\n> we re-evaluate if we should be retrying on this case?\n\nHm, so turns out the return value from LTH::Create() is pretty important.\n\nThere's 2 scenarios:\n\n1) The context creation fails. We should not retry and and LTH::Create() should return false to match previous expectations and not try create GPU process over and over.\n\n2) The creation works but it gets lost quickly after before we can init the renderer. We should retry in this case.\n\nThere used to be some logic in the proxies that held onto an OutputSurface* that was created in LTH::Create() in order to make 1) happen. We could retain that by having the proxy only call LTH::CreateOutputSurface when it doesn't have an OutputSurface* already, provided from the LTH::Create() path.\n\nThen, the first time you go to DoCreateAndInitOutputSurface, you could skip the create step. The next time around it would be gone and youd have to CreateOutputSurface() again.\n\nWhat do you think of that?\n\n> > I'm thinking about the bug for https://codereview.chromium.org/14238011/ what\n> if\n> > we get the ordering like:\n> > \n> > - Lose context\n> > - DoCreateAndInit fails -> retry x1\n> > - DoCreateAndInit fails -> retry x2\n> > - DoCreateAndInit fails -> retry x3\n> > - DoCreateAndInit fails -> retry x4\n> > - DoCreateAndInit is post-tasked here.\n> > - CompositeAndReadback comes here, tries to init fails. That's the 5th\n> failure,\n> > we DidRecreateOS(false) to the embedder.\n> > - DoCreateAndInit wakes up and runs, and succeeds.\n> > \n> > Now the compositor and the embedder disagree on things.\n> \n> Done.\n> \n> Maybe we should do something more drastic like stopping thread_proxy? I'm not\n> sure...\n\nI think the solution to https://codereview.chromium.org/14238011/ can also apply here. The DoCreateAndInit method should be verifying that the LTH hasn't told its client that it's giving up on life before trying to init. The cancel solves that for now (thanks) but we could DCHECK and early-out in DoCreateAndInit if the LTH has already done DidRecreateOS(false). WDYT of that?\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc\nFile cc/trees/thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/151001/cc/trees/thread_proxy.cc#newcode1109\ncc/trees/thread_proxy.cc:1109: if (scheduler_on_impl_thread_->HasInitializedOutputSurface()) {\nOn 2013/04/24 22:01:00, boliu wrote:\n> So how does the embedder know when is it safe to call CompositeAndReadback? Is\n> this case impossible in practice?\n\nYou're right it should be able to call it immediately. I didn't think of the Comp&Readback case immediately after creation.\n\n> \n> Here's the rest of the list and how I fixed them:\n> \n> * LayerTreeHostTestCompositeAndReadbackCleanup - Move test to\n> DidRecreateOutputSurface hook so CompositeAndReadback is not force initializing\n> output surface.\n\nThis one feels wrong, I guess we need to handle this case. I'm glad we have some test coverage of this. I guess in this case we're going to end up calling DidRecreateOutputSurface(true) an extra time for no reason too since we told LTH it lost the context but actually didn't.. doh.\n\nCancellable callback is not threadsafe so it's not something we can use to solve this unfortunately.\n\nSo the problem is basically impl side can tell main thread to create output surface. By the time it gets to that task, it may have already done it, and how can it tell. We need some kind of extra syncronization between threads. We could use a lock and a variable or some kind to signal, but that's kinda ugly.\n\nWhat if the first thing CreateAndInitializeOutputSurface() did was to block the main thread and jump to the impl thread and query if we have an output surface. And then if we do, just early out. That would remove race conditions with the main thread doing it in between, and avoid an extra DidLose() and DidRecreate() from going on.\n\n\n> * LayerTreeHostTestCapturePicture - Remove InitializeOutputIfNeeded call,\n> nothing broke\n> * ScrollbarLayerTestMaxTextureSize - Remove InitializeOutputIfNeeded call,\n> nothing broke\n\nThose look fine to me.","disapproval":false,"date":"2013-04-24 23:17:13.383640","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"On 2013/04/24 23:17:13, danakj wrote:\n> 1) The context creation fails. We should not retry and and LTH::Create() should\n> return false to match previous expectations and not try create GPU process over\n> and over.\n> \n> 2) The creation works but it gets lost quickly after before we can init the\n> renderer. We should retry in this case.\n> \n> There used to be some logic in the proxies that held onto an OutputSurface* that\n> was created in LTH::Create() in order to make 1) happen. We could retain that by\n> having the proxy only call LTH::CreateOutputSurface when it doesn't have an\n> OutputSurface* already, provided from the LTH::Create() path.\n> \n> Then, the first time you go to DoCreateAndInitOutputSurface, you could skip the\n> create step. The next time around it would be gone and youd have to\n> CreateOutputSurface() again.\n> \n> What do you think of that?\n\nUnfortunate but seems necessary at this stage. Makes this patch less lovable. And I think Vangelis was suggesting this could improve start up time: https://code.google.com/p/chromium/issues/detail?id=230197#c4  Oh well...\n\nMaybe a better long term solution would be to let embedder set how many times to retry. It can start with 0 and RenderWidget can set it to 5 after first OutputSurface created.\n\nBut should definitely fix linux_chromeos first though. It's relying on the fact that we fail synchronously and never enter into accelerated compositing mode. Probably much better to set a flag on that bot to disable accelerated compositing if that's what the bot needs, not try to start gpu and assume failure is synchronous.\n\n\n> I think the solution to https://codereview.chromium.org/14238011/ can also apply\n> here. The DoCreateAndInit method should be verifying that the LTH hasn't told\n> its client that it's giving up on life before trying to init. The cancel solves\n> that for now (thanks) but we could DCHECK and early-out in DoCreateAndInit if\n> the LTH has already done DidRecreateOS(false). WDYT of that?\n\nSG\n\n> This one feels wrong, I guess we need to handle this case. I'm glad we have some\n> test coverage of this. I guess in this case we're going to end up calling\n> DidRecreateOutputSurface(true) an extra time for no reason too since we told LTH\n> it lost the context but actually didn't.. doh.\n> \n> Cancellable callback is not threadsafe so it's not something we can use to solve\n> this unfortunately.\n> \n> So the problem is basically impl side can tell main thread to create output\n> surface. By the time it gets to that task, it may have already done it, and how\n> can it tell. We need some kind of extra syncronization between threads. We could\n> use a lock and a variable or some kind to signal, but that's kinda ugly.\n> \n> What if the first thing CreateAndInitializeOutputSurface() did was to block the\n> main thread and jump to the impl thread and query if we have an output surface.\n> And then if we do, just early out. That would remove race conditions with the\n> main thread doing it in between, and avoid an extra DidLose() and DidRecreate()\n> from going on.\n> \n\nDone\n\nAnother idea floating around in my head to avoid this synchronization: Take a timestamp of when CreateAndInitializeOutputSurface is posted by scheduler, and when last time output_surface_lost is set to false on main thread, then just compare them. But it's assuming timestamps have enough resolution, and seems like a can of worms to maintain.","disapproval":false,"date":"2013-04-25 01:03:35.240340","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"This patch LGTM. One request for a one last test to watch for the race condition we've solved for CreateAndInitOS() after CompositeAndReadback().\n\njamesr@ please take a look too!\n\nOn 2013/04/25 01:03:35, boliu wrote:\n> On 2013/04/24 23:17:13, danakj wrote:\n> > 1) The context creation fails. We should not retry and and LTH::Create()\n> should\n> > return false to match previous expectations and not try create GPU process\n> over\n> > and over.\n> > \n> > 2) The creation works but it gets lost quickly after before we can init the\n> > renderer. We should retry in this case.\n> > \n> > There used to be some logic in the proxies that held onto an OutputSurface*\n> that\n> > was created in LTH::Create() in order to make 1) happen. We could retain that\n> by\n> > having the proxy only call LTH::CreateOutputSurface when it doesn't have an\n> > OutputSurface* already, provided from the LTH::Create() path.\n> > \n> > Then, the first time you go to DoCreateAndInitOutputSurface, you could skip\n> the\n> > create step. The next time around it would be gone and youd have to\n> > CreateOutputSurface() again.\n> > \n> > What do you think of that?\n> \n> Unfortunate but seems necessary at this stage. Makes this patch less lovable.\n> And I think Vangelis was suggesting this could improve start up time:\n> https://code.google.com/p/chromium/issues/detail?id=230197#c4  Oh well...\n> \n> Maybe a better long term solution would be to let embedder set how many times to\n> retry. It can start with 0 and RenderWidget can set it to 5 after first\n> OutputSurface created.\n> \n> But should definitely fix linux_chromeos first though. It's relying on the fact\n> that we fail synchronously and never enter into accelerated compositing mode.\n> Probably much better to set a flag on that bot to disable accelerated\n> compositing if that's what the bot needs, not try to start gpu and assume\n> failure is synchronous.\n\nI don't think it makes this patch so bad :) I like the idea of splitting that behaviour change into a separate step. If we can always tell ahead of time when LTH::Create() is going to fail and avoid calling it altogether, that sounds good to me..\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host.cc\nFile cc/trees/layer_tree_host.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host.cc#newcode725\ncc/trees/layer_tree_host.cc:725: if (!renderer_can_be_initialized_)\nguess this should rename to like output_surface_can_be_initialized to be consistent with these changes\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host_unittest.cc\nFile cc/trees/layer_tree_host_unittest.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host_unittest.cc#newcode1228\ncc/trees/layer_tree_host_unittest.cc:1228: class LayerTreeHostTestCompositeAndReadbackCleanup : public LayerTreeHostTest {\nCould you add a test similar to this to the LTHContextTests, but that does not EndTest() until DidCommitAndDrawFrame() happens, and verifies that DidRecreateOS(true) is only happening a single time?\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host_unittest_context.cc#newcode1134\ncc/trees/layer_tree_host_unittest_context.cc:1134: : LayerTreeHostContextTest() {\nnit: don't need to explcitly name the parent constructor (i learnt this recently :))\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/single_thread_proxy.cc\nFile cc/trees/single_thread_proxy.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/single_thread_proxy.cc#newcode51\ncc/trees/single_thread_proxy.cc:51: DCHECK(!layer_tree_host_impl_.get());\nnit: don't need the .get() while you're here","disapproval":false,"date":"2013-04-25 15:16:48.872170","approval":true},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Two new tests:\n\nLayerTreeHostContextTestCompositeAndReadbackBeforeOutputSurfaceInit to explicitly test CompositeAndReadback initializes OutputSurface before the scheduler's posted task runs.\n\nLayerTreeHostTestCannotCreateIfCannotCreateOutputSurface to test if OutputSurface cannot be created by LTHClient, then fail create LTH. Can't reuse the LayerTreeTest harness for this because LTT always expects LTH::Create to succeed, which is a good assumption for all other tests.\n\nJames: PTAL\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/178001/cc/trees/layer_tree_host_unittest_context.cc#newcode1134\ncc/trees/layer_tree_host_unittest_context.cc:1134: : LayerTreeHostContextTest() {\nOn 2013/04/25 15:16:49, danakj wrote:\n> nit: don't need to explcitly name the parent constructor (i learnt this recently\n> :))\n\n!! Under what conditions is it safe to do this? When the base class has a default consturctor, and...? Is there a link/discussion I can read?","disapproval":false,"date":"2013-04-25 17:25:11.256300","approval":false},{"sender":"danakj@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Thanks :) New tests LGTM, I'm glad you did the 2nd one outside of the LayerTreeTest system.\n\nhttps://codereview.chromium.org/12544032/diff/183001/cc/trees/layer_tree_host_unittest_context.cc\nFile cc/trees/layer_tree_host_unittest_context.cc (right):\n\nhttps://codereview.chromium.org/12544032/diff/183001/cc/trees/layer_tree_host_unittest_context.cc#newcode1225\ncc/trees/layer_tree_host_unittest_context.cc:1225: EXPECT_EQ(1, times_output_surface_created_);\nCan you move this to AfterTest() in case it does recreate a 2nd time but doesn't draw again because of the test ending?","disapproval":false,"date":"2013-04-25 17:36:46.278020","approval":true},{"sender":"jamesr@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"lgtm2! Thank you for persisting with this and thank you Dana for all the reviews.\n\nhttps://codereview.chromium.org/12544032/diff/190001/cc/trees/proxy.h\nFile cc/trees/proxy.h (right):\n\nhttps://codereview.chromium.org/12544032/diff/190001/cc/trees/proxy.h#newcode65\ncc/trees/proxy.h:65: // LayerTreeHost::OnCreateAndInitializeOutputSurfaceAttemptedwith the result.\ntypo \"...Attemptedwith\"","disapproval":false,"date":"2013-04-25 18:04:53.744950","approval":true},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"And thanks for all the guidance and timely reviews.","disapproval":false,"date":"2013-04-25 18:11:29.625410","approval":false},{"sender":"commit-bot@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/boliu@chromium.org/12544032/142002","disapproval":false,"date":"2013-04-25 18:11:49.676930","approval":false},{"sender":"commit-bot@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Change committed as 196480","disapproval":false,"date":"2013-04-25 20:29:10.187150","approval":false},{"sender":"boliu@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Reopening in preparation for reland. Added this to the description:\n\nFirst commited in r196480. Reverted in r196509 due to exposing \nWebGLInfobarTest that should never have passed on asan. Disable \nthem on asan: https://codereview.chromium.org/14499007/","disapproval":false,"date":"2013-04-25 23:23:43.602980","approval":false},{"sender":"commit-bot@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/boliu@chromium.org/12544032/213002","disapproval":false,"date":"2013-04-26 10:09:14.174450","approval":false},{"sender":"commit-bot@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Change committed as 196708","disapproval":false,"date":"2013-04-26 12:34:57.607630","approval":false},{"sender":"commit-bot@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/boliu@chromium.org/12544032/213002","disapproval":false,"date":"2013-04-30 23:14:48.842000","approval":false},{"sender":"commit-bot@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"CQ is trying da patch. Follow status at\nhttps://chromium-status.appspot.com/cq/boliu@chromium.org/12544032/237001","disapproval":false,"date":"2013-05-01 00:31:58.302870","approval":false},{"sender":"commit-bot@chromium.org","recipients":["boliu@chromium.org","jamesr@chromium.org","danakj@chromium.org","chromium-reviews@chromium.org","cc-bugs@chromium.org","aelias@chromium.org"],"text":"Change committed as 197550","disapproval":false,"date":"2013-05-01 03:13:25.753280","approval":false}],"owner_email":"boliu@chromium.org","private":false,"base_url":"svn://svn.chromium.org/chrome/trunk/src","owner":"boliu","subject":"Initialize cc::Renderer in vsync","created":"2013-03-22 23:00:26.968720","patchsets":[1,5001,9001,16001,20001,22001,24001,26001,28001,32001,43001,57001,64001,72001,73028,83001,87001,92001,95001,98001,100001,103001,105001,107001,119001,120001,123001,126001,129001,133002,151001,158001,162001,163001,166001,169001,121021,161002,66003,178001,183001,190001,142002,213002,237001],"modified":"2013-05-01 03:13:25.852340","closed":true,"commit":false,"issue":12544032}