{"description":"Add storage code to appcache update process.\nAdd storage API for simulating storage errors.\n\nTEST=verify appcache update wrote to storage correctly\nBUG=none\n\n\nCommitted: http://src.chromium.org/viewvc/chrome?view=rev&revision=30612","cc":["chromium-reviews@googlegroups.com","darin@chromium.org"],"reviewers":["michaeln@chromium.org"],"messages":[{"sender":"michaeln@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"http://codereview.chromium.org/326002/diff/1/3\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/1/3#newcode55\nLine 55: bytes_to_write_ = 0;\nThis data member access is iffy... see comments below.\n\nhttp://codereview.chromium.org/326002/diff/1/3#newcode224\nLine 224: OnResponseCompleted(request);\nhere's another delete request (and info) code path\n\nhttp://codereview.chromium.org/326002/diff/1/3#newcode270\nLine 270: OnResponseCompleted(request);\nSince this can delete the 'request', which will delete the 'info', the UpdateJobInfo::OnWriteComplete has to be very careful to not access it's data members upon return from OnWriteResposneComplete.\n\nhttp://codereview.chromium.org/326002/diff/1/3#newcode281\nLine 281: ReadResponseData(request);\nThis too can result in 'delete request'.","disapproval":false,"date":"2009-10-23 00:58:16.748468","approval":false},{"sender":"jennb@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"Completed the work for this CL.  I have code in here that cleans up responses.  Should I take it out?","disapproval":false,"date":"2009-10-28 01:45:33.414699","approval":false},{"sender":"michaeln@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"not a full review yet... but here is a round of comments\n\nhttp://codereview.chromium.org/326002/diff/3001/4002\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode40\nLine 40: void SetUpResponseWriter(AppCacheResponseWriter* writer,\nnit: Setup... but i see both SetUp and Setup in use in the code base\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode49\nLine 49: write_callback_.reset(new net::CompletionCallbackImpl<UpdateJobInfo>(\nits much more common to define storage for CallbackImpls inline rather than heap allocate them...\n\nclass UpdateJobInfo {\n  UpdateJobInfo() \n      : bar_(0),\n        ALLOW_THIS_IN_INITIALIZER_LIST(\n            write_callback_(this, &UpdateJobInfo::OnWriteComplete)) {\n  }\n\n  int bar_;\n  net::CompletionCallbackImpl<UpdateJobInfo> write_callback_;\n};\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode68\nLine 68: int bytes_to_write_;  // remember data bytes while writing http response info\nis this really specific to 'response info' or is this for the 'data'... oh i see (after looking at the callsite)... after 'info' is written then you write this amount of 'data'.\n\nthat's a little awkward?\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode232\nLine 232: int bytes_read) {\nCan you add a DCHECK(bytes_read > 0) here so readers know w/o examining the callsite?\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode239\nLine 239: return false;  // wait for async storage callback\nnit: maybe \"wait for async completion to continue reading\"... if it fits on the line?\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode467\nLine 467: entry.set_response_id(info->response_writer_.get()->response_id());\nresponse_writer_-> should work here\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode482\nLine 482: // might be smart enough to discard uncommitted writes?)\ni think we can leave this out for now, and revisit if needed when we get to persistent storage... wdyt?\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode549\nLine 549: manifest_response_writer_.get()->WriteData(\ndon't need the .get() on the smart ptr\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode551\nLine 551: new net::CompletionCallbackImpl<AppCacheUpdateJob>(\nditto... more common to define inline","disapproval":false,"date":"2009-10-28 21:19:52.298280","approval":false},{"sender":"michaeln@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"some more comments\n\nhttp://codereview.chromium.org/326002/diff/3001/4002\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode68\nLine 68: int bytes_to_write_;  // remember data bytes while writing http response info\nmaybe call this 'initial_bytes_to_write_', and instead of delivering the value back to the UpdateJob via an argument in each call to OnWriteReponseComplete, have that method check for a non-zero value in the info class... or maybe have a seperate UpdateJob method for OnWriteResponseInfoComplete? Something like that may be less awkward... wdyt?\n\nInfo::OnWriteComplete(int result) {\n if (initial_bytes_to_write_)\n    update_job_->OnWriteResponseInfoComplete(result, info);\n else\n    update_job_->OnWriteResponseComplete(result, info);\n}\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode256\nLine 256: info->response_writer_.get()->WriteInfo(\nHow you're handling the refcounted ioBuffer parameter is susceptible to leaks. If the callee doesn't take then later release a ref to the ioBuffer, the object will be leaked. There are code paths where the callee may skip the taking a ref of its own. A safer pattern is to load the newly created refcounted object into a scoped_refptr in the current scope as follows...\n\nscoped_refptr<HttpResponseInfoIOBuffer> info_buffer(new ...);\ninfo->response_writer_->WriteInfo(info_buffer, callback);\n\n... on exit from the current scope, Release will get called and if the callee didn't take a ref of its own, the object will be deleted.\n\nDitto other refcounted info ioBuffer arg usages for the writing of the manifest entry.\n\n\nAlso, with the smart ptr, you don't need to the .get() to invoke the method.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode536\nLine 536: new net::CompletionCallbackImpl<AppCacheUpdateJob>(\nditto... more common to define inline\n\nalso, where is this heap allocated block deleted?\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode577\nLine 577: service_->storage()->StoreGroupAndNewestCache(group_, this);  // async\nI think we may have some racey'ness here, and I missed this in the design of the storage APIs :(\n\nOur data structures can get into an inconsistent state if the the store call fails. The in-memory group will reflect the new cache, but that's not how it is on disk, and thats not how it will look after the group falls out of the working-set and gets reloaded into memory.\n\nThoughts?\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode868\nLine 868: // has not been committed by actually writing the cache to storage?)\nditto","disapproval":false,"date":"2009-10-28 21:57:25.376432","approval":false},{"sender":"jennb@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"New patch uploaded.  Ignore patch 3 and go straight to patch 4  - I thought of a couple more tests right after uploading patch 3 and made 2 back-to-back uploads.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode40\nLine 40: void SetUpResponseWriter(AppCacheResponseWriter* writer,\nOn 2009/10/28 21:19:52, michaeln wrote:\n> nit: Setup... but i see both SetUp and Setup in use in the code base\n\nI was once lectured: \"set up\" is a verb, \"setup\" is a noun.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode49\nLine 49: write_callback_.reset(new net::CompletionCallbackImpl<UpdateJobInfo>(\nOn 2009/10/28 21:19:52, michaeln wrote:\n> its much more common to define storage for CallbackImpls inline rather than heap\n> allocate them...\n> \n> class UpdateJobInfo {\n>   UpdateJobInfo() \n>       : bar_(0),\n>         ALLOW_THIS_IN_INITIALIZER_LIST(\n>             write_callback_(this, &UpdateJobInfo::OnWriteComplete)) {\n>   }\n> \n>   int bar_;\n>   net::CompletionCallbackImpl<UpdateJobInfo> write_callback_;\n> };\n> \n> \n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode68\nLine 68: int bytes_to_write_;  // remember data bytes while writing http response info\nOn 2009/10/28 21:19:52, michaeln wrote:\n> is this really specific to 'response info' or is this for the 'data'... oh i see\n> (after looking at the callsite)... after 'info' is written then you write this\n> amount of 'data'.\n> \n> that's a little awkward?\n\nReworked flow to write all data first, then write response info.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode232\nLine 232: int bytes_read) {\nOn 2009/10/28 21:19:52, michaeln wrote:\n> Can you add a DCHECK(bytes_read > 0) here so readers know w/o examining the\n> callsite?\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode239\nLine 239: return false;  // wait for async storage callback\nOn 2009/10/28 21:19:52, michaeln wrote:\n> nit: maybe \"wait for async completion to continue reading\"... if it fits on the\n> line?\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode256\nLine 256: info->response_writer_.get()->WriteInfo(\nOn 2009/10/28 21:57:25, michaeln wrote:\n> How you're handling the refcounted ioBuffer parameter is susceptible to leaks.\n> If the callee doesn't take then later release a ref to the ioBuffer, the object\n> will be leaked. There are code paths where the callee may skip the taking a ref\n> of its own. A safer pattern is to load the newly created refcounted object into\n> a scoped_refptr in the current scope as follows...\n> \n> scoped_refptr<HttpResponseInfoIOBuffer> info_buffer(new ...);\n> info->response_writer_->WriteInfo(info_buffer, callback);\n> \n> ... on exit from the current scope, Release will get called and if the callee\n> didn't take a ref of its own, the object will be deleted.\n> \n> Ditto other refcounted info ioBuffer arg usages for the writing of the manifest\n> entry.\n> \n> \n> Also, with the smart ptr, you don't need to the .get() to invoke the method.\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode467\nLine 467: entry.set_response_id(info->response_writer_.get()->response_id());\nOn 2009/10/28 21:19:52, michaeln wrote:\n> response_writer_-> should work here\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode482\nLine 482: // might be smart enough to discard uncommitted writes?)\nOn 2009/10/28 21:19:52, michaeln wrote:\n> i think we can leave this out for now, and revisit if needed when we get to\n> persistent storage... wdyt?\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode536\nLine 536: new net::CompletionCallbackImpl<AppCacheUpdateJob>(\nOn 2009/10/28 21:57:25, michaeln wrote:\n> ditto... more common to define inline\n> \n> also, where is this heap allocated block deleted?\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode549\nLine 549: manifest_response_writer_.get()->WriteData(\nOn 2009/10/28 21:19:52, michaeln wrote:\n> don't need the .get() on the smart ptr\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode551\nLine 551: new net::CompletionCallbackImpl<AppCacheUpdateJob>(\nOn 2009/10/28 21:19:52, michaeln wrote:\n> ditto... more common to define inline\n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode577\nLine 577: service_->storage()->StoreGroupAndNewestCache(group_, this);  // async\nOn 2009/10/28 21:57:25, michaeln wrote:\n> I think we may have some racey'ness here, and I missed this in the design of the\n> storage APIs :(\n> \n> Our data structures can get into an inconsistent state if the the store call\n> fails. The in-memory group will reflect the new cache, but that's not how it is\n> on disk, and thats not how it will look after the group falls out of the\n> working-set and gets reloaded into memory.\n> \n> Thoughts?\n\nAdded code to restore in-memory state of group upon storage failure.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode868\nLine 868: // has not been committed by actually writing the cache to storage?)\nOn 2009/10/28 21:57:25, michaeln wrote:\n> ditto\n\nDone.","disapproval":false,"date":"2009-10-29 21:25:40.588635","approval":false},{"sender":"michaeln@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"http://codereview.chromium.org/326002/diff/3001/4002\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode577\nLine 577: service_->storage()->StoreGroupAndNewestCache(group_, this);  // async\n\n> Added code to restore in-memory state of group upon storage failure.\n\nI think this is OK for now, but its still racey. Can you add a TODO here to revisit at a later date?\n\nhttp://codereview.chromium.org/326002/diff/12001/13002#newcode281\nLine 281: return;\nCan the request be complete prior to the caller having read everything out of it? I'm not sure. Should we read until we hit EOF instead?\n\nhttp://codereview.chromium.org/326002/diff/12001/13005\nFile webkit/appcache/mock_appcache_storage.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/12001/13005#newcode162\nLine 162: delegate_ref->delegate) {\nyou could go down this code path even if the delegate_ref has been dropped... so...\n\nif (simulate_failure) {\n  if (delegate_ref->delegate()\n    call it\n}\n\nSo long as simulate_failure was on... the ops would fail regardless of delegate_ref status.","disapproval":false,"date":"2009-10-30 00:25:30.834853","approval":false},{"sender":"jennb@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"New patch uploaded.\n\nhttp://codereview.chromium.org/326002/diff/3001/4002\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/3001/4002#newcode577\nLine 577: service_->storage()->StoreGroupAndNewestCache(group_, this);  // async\nOn 2009/10/30 00:25:30, michaeln wrote:\n> \n> > Added code to restore in-memory state of group upon storage failure.\n> \n> I think this is OK for now, but its still racey. Can you add a TODO here to\n> revisit at a later date?\n> \n\nDone.\n\nhttp://codereview.chromium.org/326002/diff/12001/13002#newcode281\nLine 281: return;\nOn 2009/10/30 00:25:31, michaeln wrote:\n> Can the request be complete prior to the caller having read everything out of\n> it? I'm not sure. Should we read until we hit EOF instead?\n\nReworked. Now info is written immediately after first data write completes and we read to EOF. Trying to do all of one and then the other seemed logically simpler, but turned out messier in code.\n\nhttp://codereview.chromium.org/326002/diff/12001/13005\nFile webkit/appcache/mock_appcache_storage.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/12001/13005#newcode162\nLine 162: delegate_ref->delegate) {\nOn 2009/10/30 00:25:31, michaeln wrote:\n> you could go down this code path even if the delegate_ref has been dropped...\n> so...\n> \n> if (simulate_failure) {\n>   if (delegate_ref->delegate()\n>     call it\n> }\n> \n> So long as simulate_failure was on... the ops would fail regardless of\n> delegate_ref status.\n\nDone.","disapproval":false,"date":"2009-10-30 17:31:17.529974","approval":false},{"sender":"michaeln@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"LGTM (one minor style thing)\n\nhttp://codereview.chromium.org/326002/diff/9002/9004\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/9002/9004#newcode240\nLine 240: this, request);\nindents are off here","disapproval":false,"date":"2009-10-30 18:48:16.692818","approval":true},{"sender":"jennb@chromium.org","recipients":["jennb@chromium.org","michaeln@chromium.org","chromium-reviews@googlegroups.com","darin@chromium.org"],"text":"http://codereview.chromium.org/326002/diff/9002/9004\nFile webkit/appcache/appcache_update_job.cc (right):\n\nhttp://codereview.chromium.org/326002/diff/9002/9004#newcode240\nLine 240: this, request);\nOn 2009/10/30 18:48:16, michaeln wrote:\n> indents are off here\n\nDone.","disapproval":false,"date":"2009-10-30 18:50:33.529490","approval":false}],"owner_email":"jennb@chromium.org","private":false,"base_url":"svn://chrome-svn/chrome/trunk/src/","owner":"jennb","subject":"Add storage code to appcache update process.","created":"2009-10-23 00:30:57.776788","patchsets":[1,3001,4005,12001,9002],"modified":"2011-06-01 03:24:20.322152","closed":true,"commit":false,"issue":326002}